<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教书的先生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-29T11:11:08.869Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王荣胜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Numpy</title>
    <link href="http://yoursite.com/2019/09/28/%E5%88%9D%E8%AF%86Numpy/"/>
    <id>http://yoursite.com/2019/09/28/初识Numpy/</id>
    <published>2019-09-28T01:19:02.000Z</published>
    <updated>2019-09-29T11:11:08.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Numpy简介"><a href="#Numpy简介" class="headerlink" title="Numpy简介"></a>Numpy简介</h2><p>NumPy 是 Numerical Python 的简称，它是 Python 中的科学计算基本软件包。NumPy 为 Python 提供了大量数学库，使我们能够高效地进行数字计算。更多可点击<a href="http://www.numpy.org" target="_blank" rel="noopener">Numpy官网</a> 查看。</p><a id="more"></a><p>关于Numpy需要知道的几点：</p><ul><li><p>NumPy 数组在创建时有固定的大小，不同于Python列表（可以动态增长）。更改ndarray的大小将创建一个新的数组并删除原始数据。</p></li><li><p>NumPy 数组中的元素都需要具有相同的数据类型，因此在存储器中将具有相同的大小。数组的元素如果也是数组（可以是 Python 的原生 array，也可以是 ndarray）的情况下，则构成了多维数组。</p></li><li><p>NumPy 数组便于对大量数据进行高级数学和其他类型的操作。通常，这样的操作比使用Python的内置序列可能更有效和更少的代码执行。</p></li></ul><p>所以，Numpy 的核心是ndarray对象，这个对象封装了同质数据类型的n维数组。起名 ndarray 的原因就是因为是 n-dimension-array 的简写。接下来本节所有的课程都是围绕着ndarray来讲的，理论知识较少，代码量较多，所以大家在学习的时候，多自己动动手，尝试自己去运行一下代码。</p><h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><ul><li>由python list创建</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 1维数组</span></span><br><span class="line">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  </span><br><span class="line">print(type(a), a.shape, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>'&gt; <span class="hljs-params">(<span class="hljs-number">3</span>,)</span> 1 2 3</span></span><br><span class="line"><span class="hljs-class"></span></span><br><span class="line"><span class="hljs-class"># 重新赋值</span></span><br><span class="line">a[0] = 5                 </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2维数组</span></span><br><span class="line">b = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])   </span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</span><br><span class="line"> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]</span><br><span class="line"></span><br><span class="line">print(b[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><ul><li>由numpy内置函数创建</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 创建2x2的全0数组</span></span><br><span class="line">a = np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))  </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">0.</span>  <span class="hljs-number">0.</span>]</span><br><span class="line"> [ <span class="hljs-number">0.</span>  <span class="hljs-number">0.</span>]]</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment"># 创建1x2的全1数组</span></span><br><span class="line">b = np.ones((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))  </span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">1.</span>  <span class="hljs-number">1.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 创建2x2定值为7的数组</span></span><br><span class="line">c = np.full((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), <span class="hljs-number">7</span>) </span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">7</span> <span class="hljs-number">7</span>]</span><br><span class="line"> [<span class="hljs-number">7</span> <span class="hljs-number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 创建2x2的单位矩阵（对角元素为1）</span></span><br><span class="line">d = np.eye(<span class="hljs-number">2</span>)        </span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">1.</span>  <span class="hljs-number">0.</span>]</span><br><span class="line"> [ <span class="hljs-number">0.</span>  <span class="hljs-number">1.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个对角线为10,20,30,50的对角矩阵</span></span><br><span class="line">d_1 = np.diag([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>]) </span><br><span class="line">print(d_1)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">10</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</span><br><span class="line"> [ <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</span><br><span class="line"> [ <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30</span> <span class="hljs-number">0</span>]</span><br><span class="line"> [ <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">50</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的0-14的数组</span></span><br><span class="line">e = np.arange(<span class="hljs-number">15</span>)   </span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的4-9的数组</span></span><br><span class="line">e_1 = np.arange(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>)  </span><br><span class="line">print(e_1)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的1-13且以间隔为3的数组</span></span><br><span class="line">e_2 = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-number">3</span>)  </span><br><span class="line">print(e_2)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[ <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的范围在0-10，长度为6的数组</span></span><br><span class="line">f = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>)  </span><br><span class="line">print(f)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="hljs-comment">#各个元素的间隔相等，为(10-0)/(6-1) = 2，若不想包含末尾的10，可以添加参数endpoint = False</span></span><br><span class="line">[ <span class="hljs-number">0.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">10.</span>]  </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#把arange创建的一维数组转换为3行4列的二维数组</span></span><br><span class="line">g = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)  </span><br><span class="line">print(g)                        </span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="hljs-comment">#注意：使用reshape转换前后的数据量应该相同，12 = 3x4</span></span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],              </span><br><span class="line"> [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line"> [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]              </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2x2的随机数组(矩阵),取值范围在[0.0,1.0)（包含0，不包含1）</span></span><br><span class="line">h = np.random.random((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) </span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">0.72776966</span>  <span class="hljs-number">0.94164821</span>]</span><br><span class="line"> [ <span class="hljs-number">0.04652655</span>  <span class="hljs-number">0.2316599</span> ]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个取值范围在[4,15)，2行2列的随机整数矩阵</span></span><br><span class="line">i = np.random.randint(<span class="hljs-number">4</span>,<span class="hljs-number">15</span>,size = (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))  </span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">6</span>, <span class="hljs-number">5</span>],</span><br><span class="line"> [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个从均值为0，标准差为0.1的正态分布中随机抽样的3x3矩阵</span></span><br><span class="line">j = np.random.normal(<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>,size = (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))  </span><br><span class="line">print(j)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">-0.20783767</span>, <span class="hljs-number">-0.12406401</span>, <span class="hljs-number">-0.11775284</span>],</span><br><span class="line"> [ <span class="hljs-number">0.02037018</span>,  <span class="hljs-number">0.02898423</span>, <span class="hljs-number">-0.02548213</span>],</span><br><span class="line"> [<span class="hljs-number">-0.0149878</span> ,  <span class="hljs-number">0.05277648</span>,  <span class="hljs-number">0.08332239</span>]]</span><br></pre></td></tr></table></figure><h2 id="访问、删除、增加ndarray中的元素"><a href="#访问、删除、增加ndarray中的元素" class="headerlink" title="访问、删除、增加ndarray中的元素"></a>访问、删除、增加ndarray中的元素</h2><p>这里主要是提供了一些访问、更改或增加ndarray中某一元素的基础方法。</p><h3 id="访问-amp-修改"><a href="#访问-amp-修改" class="headerlink" title="访问&amp;修改"></a>访问&amp;修改</h3><p>类似于访问python list中元素的方式，按照元素的index进行访问或更改。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#访问某一元素，这里可以自己多尝试</span></span><br><span class="line"><span class="hljs-comment">#访问一维数组的某一元素，中括号内填写index</span></span><br><span class="line">print(np.arange(<span class="hljs-number">6</span>)[<span class="hljs-number">3</span>]) </span><br><span class="line">out:<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#访问二维数组的某一元素，中括号内填写[行,列]</span></span><br><span class="line">print(np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) </span><br><span class="line">out:<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#访问三位数组中的某一元素，中括号内[组，行，列]</span></span><br><span class="line">print(np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) </span><br><span class="line">out:<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#更改某一元素，用 = 进行赋值和替换即可</span></span><br><span class="line">a = np.arange(<span class="hljs-number">6</span>)</span><br><span class="line">a[<span class="hljs-number">3</span>] = <span class="hljs-number">7</span>      <span class="hljs-comment">#先访问，再重新赋值</span></span><br><span class="line">print(a)</span><br><span class="line">[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可使用np.delete(ndarray, elements, axis)函数进行删除操作。</p><p>这里需要注意的是axis这个参数，在2维数据中，axis = 0表示选择行，axis = 1表示选择列，但不能机械的认为0就表示行，1就表示列，注意前提<strong>2维数据</strong>中。</p><blockquote><p>在三维数据中，axis = 0表示组，1表示行，2表示列。这是为什么呢？提示一下，三位数组的shape中组、行和列是怎样排序的？</p></blockquote><p>所以，axis的赋值一定要考虑数组的shape。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span><br><span class="line"><span class="hljs-comment">#思考下，这里删除axis = 0下的第0个，会是什么结果呢？自己试一下</span></span><br><span class="line">print(np.delete(a,[<span class="hljs-number">0</span>],axis = <span class="hljs-number">0</span>))</span><br></pre></td></tr></table></figure><p>再有一点需要注意的是，如果你想让原数据保留删除后的结果，需要重新赋值一下才可以。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span><br><span class="line">np.delete(a,[<span class="hljs-number">0</span>],axis = <span class="hljs-number">0</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])  <span class="hljs-comment">#原数据并未更改</span></span><br><span class="line"></span><br><span class="line">a = np.delete(a,[<span class="hljs-number">0</span>],axis = <span class="hljs-number">0</span>)  <span class="hljs-comment">#重新赋值</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">array([[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])   <span class="hljs-comment">#原数据已更改</span></span><br></pre></td></tr></table></figure><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>往ndarray中增加元素的办法跟python list也很类似，常用的有两种：</p><ul><li><p>一种是添加（append），就是将新增的元素添加到ndarray的尾部</p></li><li><p>语法为：np.append(ndarray, elements, axis)</p></li><li><p>参数和delete函数一致，用法也一致，这里不再赘述</p></li><li><p>一种是插入（insert），可以让新增元素插入到指定位置</p></li><li><p>语法为：np.insert(ndarray, index, elements, axis)</p></li><li><p>参数中就多了一个index，指示的是插入新元素的位置。</p></li></ul><p>这里值得注意的是，不论是append还是insert，在往多维数组中插入元素时，一定要注意对应axis上的shape要一致。再一个就是，和delete一样，如果你想要更改原数据，需要重新赋值。</p><h2 id="切片和筛选"><a href="#切片和筛选" class="headerlink" title="切片和筛选"></a>切片和筛选</h2><h3 id="ndarray切片"><a href="#ndarray切片" class="headerlink" title="ndarray切片"></a>ndarray切片</h3><p>前面学了选择ndarray中的某个元素的方法，这里我们学习获取ndarray子集的方法——切片。</p><p>对于切片大家并不陌生，在list里面我们也接触过切片，一维的ndarray切片与list无异。需要注意的是，就是理解2维及多维ndarray切片。</p><ul><li>2维矩阵切片</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="hljs-number">4</span>*<span class="hljs-number">4</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]])</span><br><span class="line"></span><br><span class="line">a[:,:<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])</span><br></pre></td></tr></table></figure><p>这里可以看出，我们筛选了a矩阵中前三列的所有行，这是如何实现的呢？</p><p>切片的第一个元素:表示的是选择所有行，第二个元素:-1表示的是从第0列至最后一列（不包含），所以结果如上所示。</p><p>再看一个例子：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</span><br></pre></td></tr></table></figure><p>筛选的是第2-3行的所有列。</p><ul><li>一个常用的切片</li></ul><p>以列的形式获取最后一列数据：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a[:,<span class="hljs-number">3</span>:]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">7</span>],</span><br><span class="line">       [<span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">15</span>]])</span><br></pre></td></tr></table></figure><p>以一维数组的形式获取最后一列数据：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[:,<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([ <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>])</span><br></pre></td></tr></table></figure><p>上面两种方法经常会用到，前者的shape为(4,1)，后者为(4,)。</p><h3 id="ndarray筛选"><a href="#ndarray筛选" class="headerlink" title="ndarray筛选"></a>ndarray筛选</h3><ul><li>选择ndarray的对角线</li></ul><p>所用函数为np.diag(ndarray, k=N)，其中参数k的取值决定了按照哪一条对角线选择数据。</p><p>默认k = 0，取主对角线；</p><p>k = 1时，取主对角线上面1行的元素；</p><p>k = -1时，取主对角线下面1行的元素。</p><p><strong>思考</strong>：这个函数只能选择主对角线上的元素，那如果想要获取副对角线上的元素呢？</p><p>尝试自己搜索一下关键词numpy opposite diagonal寻找答案。</p><p>不建议你直接点getting the opposite diagonal of a numpy array。</p><ul><li>提取ndarray中的唯一值</li></ul><p>所用函数为np.unique(ndarray)，注意unique也可以添加参数axis来控制评判唯一值的轴方向，不好理解可以看示例：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#查看二维数组a中的唯一值</span></span><br><span class="line">a = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],</span><br><span class="line">     [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],</span><br><span class="line">     [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]</span><br><span class="line">print(np.unique(a))    </span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看a中的唯一行（也就是没有重复的行）</span></span><br><span class="line">print(np.unique(a,axis = <span class="hljs-number">0</span>))  </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看a中的唯一列</span></span><br><span class="line">print(np.unique(a,axis = <span class="hljs-number">1</span>))  </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看a中第一行的唯一值</span></span><br><span class="line">print(np.unique(a[<span class="hljs-number">0</span>]))  </span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure><ul><li>通过布尔运算筛选</li></ul><p>这里在中括号中添加筛选条件，当该条件的结果为True时（即满足条件时），返回该值。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[X &gt; <span class="hljs-number">10</span>] <span class="hljs-comment">#筛选数组X中大于10的数据</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，当输入多个筛选条件时，&amp;表示与，|表示或，~表示非。</p><h2 id="运算与排序"><a href="#运算与排序" class="headerlink" title="运算与排序"></a>运算与排序</h2><h3 id="ndarray运算"><a href="#ndarray运算" class="headerlink" title="ndarray运算"></a>ndarray运算</h3><ul><li>集合运算</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.intersect1d(x,y) <span class="hljs-comment">#取x与y的交集</span></span><br><span class="line">np.setdiff1d(x,y)   <span class="hljs-comment">#取x与y的差集，返回的是在x中且没在y中的元素</span></span><br><span class="line">np.union1d(x,y)     <span class="hljs-comment">#取x与y的并集</span></span><br></pre></td></tr></table></figure><ul><li>算术运算<br>我们可以通过+、-、*、/或np.add、np.substract、np.multiply 、np.divide来对两个矩阵进行元素级的加减乘除运算，因为是元素级的运算，所以两个矩阵的shape必须要一致或者是可广播(Broadcast)。</li></ul><p>这里所谓的可广播，就是指虽然A和B两个矩阵的shape不一致，但是A可以拆分为整数个与B具有相同shape的矩阵，这样在进行元素级别的运算时，就会先将A进行拆分，然后与B进行运算，结果再组合一起就可以。这里的A就是“可广播”矩阵。</p><blockquote><p>上面涉及到的乘法是元素对应相乘，也就是点乘，那矩阵的叉乘呢？可以了解下numpy.matmul函数。</p></blockquote><h3 id="ndarray排序"><a href="#ndarray排序" class="headerlink" title="ndarray排序"></a>ndarray排序</h3><p>我们使用np.sort()和ndarray.sort()来对ndarray进行排序。</p><p>相同的是：</p><p>二者都可以使用参数axis来决定依照哪个轴进行排序，axis = 0时按照列排序，axis = 1时按照行排序；</p><p>不同的是：</p><p>np.sort()不会更改原数组；ndarray.sort()会更改原数组。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Numpy简介&quot;&gt;&lt;a href=&quot;#Numpy简介&quot; class=&quot;headerlink&quot; title=&quot;Numpy简介&quot;&gt;&lt;/a&gt;Numpy简介&lt;/h2&gt;&lt;p&gt;NumPy 是 Numerical Python 的简称，它是 Python 中的科学计算基本软件包。NumPy 为 Python 提供了大量数学库，使我们能够高效地进行数字计算。更多可点击&lt;a href=&quot;http://www.numpy.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Numpy官网&lt;/a&gt; 查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Numpy" scheme="http://yoursite.com/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>南大周志华关于论文内容演讲演示文稿</title>
    <link href="http://yoursite.com/2019/09/25/%E5%8D%97%E5%A4%A7%E5%91%A8%E5%BF%97%E5%8D%8E%E5%85%B3%E4%BA%8E%E8%AE%BA%E6%96%87%E5%86%85%E5%AE%B9%E6%BC%94%E8%AE%B2%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/"/>
    <id>http://yoursite.com/2019/09/25/南大周志华关于论文内容演讲演示文稿/</id>
    <published>2019-09-25T11:45:38.000Z</published>
    <updated>2019-09-25T11:49:48.903Z</updated>
    
    <content type="html"><![CDATA[<p>可以允许不完美，但不能不做~</p><a id="more"></a><ol><li><p>Oneindex下载：<a href="http://pan.sqdxwz.com/?/文档/" target="_blank" rel="noopener">http://pan.sqdxwz.com/?/文档/</a></p></li><li><p>蓝奏云下载：<a href="https://www.lanzous.com/i6ecpmj" target="_blank" rel="noopener">https://www.lanzous.com/i6ecpmj</a></p></li><li><p>网盘(提取码：21yg )备用下载：<a href="https://pan.baidu.com/s/1xXDe3QdrnoiAYojYLl2OuA" target="_blank" rel="noopener">https://pan.baidu.com/s/1xXDe3QdrnoiAYojYLl2OuA</a> </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以允许不完美，但不能不做~&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="周志华论文" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Mish:撼动深度学习ReLU激活函数的新继任者</title>
    <link href="http://yoursite.com/2019/09/25/Mish-%E6%92%BC%E5%8A%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0ReLU%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B0%E7%BB%A7%E4%BB%BB%E8%80%85/"/>
    <id>http://yoursite.com/2019/09/25/Mish-撼动深度学习ReLU激活函数的新继任者/</id>
    <published>2019-09-25T10:55:14.000Z</published>
    <updated>2019-09-25T11:10:41.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对激活函数的研究一直没有停止过，ReLU还是统治着深度学习的激活函数，不过，这种情况有可能会被Mish改变。</p></blockquote><a id="more"></a><p>Diganta Misra的一篇题为“Mish: A Self Regularized Non-Monotonic Neural Activation Function”的新论文介绍了一个新的深度学习激活函数，该函数在最终准确度上比Swish(+.494%)和ReLU(+ 1.671%)都有提高。</p><p>他们的小型FastAI团队使用Mish代替ReLU，打破了之前在FastAI全球排行榜上准确性得分记录的一部分。结合Ranger优化器，Mish激活，Flat + Cosine 退火和自注意力层，他们能够获得12个新的排行榜记录！</p><p><a href="https://sm.ms/image/PZMCh1OpjkRvYqf" target="_blank"><img src="https://i.loli.net/2019/09/25/PZMCh1OpjkRvYqf.jpg"></a></p><p>我们12项排行榜记录中的6项。每条记录都是用Mish而不是ReLU。(蓝色高亮显示，400 epoch的准确率为94.6，略高于我们的20 epoch的准确率为93.8:)</p><p>作为他们自己测试的一部分，对于ImageWoof数据集的5 epoch测试，他们说：</p><blockquote><p>Mish在高显著性水平上优于ReLU (P &lt; 0.0001)。(FastAI论坛@ Seb)</p></blockquote><p>Mish已经在70多个基准上进行了测试，包括图像分类、分割和生成，并与其他15个激活函数进行了比较。</p><h1 id="什么是Mesh"><a href="#什么是Mesh" class="headerlink" title="什么是Mesh"></a>什么是Mesh</h1><p>直接看Mesh的代码会更简单一点，简单总结一下，Mish=x * tanh(ln(1+e^x))。</p><p>其他的激活函数，ReLU是x = max(0,x)，Swish是x * sigmoid(x)。</p><p><strong>PyTorch的Mish实现</strong>：</p><p><a href="https://sm.ms/image/Ya4lGfdXjN3o2qH" target="_blank"><img src="https://i.loli.net/2019/09/25/Ya4lGfdXjN3o2qH.jpg"></a></p><p><strong>Tensorflow中的Mish函数</strong>：</p><p>Tensorflow：x = x *tf.math.tanh(F.softplus(x))</p><h1 id="Mish和其他的激活函数相比怎么样？"><a href="#Mish和其他的激活函数相比怎么样？" class="headerlink" title="Mish和其他的激活函数相比怎么样？"></a>Mish和其他的激活函数相比怎么样？</h1><p>下图显示了Mish与其他一些激活函数的测试结果。这是多达73个测试的结果，在不同的架构，不同的任务上：</p><p><a href="https://sm.ms/image/zrD2FSpymHT13s5" target="_blank"><img src="https://i.loli.net/2019/09/25/zrD2FSpymHT13s5.jpg"></a></p><h1 id="为什么Mish表现这么好？"><a href="#为什么Mish表现这么好？" class="headerlink" title="为什么Mish表现这么好？"></a>为什么Mish表现这么好？</h1><p>以上无边界(即正值可以达到任何高度)避免了由于封顶而导致的饱和。理论上对负值的轻微允许允许更好的梯度流，而不是像ReLU中那样的硬零边界。</p><p>最后，可能也是最重要的，目前的想法是，平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化。</p><p>尽管如此，我测试了许多激活函数，它们也满足了其中的许多想法，但大多数都无法执行。这里的主要区别可能是Mish函数在曲线上几乎所有点上的平滑度。</p><p>这种通过Mish激活曲线平滑性来推送信息的能力如下图所示，在本文的一个简单测试中，越来越多的层被添加到一个测试神经网络中，而没有一个统一的函数。随着层深的增加，ReLU精度迅速下降，其次是Swish。相比之下，Mish能更好地保持准确性，这可能是因为它能更好地传播信息：</p><p><a href="https://sm.ms/image/3udy29EoMmq8KwD" target="_blank"><img src="https://i.loli.net/2019/09/25/3udy29EoMmq8KwD.jpg"></a></p><p>更平滑的激活功能允许信息更深入地流动……注意，随着层数的增加，ReLU快速下降。</p><h1 id="如何把Mish放到你自己的网络中？"><a href="#如何把Mish放到你自己的网络中？" class="headerlink" title="如何把Mish放到你自己的网络中？"></a>如何把Mish放到你自己的网络中？</h1><p>Mish的PyTorch和FastAI的源代码可以在github的两个地方找到：</p><p>1、官方Mish github：<a href="https://github.com/digantamisra98/Mish" target="_blank" rel="noopener">https://github.com/digantamisra98/Mish</a></p><p>2、非官方的Mish使用inline提升速度：<a href="https://github.com/lessw2020/mish" target="_blank" rel="noopener">https://github.com/lessw2020/mish</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReLU有一些已知的弱点，但是通常它执行起来很轻，并且在计算上很轻。Mish具有较强的理论渊源，在测试中，就训练稳定性和准确性而言，Mish的平均性能优于ReLU。</p><p>复杂度只稍微增加了一点(V100 GPU和Mish，相对于ReLU，每epoch增加大约1秒)，考虑到训练稳定性的提高和最终精度的提高，稍微增加一点时间似乎是值得的。</p><p>最终，在今年测试了大量新的激活函数后，Mish在这方面处于领先地位，许多人怀疑它很有可能成为AI未来的新ReLU。</p><p>英文文章地址：<a href="https://medium.com/@lessw/meet-mish-new-state-of-the-art-ai-activation-function-the-successor-to-relu-846a6d93471f" target="_blank" rel="noopener">https://medium.com/@lessw/meet-mish-new-state-of-the-art-ai-activation-function-the-successor-to-relu-846a6d93471f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对激活函数的研究一直没有停止过，ReLU还是统治着深度学习的激活函数，不过，这种情况有可能会被Mish改变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法可视化平台</title>
    <link href="http://yoursite.com/2019/09/25/%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2019/09/25/算法可视化平台/</id>
    <published>2019-09-25T10:47:40.000Z</published>
    <updated>2019-09-25T11:10:00.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无疑，数据结构与算法学习最大的难点之一就是如何在脑中形象化其抽象的逻辑步骤。而图像在很多时候能够大大帮助我们理解其对应的抽象化的东西，而如果这个图像还是我们自己一点点画出来的，那么无疑这个印象是最深刻的了。没错，今天就是算法可视化的网站。</p><a id="more"></a><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ol><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li></ol><p>该网站特点:</p><ul><li><p>算法可视化</p></li><li><p>界面简洁直观</p></li><li><p>过程可控制</p></li></ul><ol start="2"><li><a href="https://visualgo.net/zh/" target="_blank" rel="noopener">https://visualgo.net/zh/</a></li></ol><p>该网站特点：</p><ul><li><p>算法可视化</p></li><li><p>文字讲解</p></li><li><p>复杂度备注</p></li><li><p>图形可操控调整</p></li></ul><ol start="3"><li><a href="https://algorithm-visualizer.org/" target="_blank" rel="noopener">https://algorithm-visualizer.org/</a></li></ol><p>该网站特点：</p><ul><li><p>算法可视化</p></li><li><p>有代码</p></li><li><p>有控制台输出帮助理解</p></li><li><p>算法种类丰富</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;无疑，数据结构与算法学习最大的难点之一就是如何在脑中形象化其抽象的逻辑步骤。而图像在很多时候能够大大帮助我们理解其对应的抽象化的东西，而如果这个图像还是我们自己一点点画出来的，那么无疑这个印象是最深刻的了。没错，今天就是算法可视化的网站。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="可视化" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>即学即用的30个python常用代码</title>
    <link href="http://yoursite.com/2019/09/24/%E5%8D%B3%E5%AD%A6%E5%8D%B3%E7%94%A8%E7%9A%8430%E4%B8%AApython%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/09/24/即学即用的30个python常用代码/</id>
    <published>2019-09-24T03:22:10.000Z</published>
    <updated>2019-09-24T03:27:36.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-检查重复元素"><a href="#1-检查重复元素" class="headerlink" title="1.检查重复元素"></a>1.检查重复元素</h2><p>下面的方法可以检查给定列表中是否有重复的元素。它使用了 set() 属性，该属性将会从列表中删除重复的元素。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">all_unique</span><span class="hljs-params">(lst)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> len(lst) == len(set(lst))  </span><br><span class="line">      </span><br><span class="line">x = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]    </span><br><span class="line">y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]    </span><br><span class="line">all_unique(x) <span class="hljs-comment"># False    </span></span><br><span class="line">all_unique(y) <span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-变位词"><a href="#2-变位词" class="headerlink" title="2.变位词"></a>2.变位词</h2><p>检测两个字符串是否互为变位词（即互相颠倒字符顺序）</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter   </span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anagram</span><span class="hljs-params">(first, second)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> Counter(first) == Counter(second)    </span><br><span class="line">anagram(<span class="hljs-string">"abcd3"</span>, <span class="hljs-string">"3acdb"</span>) <span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="3-检查内存使用情况"><a href="#3-检查内存使用情况" class="headerlink" title="3.检查内存使用情况"></a>3.检查内存使用情况</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> sys    </span><br><span class="line">variable = <span class="hljs-number">30</span>     </span><br><span class="line">print(sys.getsizeof(variable)) <span class="hljs-comment"># 24</span></span><br></pre></td></tr></table></figure><h2 id="4-字节大小计算"><a href="#4-字节大小计算" class="headerlink" title="4.字节大小计算"></a>4.字节大小计算</h2><p>以下方法将以字节为单位返回字符串长度。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byte_size</span><span class="hljs-params">(string)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span>(len(string.encode( utf<span class="hljs-number">-8</span> )))   </span><br><span class="line">     </span><br><span class="line">byte_size( 😀 ) <span class="hljs-comment"># 4    </span></span><br><span class="line">byte_size( Hello World ) <span class="hljs-comment"># 11</span></span><br></pre></td></tr></table></figure><h2 id="5-重复打印字符n次"><a href="#5-重复打印字符n次" class="headerlink" title="5.重复打印字符n次"></a>5.重复打印字符n次</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="hljs-number">2</span>; </span><br><span class="line">s =<span class="hljs-string">"Programming"</span>; print(s * n); </span><br><span class="line"><span class="hljs-comment"># ProgrammingProgramming</span></span><br></pre></td></tr></table></figure><h2 id="6-首字母大写"><a href="#6-首字母大写" class="headerlink" title="6.首字母大写"></a>6.首字母大写</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="hljs-string">"programming is awesome"</span>    </span><br><span class="line">print(s.title()) <span class="hljs-comment"># Programming Is Awesome</span></span><br></pre></td></tr></table></figure><h2 id="7-分块"><a href="#7-分块" class="headerlink" title="7.分块"></a>7.分块</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> ceil </span><br><span class="line">   </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chunk</span><span class="hljs-params">(lst, size)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> list(    </span><br><span class="line">        map(<span class="hljs-keyword">lambda</span> x: lst[x * size:x * size + size],    </span><br><span class="line">            list(range(<span class="hljs-number">0</span>, ceil(len(lst) / size)))))    </span><br><span class="line">chunk([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">2</span>) <span class="hljs-comment"># [[1,2],[3,4],5]</span></span><br></pre></td></tr></table></figure><h2 id="8-压缩"><a href="#8-压缩" class="headerlink" title="8.压缩"></a>8.压缩</h2><p>以下方法使用 fliter() 删除列表中的错误值（如：False, None, 0 和“”）</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compact</span><span class="hljs-params">(lst)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> list(filter(bool, lst))    </span><br><span class="line">compact([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>, <span class="hljs-number">2</span>,   , <span class="hljs-number">3</span>,  a ,  s , <span class="hljs-number">34</span>]) <span class="hljs-comment"># [ 1, 2, 3,  a ,  s , 34 ]</span></span><br></pre></td></tr></table></figure><h2 id="9-间隔数"><a href="#9-间隔数" class="headerlink" title="9.间隔数"></a>9.间隔数</h2><p>以下代码段可以用来转换一个二维数组。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [[ a ,  b ], [ c ,  d ], [ e ,  f ]]    </span><br><span class="line">transposed = zip(*array)    </span><br><span class="line">print(transposed) <span class="hljs-comment"># [( a ,  c ,  e ), ( b ,  d ,  f )]</span></span><br></pre></td></tr></table></figure><h2 id="10-链式比较"><a href="#10-链式比较" class="headerlink" title="10.链式比较"></a>10.链式比较</h2><p>以下代码可以在一行中用各种操作符进行多次比较。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-number">3</span>    </span><br><span class="line">print( <span class="hljs-number">2</span> &lt; a &lt; <span class="hljs-number">8</span>) <span class="hljs-comment"># True    </span></span><br><span class="line">print(<span class="hljs-number">1</span> == a &lt; <span class="hljs-number">2</span>) <span class="hljs-comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="11-逗号分隔"><a href="#11-逗号分隔" class="headerlink" title="11.逗号分隔"></a>11.逗号分隔</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hobbies = [<span class="hljs-string">"basketball"</span>, <span class="hljs-string">"football"</span>, <span class="hljs-string">"swimming"</span>]</span><br><span class="line">print(<span class="hljs-string">"My hobbies are: "</span> + <span class="hljs-string">", "</span>.join(hobbies)) <span class="hljs-comment"># My hobbies are: basketball, football, swimming</span></span><br></pre></td></tr></table></figure><h2 id="12-计算元音字母数"><a href="#12-计算元音字母数" class="headerlink" title="12.计算元音字母数"></a>12.计算元音字母数</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> re    </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_vowels</span><span class="hljs-params">(str)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> len(len(re.findall(r [aeiou] , str, re.IGNORECASE)))    </span><br><span class="line">count_vowels( foobar ) <span class="hljs-comment"># 3    </span></span><br><span class="line">count_vowels( gym ) <span class="hljs-comment"># 0</span></span><br></pre></td></tr></table></figure><h2 id="13-首字母恢复小写"><a href="#13-首字母恢复小写" class="headerlink" title="13.首字母恢复小写"></a>13.首字母恢复小写</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decapitalize</span><span class="hljs-params">(string)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> str[:<span class="hljs-number">1</span>].lower() + str[<span class="hljs-number">1</span>:]    </span><br><span class="line">decapitalize( FooBar ) <span class="hljs-comment">#  fooBar     </span></span><br><span class="line">decapitalize( FooBar ) <span class="hljs-comment">#  fooBar</span></span><br></pre></td></tr></table></figure><h2 id="14-平面化"><a href="#14-平面化" class="headerlink" title="14.平面化"></a>14.平面化</h2><p>以下方法使用递归来展开潜在的深度列表。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spread</span><span class="hljs-params">(arg)</span>:</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:</span><br><span class="line">        <span class="hljs-keyword">if</span> isinstance(i, list):</span><br><span class="line">            ret.extend(i)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret.append(i)</span><br><span class="line">    <span class="hljs-keyword">return</span> ret</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deep_flatten</span><span class="hljs-params">(lst)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    result.extend(</span><br><span class="line">        spread(list(map(<span class="hljs-keyword">lambda</span> x: deep_flatten(x) <span class="hljs-keyword">if</span> type(x) == list <span class="hljs-keyword">else</span> x, lst))))</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line">deep_flatten([<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>], [[<span class="hljs-number">3</span>], <span class="hljs-number">4</span>], <span class="hljs-number">5</span>]) <span class="hljs-comment"># [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="15-差异"><a href="#15-差异" class="headerlink" title="15.差异"></a>15.差异</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">difference</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    set_a = set(a)</span><br><span class="line">    set_b = set(b)</span><br><span class="line">    comparison = set_a.difference(set_b)</span><br><span class="line">    <span class="hljs-keyword">return</span> list(comparison)</span><br><span class="line">difference([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]) <span class="hljs-comment"># [3]</span></span><br></pre></td></tr></table></figure><h2 id="16-寻找差异"><a href="#16-寻找差异" class="headerlink" title="16.寻找差异"></a>16.寻找差异</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">difference_by</span><span class="hljs-params">(a, b, fn)</span>:</span></span><br><span class="line">    b = set(map(fn, b))</span><br><span class="line">    <span class="hljs-keyword">return</span> [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> fn(item) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> b]</span><br><span class="line"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> floor</span><br><span class="line">difference_by([<span class="hljs-number">2.1</span>, <span class="hljs-number">1.2</span>], [<span class="hljs-number">2.3</span>, <span class="hljs-number">3.4</span>],floor) <span class="hljs-comment"># [1.2]</span></span><br><span class="line">difference_by([&#123;  x : <span class="hljs-number">2</span> &#125;, &#123;  x : <span class="hljs-number">1</span> &#125;], [&#123;  x : <span class="hljs-number">1</span> &#125;], <span class="hljs-keyword">lambda</span> v : v[ x ]) <span class="hljs-comment"># [ &#123; x: 2 &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="17-链式函数调用"><a href="#17-链式函数调用" class="headerlink" title="17.链式函数调用"></a>17.链式函数调用</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a + b</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subtract</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a - b</span><br><span class="line">a, b = <span class="hljs-number">4</span>, <span class="hljs-number">5</span></span><br><span class="line">print((subtract <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> add)(a, b)) <span class="hljs-comment"># 9</span></span><br></pre></td></tr></table></figure><h2 id="18-检查重复元素"><a href="#18-检查重复元素" class="headerlink" title="18.检查重复元素"></a>18.检查重复元素</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_duplicates</span><span class="hljs-params">(lst)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> len(lst) != len(set(lst))</span><br><span class="line">    </span><br><span class="line">x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]</span><br><span class="line">y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</span><br><span class="line">has_duplicates(x) <span class="hljs-comment"># True</span></span><br><span class="line">has_duplicates(y) <span class="hljs-comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="19-合并两个字典"><a href="#19-合并两个字典" class="headerlink" title="19.合并两个字典"></a>19.合并两个字典</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_two_dicts</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    c = a.copy()   <span class="hljs-comment"># make a copy of a </span></span><br><span class="line">    c.update(b)    <span class="hljs-comment"># modify keys and values of a with the ones from b</span></span><br><span class="line">    <span class="hljs-keyword">return</span> c</span><br><span class="line">a = &#123;  x : <span class="hljs-number">1</span>,  y : <span class="hljs-number">2</span>&#125;</span><br><span class="line">b = &#123;  y : <span class="hljs-number">3</span>,  z : <span class="hljs-number">4</span>&#125;</span><br><span class="line">print(merge_two_dicts(a, b)) <span class="hljs-comment"># &#123; y : 3,  x : 1,  z : 4&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#在python3.5版本后你还可以：</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_dictionaries</span><span class="hljs-params">(a, b)</span></span></span><br><span class="line">   return &#123;**a, **b&#125;</span><br><span class="line">a = &#123;  x : <span class="hljs-number">1</span>,  y : <span class="hljs-number">2</span>&#125;</span><br><span class="line">b = &#123;  y : <span class="hljs-number">3</span>,  z : <span class="hljs-number">4</span>&#125;</span><br><span class="line">print(merge_dictionaries(a, b)) <span class="hljs-comment"># &#123; y : 3,  x : 1,  z : 4&#125;</span></span><br></pre></td></tr></table></figure><h2 id="20-将两个列表转化成一个字典"><a href="#20-将两个列表转化成一个字典" class="headerlink" title="20.将两个列表转化成一个字典"></a>20.将两个列表转化成一个字典</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dictionary</span><span class="hljs-params">(keys, values)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> dict(zip(keys, values))</span><br><span class="line">    </span><br><span class="line">keys = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]    </span><br><span class="line">values = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line">print(to_dictionary(keys, values)) <span class="hljs-comment"># &#123; a : 2,  c : 4,  b : 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="21-使用枚举"><a href="#21-使用枚举" class="headerlink" title="21.使用枚举"></a>21.使用枚举</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下方法将字典作为输入，然后仅返回该字典中的键。</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> enumerate(list): </span><br><span class="line">    print(<span class="hljs-string">"Value"</span>, element, <span class="hljs-string">"Index "</span>, index, )</span><br><span class="line"><span class="hljs-comment"># ( Value ,  a ,  Index  , 0)</span></span><br><span class="line"><span class="hljs-comment"># ( Value ,  b ,  Index  , 1)</span></span><br><span class="line"><span class="hljs-comment">#( Value ,  c ,  Index  , 2)</span></span><br><span class="line"><span class="hljs-comment"># ( Value ,  d ,  Index  , 3)</span></span><br></pre></td></tr></table></figure><h2 id="22-计算需要的时间"><a href="#22-计算需要的时间" class="headerlink" title="22.计算需要的时间"></a>22.计算需要的时间</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">a = <span class="hljs-number">1</span></span><br><span class="line">b = <span class="hljs-number">2</span></span><br><span class="line">c = a + b</span><br><span class="line">print(c) <span class="hljs-comment">#3</span></span><br><span class="line">end_time = time.time()</span><br><span class="line">total_time = end_time - start_time</span><br><span class="line">print(<span class="hljs-string">"Time: "</span>, total_time)</span><br><span class="line"><span class="hljs-comment"># ( Time:  , 1.1205673217773438e-05)</span></span><br></pre></td></tr></table></figure><h2 id="23-Try-else指令"><a href="#23-Try-else指令" class="headerlink" title="23.Try else指令"></a>23.Try else指令</h2><p>你可以将 else 子句作为 try/except 块的一部分，如果没有抛出异常，则执行该子句。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    <span class="hljs-number">2</span>*<span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-keyword">except</span> TypeError:</span><br><span class="line">    print(<span class="hljs-string">"An exception was raised"</span>)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">"Thank God, no exceptions were raised."</span>)</span><br><span class="line"><span class="hljs-comment">#Thank God, no exceptions were raised.</span></span><br></pre></td></tr></table></figure><h2 id="24-查找最常见元素"><a href="#24-查找最常见元素" class="headerlink" title="24.查找最常见元素"></a>24.查找最常见元素</h2><p>以下方法返回列表中出现的最常见元素。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">most_frequent</span><span class="hljs-params">(list)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> max(set(list), key = list.count)</span><br><span class="line">  </span><br><span class="line">list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]</span><br><span class="line">most_frequent(list)</span><br></pre></td></tr></table></figure><h2 id="25-回文"><a href="#25-回文" class="headerlink" title="25.回文"></a>25.回文</h2><p>以下方法可检查给定的字符串是否为回文结构。该方法首先将字符串转换为小写，然后从中删除非字母数字字符。最后，它会将新的字符串与反转版本进行比较。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">palindrome</span><span class="hljs-params">(string)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">from</span> re <span class="hljs-keyword">import</span> sub</span><br><span class="line">    s = sub( [W_] ,   , string.lower())</span><br><span class="line">    <span class="hljs-keyword">return</span> s == s[::<span class="hljs-number">-1</span>]</span><br><span class="line">palindrome( taco cat ) <span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="26-没有-if-else-语句的简单计算器"><a href="#26-没有-if-else-语句的简单计算器" class="headerlink" title="26.没有 if-else 语句的简单计算器"></a>26.没有 if-else 语句的简单计算器</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> operator</span><br><span class="line">action = &#123;</span><br><span class="line">    <span class="hljs-string">"+"</span>: operator.add,</span><br><span class="line">    <span class="hljs-string">"-"</span>: operator.sub,</span><br><span class="line">    <span class="hljs-string">"/"</span>: operator.truediv,</span><br><span class="line">    <span class="hljs-string">"*"</span>: operator.mul,</span><br><span class="line">    <span class="hljs-string">"**"</span>: pow</span><br><span class="line">&#125;</span><br><span class="line">print(action[ - ](<span class="hljs-number">50</span>, <span class="hljs-number">25</span>)) <span class="hljs-comment"># 25</span></span><br></pre></td></tr></table></figure><h2 id="27-元素顺序打乱"><a href="#27-元素顺序打乱" class="headerlink" title="27.元素顺序打乱"></a>27.元素顺序打乱</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy</span><br><span class="line"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(lst)</span>:</span></span><br><span class="line">    temp_lst = deepcopy(lst)</span><br><span class="line">    m = len(temp_lst)</span><br><span class="line">    <span class="hljs-keyword">while</span> (m):</span><br><span class="line">        m -= <span class="hljs-number">1</span></span><br><span class="line">        i = randint(<span class="hljs-number">0</span>, m)</span><br><span class="line">        temp_lst[m], temp_lst[i] = temp_lst[i], temp_lst[m]</span><br><span class="line">    <span class="hljs-keyword">return</span> temp_lst</span><br><span class="line">  </span><br><span class="line">foo = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span><br><span class="line">shuffle(foo) <span class="hljs-comment"># [2,3,1] , foo = [1,2,3]</span></span><br></pre></td></tr></table></figure><h2 id="28-列表扁平化"><a href="#28-列表扁平化" class="headerlink" title="28.列表扁平化"></a>28.列表扁平化</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spread</span><span class="hljs-params">(arg)</span>:</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:</span><br><span class="line">        <span class="hljs-keyword">if</span> isinstance(i, list):</span><br><span class="line">            ret.extend(i)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret.append(i)</span><br><span class="line">    <span class="hljs-keyword">return</span> ret</span><br><span class="line">spread([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>],<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]) <span class="hljs-comment"># [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><h2 id="29-变量变换"><a href="#29-变量变换" class="headerlink" title="29.变量变换"></a>29.变量变换</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">  <span class="hljs-keyword">return</span> b, a</span><br><span class="line">a, b = <span class="hljs-number">-1</span>, <span class="hljs-number">14</span></span><br><span class="line">swap(a, b) <span class="hljs-comment"># (14, -1)</span></span><br></pre></td></tr></table></figure><h2 id="30-获取确实键的默认值"><a href="#30-获取确实键的默认值" class="headerlink" title="30.获取确实键的默认值"></a>30.获取确实键的默认值</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; a : <span class="hljs-number">1</span>,  b : <span class="hljs-number">2</span>&#125;</span><br><span class="line">print(d.get( c , <span class="hljs-number">3</span>)) <span class="hljs-comment"># 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-检查重复元素&quot;&gt;&lt;a href=&quot;#1-检查重复元素&quot; class=&quot;headerlink&quot; title=&quot;1.检查重复元素&quot;&gt;&lt;/a&gt;1.检查重复元素&lt;/h2&gt;&lt;p&gt;下面的方法可以检查给定列表中是否有重复的元素。它使用了 set() 属性，该属性将会从列表中删除重复的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight python hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;all_unique&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(lst)&lt;/span&gt;:&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; len(lst) == len(set(lst))  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;all_unique(x) &lt;span class=&quot;hljs-comment&quot;&gt;# False    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;all_unique(y) &lt;span class=&quot;hljs-comment&quot;&gt;# True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python常用代码" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>The Game of Life</title>
    <link href="http://yoursite.com/2019/09/18/The-Game-of-Life/"/>
    <id>http://yoursite.com/2019/09/18/The-Game-of-Life/</id>
    <published>2019-09-18T14:47:02.000Z</published>
    <updated>2019-09-29T11:11:26.027Z</updated>
    
    <content type="html"><![CDATA[<p>#引言</p><p>Python 的 Matplotlib 是最常用的图表绘制以及数据可视化库。我们对折线图、柱状图以及热力图都比较熟悉，但你知道用 Matplotlib 还能做简单的动画吗？</p><a id="more"></a><p>下面就是用 Matplotlib 制作动画的例子。展示的是 John Conway 的 《The Game of Life》，这是一个 Metis（数据科学夏令营）中的编程挑战题目，同时给了我一个机会让我知道Matpltlib可以制作动图。看看结果的动图：</p><p><a href="https://sm.ms/image/CAmo9P5xGeOHMcR" target="_blank"><img src="https://i.loli.net/2019/09/18/CAmo9P5xGeOHMcR.gif"></a></p><p>这篇文章的重点还是主要放在 python 中如何用 Matploylib 制作动画。</p><p>但如果你不太熟悉模拟游戏的话（它更像是可以看的模拟动画，而非可以玩的游戏），我来给大家介绍一下规则：</p><ol><li><p>一开始先设置一个 N×N 的网格（我的动画中用的是 50×50 ）；</p></li><li><p>接着随机地向格子中填充“小细胞”（一开始随机地从 2500 个格子中选取 1500 个进行填充）；</p></li><li><p>如果邻居小细胞少于等于 1 个，那格子中的小细胞会死掉；</p></li><li><p>如果邻居大于等于 4 个的也会死掉；</p></li><li><p>只有 2 个或 3 个邻居时可以生存；</p></li><li><p>空的格子中如果正好有 3 个邻居，则会长出 1 个新的“小细胞”；</p></li></ol><p>通过对规则的阅读我最先想到的是：<a href="https://baike.sogou.com/v9062794.htm?fromTitle=生命游戏" target="_blank" rel="noopener">生命游戏</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>注意:</strong>我运行采用的是<strong>Anaconda3集成环境</strong>；程序运行<strong>两次</strong>，第一次营造运行环境，第二次运行程序输出。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> animation</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns</span><br><span class="line"><span class="hljs-keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Some helper functions</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Initialize the board with starting positions</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_board</span><span class="hljs-params">(pos_list, my_board)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> pos_list:</span><br><span class="line">        my_board[pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> my_board</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Make sure padded border values are always zero</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">force_pad_zero</span><span class="hljs-params">(my_board)</span>:</span></span><br><span class="line">    edge_row_0 = <span class="hljs-number">0</span></span><br><span class="line">    edge_row_1 = my_board.shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span></span><br><span class="line">    edge_col_0 = <span class="hljs-number">0</span></span><br><span class="line">    edge_col_1 = my_board.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> enumerate(my_board):</span><br><span class="line">        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:</span><br><span class="line">            row[:] = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> index == edge_row_1:</span><br><span class="line">            row[:] = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            row[edge_col_0] = <span class="hljs-number">0</span></span><br><span class="line">            row[edge_col_1] = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> my_board:</span><br><span class="line">        col[edge_row_0] = <span class="hljs-number">0</span></span><br><span class="line">        col[edge_row_1] = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">return</span> my_board</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Figure out the number of neighbors for a given cell</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_neighbors</span><span class="hljs-params">(row, col, my_board)</span>:</span></span><br><span class="line">    b = force_pad_zero(my_board)</span><br><span class="line">    num_neighbors = (b[row<span class="hljs-number">-1</span>,col<span class="hljs-number">-1</span>] + b[row+<span class="hljs-number">0</span>,col<span class="hljs-number">-1</span>] + b[row+<span class="hljs-number">1</span>,col<span class="hljs-number">-1</span>] + b[row+<span class="hljs-number">1</span>,col+<span class="hljs-number">0</span>] </span><br><span class="line">                   + b[row+<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>] + b[row+<span class="hljs-number">0</span>,col+<span class="hljs-number">1</span>] + b[row<span class="hljs-number">-1</span>,col+<span class="hljs-number">1</span>] + b[row<span class="hljs-number">-1</span>,col+<span class="hljs-number">0</span>])</span><br><span class="line">    <span class="hljs-keyword">return</span> num_neighbors</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Update the board based on the game rules, each call to update_board is one turn</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_board</span><span class="hljs-params">(my_board)</span>:</span></span><br><span class="line">    old_board = my_board.copy()</span><br><span class="line">    set_zero = []</span><br><span class="line">    set_one = []</span><br><span class="line">    <span class="hljs-comment"># Loop through board and update according to rules</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> enumerate(my_board[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>]):</span><br><span class="line">        <span class="hljs-keyword">for</span> j, col <span class="hljs-keyword">in</span> enumerate(row):</span><br><span class="line">            true_i = i + <span class="hljs-number">1</span></span><br><span class="line">            true_j = j + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment"># Update based on number of neighbors (using calc_neighbors)</span></span><br><span class="line">            <span class="hljs-comment"># set_zero and set_one are lists that tell me the coordinates of cells that require updating</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (((calc_neighbors(true_i, true_j, my_board) &lt;= <span class="hljs-number">1</span>) </span><br><span class="line">                  <span class="hljs-keyword">or</span> (calc_neighbors(true_i, true_j, my_board) &gt;= <span class="hljs-number">4</span>))</span><br><span class="line">                  <span class="hljs-keyword">and</span> my_board[true_i, true_j] != <span class="hljs-number">0</span>):</span><br><span class="line">                set_zero.append([true_i, true_j])</span><br><span class="line">            <span class="hljs-keyword">elif</span> ((calc_neighbors(true_i, true_j, my_board) == <span class="hljs-number">3</span>)</span><br><span class="line">                  <span class="hljs-keyword">and</span> my_board[true_i, true_j] == <span class="hljs-number">0</span>):</span><br><span class="line">                set_one.append([true_i, true_j])</span><br><span class="line">    <span class="hljs-comment"># Update the required cells</span></span><br><span class="line">    <span class="hljs-keyword">for</span> index, val <span class="hljs-keyword">in</span> enumerate(set_zero):</span><br><span class="line">        my_board[val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> index, val <span class="hljs-keyword">in</span> enumerate(set_one):</span><br><span class="line">        my_board[val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> my_board</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Input variables for the board</span></span><br><span class="line">boardsize = <span class="hljs-number">50</span>        <span class="hljs-comment"># board will be X by X where X = boardsize</span></span><br><span class="line">pad = <span class="hljs-number">2</span>               <span class="hljs-comment"># padded border, do not change this!</span></span><br><span class="line">initial_cells = <span class="hljs-number">1500</span>  <span class="hljs-comment"># this number of initial cells will be placed </span></span><br><span class="line">                      <span class="hljs-comment"># in randomly generated positions</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Get a list of random coordinates so that we can initialize </span></span><br><span class="line"><span class="hljs-comment"># board with randomly placed organisms</span></span><br><span class="line">pos_list = []</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(initial_cells):</span><br><span class="line">    pos_list.append([random.randint(<span class="hljs-number">1</span>, boardsize), </span><br><span class="line">                     random.randint(<span class="hljs-number">1</span>, boardsize)])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Initialize the board</span></span><br><span class="line">my_board = np.zeros((boardsize+pad, boardsize+pad))</span><br><span class="line">my_board = init_board(pos_list, my_board)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">##### Animate the board #####</span></span><br><span class="line"><span class="hljs-comment"># This will throw an error the first time you run the code, but the program will run properly if you</span></span><br><span class="line"><span class="hljs-comment"># execute the cell again (there is an error with the animation package that I cannot seem to get rid of)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Required line for plotting the animation</span></span><br><span class="line">%matplotlib notebook</span><br><span class="line"><span class="hljs-comment"># Initialize the plot of the board that will be used for animation</span></span><br><span class="line">fig = plt.gcf()</span><br><span class="line"><span class="hljs-comment"># Show first image - which is the initial board</span></span><br><span class="line">im = plt.imshow(my_board)</span><br><span class="line">plt.show()</span><br><span class="line">plt.savefig(fname=<span class="hljs-string">'game_of_life'</span>, dpi=<span class="hljs-number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Helper function that updates the board and returns a new image of</span></span><br><span class="line"><span class="hljs-comment"># the updated board animate is the function that FuncAnimation calls</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">animate</span><span class="hljs-params">(frame)</span>:</span></span><br><span class="line">    im.set_data(update_board(my_board))</span><br><span class="line">    <span class="hljs-keyword">return</span> im,</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># This line creates the animation</span></span><br><span class="line">anim = animation.FuncAnimation(fig, animate, frames=<span class="hljs-number">200</span>, </span><br><span class="line">                               interval=<span class="hljs-number">50</span>)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望这篇文章能帮到大家。在结束之前，让我来帮助大家脑补更多我们今天学到的动画功能在数据科学上的应用：</p><ul><li><p>一个个地画出蒙特卡洛模拟数据，你能观察到最终的分布是如何逐步形成的；</p></li><li><p>按顺序遍历时间序列数据，可以描绘你的模型或数据在新的观察角度下有什么表现；</p></li><li><p>当你改变输入参数时，比如族群数，可以展现你的算法是如何划分族群的；</p></li><li><p>根据时间或不同的数据子集生成关联热力图，用于观察不同的样本是如何影响你的模型的预期参数的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#引言&lt;/p&gt;
&lt;p&gt;Python 的 Matplotlib 是最常用的图表绘制以及数据可视化库。我们对折线图、柱状图以及热力图都比较熟悉，但你知道用 Matplotlib 还能做简单的动画吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="生命游戏" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>镜像站</title>
    <link href="http://yoursite.com/2019/09/18/%E9%95%9C%E5%83%8F%E7%AB%99/"/>
    <id>http://yoursite.com/2019/09/18/镜像站/</id>
    <published>2019-09-18T14:38:20.000Z</published>
    <updated>2019-09-28T01:36:17.397Z</updated>
    
    <content type="html"><![CDATA[<p>网易镜像：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></p><p>阿里云镜像：<a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a></p><a id="more"></a><p>中国科学技术大学镜像：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p><p>厦门大学镜像：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a></p><p>搜狐镜像：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></p><p>北京交通大学镜像：<a href="http://mirror.bjtu.edu.cn/" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn/</a></p><p>北京理工大学镜像：<a href="http://mirror.bit.edu.cn/web/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/web/</a></p><p>兰州大学镜像：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a></p><p>上海交通大学镜像：<a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a></p><p>清华大学镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>东北大学镜像：<a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a></p><p>浙江大学镜像：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></p><p>东软信息学院：<a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a></p><p>重庆大学镜像：<a href="http://mirrors.cqu.edu.cn/" target="_blank" rel="noopener">http://mirrors.cqu.edu.cn/</a></p><p>大连理工大学镜像：<a href="http://mirror.dlut.edu.cn/" target="_blank" rel="noopener">http://mirror.dlut.edu.cn/</a></p><p>CN99镜像：<a href="http://mirrors.cn99.com/" target="_blank" rel="noopener">http://mirrors.cn99.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网易镜像：&lt;a href=&quot;http://mirrors.163.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.163.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云镜像：&lt;a href=&quot;http://mirrors.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="镜像" scheme="http://yoursite.com/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>AI领域区分介绍</title>
    <link href="http://yoursite.com/2019/09/15/AI%E9%A2%86%E5%9F%9F%E5%8C%BA%E5%88%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/09/15/AI领域区分介绍/</id>
    <published>2019-09-15T09:42:11.000Z</published>
    <updated>2019-09-17T03:21:43.579Z</updated>
    
    <content type="html"><![CDATA[<p>说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。<a id="more"></a>例如京东会根据你的浏览行为和用户的相似性，利用算法为你推荐你需要的产品；又比如美颜相机，会基于你面部特征的分析，通过算法精细你的美颜效果。还有众所周知的谷歌DeepMind，当AlphaGo打败了韩国职业围棋高手Lee Se-dol时，媒体描述这场人机对战的时候，提到了人工智能AI、机器学习、深度学习等术语。没错，这三项技术都为AlphaGo的胜利立下了汗马功劳，然而它们并不是一回事。</p><p>人工智能和机器学习的同时出现，机器学习和深度学习的交替使用……使大部分读者雾里看花，这些概念究竟有何区别，我们可以通过下面一个关系图来进行区分。</p><p><img src="https://i.loli.net/2019/08/31/fmbgJWRBzT5hMI4.jpg" alt="1.jpg"></p><center>图一：人工智能、机器学习、深度学习的关系</center><p>人工智能包括了机器学习和深度学习，机器学习包括了深度学习。人工智能是机器学习的父类，机器学习则是深度学习的父类。</p><p>人工智能（Artificial Intelligence，AI）是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的与人类智能相似的方式作出反应的智能机器，它不是人的智能，但能像人那样思考、也可能超过人的智能。</p><p>人工智能实际应用：机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。人工智能目前也分为：强人工智能(BOTTOM-UPAI)和弱人工智能(TOP-DOWNAI)。</p><p>机器学习（Machine Learning，ML）是人工智能的核心，属于人工智能的一个分支。机器学习是指从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法，所以机器学习的核心是数据、算法（模型）、算力（计算机运算能力）。</p><p>机器学习应用领域：数据挖掘、数据分类、计算机视觉、自然语言处理(NLP)、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用等。</p><p>深度学习（Deep Learning，DL）：是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据。</p><p>数据挖掘（Data Mining，DM），顾名思义是指利用机器学习技术从海量数据中“挖掘”隐藏信息，主要应用于图像、声音、文本。在商业环境中，企业希望让存放在数据库中的数据能“说话”，支持决策。所以数据挖掘更偏向于应用。</p><p><img src="https://i.loli.net/2019/08/31/uHUkLpMN87ZtrYV.jpg" alt="2.jpg"></p><center>图二：数据挖掘与机器学习的关系</center><p>机器学习是数据挖掘的一种重要方法，但机器学习是另一门学科，并不从属于数据挖掘，二者相辅相成。数据挖掘是机器学习和数据库的交叉，主要利用机器学习提供的技术来分析海量数据，利用数据库界提供的技术来管理海量数据。</p><p>不管是人工智能、机器学习、深度学习还是数据挖掘，目前都在解决共同目标时发挥了自己的优势，并为社会生产和人类生活提供便利，帮助我们探索过去、展示现状、预测未来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>为Anaconda3安装tensorflow等</title>
    <link href="http://yoursite.com/2019/09/15/%E4%B8%BAAnaconda3%E5%AE%89%E8%A3%85tensorflow%E7%AD%89/"/>
    <id>http://yoursite.com/2019/09/15/为Anaconda3安装tensorflow等/</id>
    <published>2019-09-15T09:39:38.000Z</published>
    <updated>2019-09-29T11:11:36.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda3介绍"><a href="#Anaconda3介绍" class="headerlink" title="Anaconda3介绍"></a>Anaconda3介绍</h1><p>简单来说，Anaconda是Python的包管理器和环境管理器。</p><p>先来解决一个初学者都会问的问题：我已经安装了Python，那么为什么还需要Anaconda呢？原因有以下几点：</p><a id="more"></a><ol><li><p>Anaconda附带了一大批常用数据科学包，它附带了conda、Python和 150 多个科学包及其依赖项。因此你可以用Anaconda立即开始处理数据。</p></li><li><p>管理包。Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这些包，包括安装、卸载和更新包。</p></li><li><p>管理环境。为什么需要管理环境呢？比如你在A项目中用到了Python2，而新的项目要求使用Python3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候conda就可以帮助你为不同的项目建立不同的运行环境。还有很多项目使用的包版本不同，比如不同的pandas版本，不可能同时安装两个pandas版本。你要做的应该是在项目对应的环境中创建对应的pandas版本。这时候conda就可以帮你做到。</p></li></ol><h1 id="Anaconda3的安装"><a href="#Anaconda3的安装" class="headerlink" title="Anaconda3的安装"></a>Anaconda3的安装</h1><ol><li><a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/" target="_blank" rel="noopener">清华镜像</a></li></ol><p>关于安装过程中的细节,如全局变量设置…可自行百度,下面我们转入正题</p><h1 id="Anaconda3安装tensorflow"><a href="#Anaconda3安装tensorflow" class="headerlink" title="Anaconda3安装tensorflow"></a>Anaconda3安装tensorflow</h1><ol><li><p>打开anaconda安装时自带的Anaconda prompt</p></li><li><p>打开后,输入清华镜像的tensorflow的下载地址(如果你已经在墙外翱翔了,可以省略这一步):</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>接着我们开始创建一个python3.6的环境,因为如果你安装的是最新的anaconda,它默认环境为py3.7,并且在不久之前,tensorflow已经开始支持py3.6,所以我们创建一个py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=3.6</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>启动anaconda中的py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow</span><br></pre></td></tr></table></figure></li></ol><p>如果不能进入,则重新执行第3步骤</p><ol start="5"><li>进入py3.6的环境中后,我们就可以进行安装了(此处我们安装的是CPU版本的tensorflow):<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade --ignore-installed tensorflow</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>当我们不使用tensorflow时,我们就可以使用:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></li></ol><p> 退出该环境</p><ol start="7"><li>开始测试一下是否安装成功:</li></ol><p>重新打开Anaconda Prompt—&gt;activate tensorflow—&gt;python来启动tensorflow，并进入python环境<br> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#TensorFlow使用图(Graph)来表示计算任务；并使用会话(Session)来执行图，通过Session.close()来关闭会话（这是一种显式关闭会话的方式）。会话方式有显式和隐式会话之分。</span></span><br><span class="line"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="hljs-string">'Hello, TensorFlow!'</span>)  <span class="hljs-comment">#初始化一个TensorFlow的常量</span></span><br><span class="line">sess = tf.Session()  <span class="hljs-comment">#启动一个会话</span></span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></p><p>如果可以准确的输出结果,那么恭喜你,安装tensorflow成功!</p><h1 id="Anaconda3安装pytorch"><a href="#Anaconda3安装pytorch" class="headerlink" title="Anaconda3安装pytorch"></a>Anaconda3安装pytorch</h1><ol><li><p>打开anaconda安装时自带的Anaconda prompt</p></li><li><p>创建py3.6环境:</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=3.6</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>启动anaconda中的py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pytorch</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>PyTorch 的官网提供了简单的安装方法，只需简单的命令即可。</li></ol><p>首先，打开 PyTorch 官网安装页面（需自备梯子）：<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">https://pytorch.org/get-started/locally/</a></p><p>然后复制页面中Run this Command后的代码,粘贴在你的命令行,等待安装完成就可以了~</p><h1 id="Anaconda3安装keras"><a href="#Anaconda3安装keras" class="headerlink" title="Anaconda3安装keras"></a>Anaconda3安装keras</h1><p>其实keras是可以与tensorflow在共同环境下使用的,所以我们可以直接将keras安装在我们的tensorflow环境中。</p><ol><li><p>打开anaconda安装时自带的Anaconda prompt</p></li><li><p>创建py3.6环境:</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=3.6</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>启动anaconda中的py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>直接运行命令:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install keras</span><br><span class="line">或者</span><br><span class="line">pip install keras</span><br></pre></td></tr></table></figure></li></ol><p> 等待安装完成即可~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Anaconda3介绍&quot;&gt;&lt;a href=&quot;#Anaconda3介绍&quot; class=&quot;headerlink&quot; title=&quot;Anaconda3介绍&quot;&gt;&lt;/a&gt;Anaconda3介绍&lt;/h1&gt;&lt;p&gt;简单来说，Anaconda是Python的包管理器和环境管理器。&lt;/p&gt;
&lt;p&gt;先来解决一个初学者都会问的问题：我已经安装了Python，那么为什么还需要Anaconda呢？原因有以下几点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Anaconda" scheme="http://yoursite.com/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>关于论文作者那点事</title>
    <link href="http://yoursite.com/2019/09/15/%E5%85%B3%E4%BA%8E%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/09/15/关于论文作者那点事/</id>
    <published>2019-09-15T09:37:21.000Z</published>
    <updated>2019-09-28T01:38:50.948Z</updated>
    
    <content type="html"><![CDATA[<p>对于论文想必大家可能都有过耳闻,今天做一下一些相关知识的普及~</p><a id="more"></a><p>首先,第一作者和通讯作者之间一直是缠缠绵绵到天涯的关系，很多人对这两者并不陌生，但是在一些细节上的问题又感觉比较绕，我今天特意收集了平时大家提到的关于两者之间的一些问题，做成问答集锦，你想知道的，都在里面啦~</p><h1 id="什么是第一作者？"><a href="#什么是第一作者？" class="headerlink" title="什么是第一作者？"></a>什么是第一作者？</h1><p>第一作者通常主导大部分的实验工作，在一般的情况下，引用一篇论文时，提到的就是第一作者的名字，如 Tomas et al. report that…。</p><p>以第一作者的身份进行论文发表对博士生的科研路是很重要的，不止中国，全球大部分的博士毕业标准都要求学生要作为第一作者发表至少一篇论文。</p><p>对博士后及资深教授来说，作为第一作者的期刊论文发表是争取基金、职称晋升及续聘时的重要因素。据此，期刊论文的作者名单里，第一个名字一直是最抢手的位置。</p><p>在第一作者之后，作者顺序是根据对研究的贡献度排序，贡献度越高的排名越前。不过，有时候可能会有多位作者贡献度相同，这时候就可以列为共同一作、共同二作…</p><p><strong>注意:</strong>第一作者很重要很重要很重要，要毕业、评职称、争基金…没头发可以，没它不行~</p><h1 id="什么是通讯作者？"><a href="#什么是通讯作者？" class="headerlink" title="什么是通讯作者？"></a>什么是通讯作者？</h1><p>通讯作者是课题的总负责人，承担课题的经费、设计、文章的书写和把关，在投稿、同行评审和整个发表流程中负责和期刊沟通。从知识产权的角度来说，研究成果算是通讯作者的。能当通讯作者的人一般有以下几类：</p><ul><li>论文的法定负责人:</li></ul><p>通讯作者也是论文的主要受益人之一。也可以这么说，论文的第一作者是这项科研成果的主要贡献者，而论文的通讯作者是这项成果的责任者和受益人。</p><ul><li>导师、教授、科研项目的主要负责人</li></ul><p>其主要贡献是提供研究指导、研究经费、试验场所、实验室、仪器设备等与实验相关的物质资源。</p><ul><li>论文的任何作者</li></ul><p>要是一篇论文有数个作者，通讯作者可以是他们中的任何一位。至于到底是谁，主要看通讯作者在这项研究中真正起的作用和做出的贡献。要是他在整个实验中做到了关键的作用，那么他就理所当然地即可做第一作者，也可做通讯作者。</p><p><strong>注意:</strong></p><p>对于学生来说，通讯作者一般是他的导师。</p><p>对于研究机构来说，通讯作者一般是项目负责人。</p><p>对于出版机构来说，通讯作者可以是机构老板。</p><p>另外！！！一定要有固定的通讯地址！</p><h1 id="第一作者和通讯作者，谁更重要？"><a href="#第一作者和通讯作者，谁更重要？" class="headerlink" title="第一作者和通讯作者，谁更重要？"></a>第一作者和通讯作者，谁更重要？</h1><p>通讯作者未必是第一作者，但第一作者可以是通讯作者。通讯作者多数情况和第一作者是同一个人，只有在通讯作者和第一作者不一致的时候，才有必要在文章脚注中附加通讯作者的标识。</p><p>所以，总的来说都重要！对于作者来说，第一作者很重要，谁是通讯作者没关系，但是通讯单位很关键，很多单位评职称看通讯单位，不看通讯作者。对于导师来说，通讯作者重要，因为导师永远当通讯作者，至于谁是第一作者不重要。对于出版机构来说，通讯作者非常重要，因为机构老板也常是通讯作者…</p><p><strong>注意:</strong>通讯作者不是随便挂的，一旦出现通讯作者，这篇文章的科研版权就要非常注意了~</p><h1 id="共同一作排序重要吗，会影响评职称吗？"><a href="#共同一作排序重要吗，会影响评职称吗？" class="headerlink" title="共同一作排序重要吗，会影响评职称吗？"></a>共同一作排序重要吗，会影响评职称吗？</h1><p>共同作者排在第一位的是最好，所有东西都可以申请。因为排第一的肯定是第一作者，大家引用的时候都会缩写成“First-Author, et al，但是排在第二位就要小心了，排在第二位的虽然也是共同第一作者，但是有些单位只看第一位的，所以评职称的时候一定要问清楚单位科研处排在第二的共同作者能否评职称。</p><p>不过事无绝对，以下一些例子里面的共同一作和第一作者的贡献量和含金量差不多，排序嘛，就比较随便了···</p><ol><li>按作者名字的字母顺序决定作者排序</li></ol><p><a href="https://sm.ms/image/NpaYABfEITyMwt5" target="_blank"><img src="https://i.loli.net/2019/08/17/NpaYABfEITyMwt5.jpg"></a></p><ol start="2"><li>抛硬币决定作者顺序</li></ol><p><a href="https://sm.ms/image/ZyXo9RD1WfUMC7N" target="_blank"><img src="https://i.loli.net/2019/08/17/ZyXo9RD1WfUMC7N.jpg"></a></p><ol start="3"><li>根据对星战的痴迷程度决定作者顺序</li></ol><p><a href="https://sm.ms/image/PMtcUr7h4k1nfLl" target="_blank"><img src="https://i.loli.net/2019/08/17/PMtcUr7h4k1nfLl.jpg"></a></p><ol start="4"><li>根据申tenure的时间远近决定作者顺序</li></ol><p><a href="https://sm.ms/image/UKyMEtvofZhA4QO" target="_blank"><img src="https://i.loli.net/2019/08/17/UKyMEtvofZhA4QO.jpg"></a></p><p><strong>注意:</strong>国内对作者排序还是很重视的，很多机构和单位甚至只认可排序靠前的，所以能排前面就别排后面啦~</p><h1 id="所有的论文都要有通讯作者吗？"><a href="#所有的论文都要有通讯作者吗？" class="headerlink" title="所有的论文都要有通讯作者吗？"></a>所有的论文都要有通讯作者吗？</h1><p>并不是要求所有的论文都一定要写通讯作者。对于没有通讯作者的稿件，默认第一作者为通讯作者。</p><p>通讯作者多数情况和第一作者是同一个人，这样的话实际上是省略了通讯作者。只有在通讯作者和第一作者不一致的时候，才有必要加通讯作者。不赞成一味地模仿国外杂志，加不加通讯作者应根据需要而定。</p><p><strong>注意:</strong>通讯作者非必须，随意模仿不可取~</p><h1 id="我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？"><a href="#我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？" class="headerlink" title="我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？"></a>我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？</h1><p>目前，最常见的做法是权力最大的排最后，权力排倒数第二，也就是大老板排最后，小老板排倒数第二。一般期刊只能允许两位通讯作者，在文章中标注，列出他们的邮箱，偶尔也会看见有些期刊会有三个通讯，不过也有些期刊不准共同通讯，只能一个人。所以在投稿前一定要仔细阅读稿约。</p><p><strong>注意:</strong>根据权力大小排就对了！</p><h1 id="导师可以既是第一作者，又是通讯作者吗？"><a href="#导师可以既是第一作者，又是通讯作者吗？" class="headerlink" title="导师可以既是第一作者，又是通讯作者吗？"></a>导师可以既是第一作者，又是通讯作者吗？</h1><p>可以。第一作者兼任通讯作者没什么问题，更何况，对单一作者的论文来说，第一作者和通讯作者肯定是同一个人。如果你的教授对研究也出谋划策，拟出初始计划和研究设计，一定要将他列为共同作者。至于具体怎么做，还是需要跟导师商量，达成一致，避免日后产生争议。</p><p><strong>注意:</strong>导师可以既当第一作者，又当通讯作者。</p><h1 id="论文被接受，还能更换作者顺序和通讯作者吗？"><a href="#论文被接受，还能更换作者顺序和通讯作者吗？" class="headerlink" title="论文被接受，还能更换作者顺序和通讯作者吗？"></a>论文被接受，还能更换作者顺序和通讯作者吗？</h1><p>一般来说，期刊对于作者顺序变更不会有太大的意见，但非必要最好避免更换通讯作者，因为期刊编辑和通讯作者之间已经有过交流，有一定的熟悉程度。</p><p>不过，如果有不可抗拒的因素需要换通讯作者跟作者顺序的话，一定要跟编辑沟通解释清楚，因为这会涉及到之后的一系列问题，例如评职称、申奖金等等。另外，修改作者的时候，一定要附上新的版权~</p><p><strong>注意:</strong>作者顺序可以改，通讯作者最好不要改！</p><h1 id="不是通讯作者可以直接和期刊编辑联系吗？"><a href="#不是通讯作者可以直接和期刊编辑联系吗？" class="headerlink" title="不是通讯作者可以直接和期刊编辑联系吗？"></a>不是通讯作者可以直接和期刊编辑联系吗？</h1><p>通讯作者的作用就是期刊编辑最主要的联系窗口，相关的沟通事宜都是通讯作者负责，不是通讯作者最好不要和期刊编辑联系，为避免将事情复杂化，最好是将事情积极反馈给通讯作者，再由通讯作者和期刊编辑沟通。</p><p><strong>注意:</strong>让通讯作者架起沟通的桥梁~</p><h1 id="论文被查出学术不端，负责的应该是第一作者还是通讯作者？"><a href="#论文被查出学术不端，负责的应该是第一作者还是通讯作者？" class="headerlink" title="论文被查出学术不端，负责的应该是第一作者还是通讯作者？"></a>论文被查出学术不端，负责的应该是第一作者还是通讯作者？</h1><p>通讯作者是要对论文的全程进行把关的。特别是对里面内容的真实性，论证的根据等，有没有达到发表的水平。所以，通讯作者，既是一个署名权，更重要的是对这篇学术论文承担的责任。如果这篇文章出问题，通讯作者是第一责任人！当然那些没有被告知，就被别人列为论文的通讯作者，还是会有背黑锅的时候···</p><p><strong>注意:</strong>通讯作者负责就要负到底！</p><h1 id="让有名望的学者当通讯作者是不是能增加论文的投中率？"><a href="#让有名望的学者当通讯作者是不是能增加论文的投中率？" class="headerlink" title="让有名望的学者当通讯作者是不是能增加论文的投中率？"></a>让有名望的学者当通讯作者是不是能增加论文的投中率？</h1><p>如果在学术界口碑好、有名望教授当自己论文的通讯作者，会增加论文的投中率。因为通讯作者需要对论文把关，好口碑的教授一般学风严谨，出任通讯作者也是以自己的名誉来做担保，所以编辑在审查的时候，也会增加对论文的好感度，最后能不能投中关键的还是看论文的质量。</p><p><strong>注意:</strong>论文能不能投中关键还是靠质量~</p><p>最后,提醒一下大家：<strong>研究项目启动前是决定署名作者及其排名顺序的最佳时机</strong>，参与项目的团队成员必须在这些方面达成完全一致，毕竟按劳所得是亘古不变的真理~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于论文想必大家可能都有过耳闻,今天做一下一些相关知识的普及~&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>机器学习分类算法</title>
    <link href="http://yoursite.com/2019/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/12/机器学习分类算法/</id>
    <published>2019-09-12T12:10:45.000Z</published>
    <updated>2019-09-17T03:22:30.083Z</updated>
    
    <content type="html"><![CDATA[<p>说起分类算法，相信学过机器学习的同学都能侃上一二。</p><p>可是，你能够如数家珍地说出所有常用的分类算法，以及他们的特征、优缺点吗？比如说，你可以快速地回答下面的问题么:</p><a id="more"></a><ul><li><p>KNN算法的优缺点是什么？</p></li><li><p>Naive Bayes算法的基本假设是什么？</p></li><li><p>entropy loss是如何定义的？</p></li><li><p>最后，分类算法调参常用的图像又有哪些？</p></li></ul><p>可能真的涉及这些问题时候，我们不能快速的回答，所以我总结了此文~</p><p>机器学习是一种能从数据中学习的计算机编程科学以及艺术，就像下面这句话说得一样。</p><blockquote><p>机器学习是使计算机无需显式编程就能学习的研究领域。——阿瑟·塞缪尔，1959年</p></blockquote><p>不过还有一个更好的定义：</p><blockquote><p>“如果一个程序在使用既有的经验（E）执行某类任务（T）的过程中被认为是“具备学习能力的”，那么它一定需要展现出:利用现有的经验（E），不断改善其完成既定任务（T）的性能（P）的特性。” ——Tom Mitchell, 1997</p></blockquote><p>例如，你的垃圾邮件过滤器是一个机器学习程序，通过学习用户标记好的垃圾邮件和常规非垃圾邮件示例，它可以学会标记垃圾邮件。系统用于学习的示例称为训练集。在此案例中，任务（T）是标记新邮件是否为垃圾邮件，经验（E）是训练数据，性能度量（P） 需要定义。例如，你可以定义正确分类的电子邮件的比例为P。这种特殊的性能度量称为准确度，这是一种有监督的学习方法，常被用于分类任务。</p><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>在监督学习中，算法从有标记数据中学习。在理解数据之后，该算法通过将模式与未标记的新数据关联来确定应该给新数据赋哪种标签。</p><p>监督学习可以分为两类：<strong>分类</strong>和<strong>回归</strong>。</p><p><strong>分类问题预测数据所属的类别</strong>；</p><p>分类的例子包括垃圾邮件检测、客户流失预测、情感分析、犬种检测等。</p><p><strong>回归问题根据先前观察到的数据预测数值</strong>；</p><p>回归的例子包括房价预测、股价预测、身高-体重预测等。</p><h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>分类是一种基于一个或多个自变量确定因变量所属类别的技术。</p><p><a href="https://sm.ms/image/isQALwyZW2k8qXa" target="_blank"><img src="https://i.loli.net/2019/09/12/isQALwyZW2k8qXa.jpg"></a></p><h1 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h1><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>逻辑回归类似于线性回归，适用于因变量不是一个数值字的情况 (例如，一个“是/否”的响应)。它虽然被称为回归，但却是基于根据回归的分类，将因变量分为两类。</p><p><a href="https://sm.ms/image/lXzAYr9EwIxL8su" target="_blank"><img src="https://i.loli.net/2019/09/12/lXzAYr9EwIxL8su.jpg"></a></p><p>如上所述，逻辑回归用于预测二分类的输出。例如，如果信用卡公司构建一个模型来决定是否通过向客户的发行信用卡申请，它将预测客户的信用卡是否会“违约”。</p><p><a href="https://sm.ms/image/AnCUkFxLyr4KqMQ" target="_blank"><img src="https://i.loli.net/2019/09/12/AnCUkFxLyr4KqMQ.jpg"></a></p><p>首先对变量之间的关系进行线性回归以构建模型，分类的阈值假设为0.5。    </p><p><a href="https://sm.ms/image/Th4bsK92YPzqfZO" target="_blank"><img src="https://i.loli.net/2019/09/12/Th4bsK92YPzqfZO.jpg"></a></p><p>然后将Logistic函数应用于回归分析，得到两类的概率。</p><p>该函数给出了事件发生和不发生概率的对数。最后，根据这两类中较高的概率对变量进行分类。</p><p><a href="https://sm.ms/image/DU8lJCFVas4Oiqz" target="_blank"><img src="https://i.loli.net/2019/09/12/DU8lJCFVas4Oiqz.jpg"></a></p><h2 id="K-近邻算法（K-NN）"><a href="#K-近邻算法（K-NN）" class="headerlink" title="K-近邻算法（K-NN）"></a>K-近邻算法（K-NN）</h2><p>K-NN算法是一种最简单的分类算法，通过识别被分成若干类的数据点，以预测新样本点的分类。K-NN是一种非参数的算法，是“懒惰学习”的著名代表，它根据相似性（如，距离函数）对新数据进行分类。</p><p><a href="https://sm.ms/image/sXxPpoTJ1kY5SIV" target="_blank"><img src="https://i.loli.net/2019/09/12/sXxPpoTJ1kY5SIV.jpg"></a><br><a href="https://sm.ms/image/d1MlhBKkIQ7uDgs" target="_blank"><img src="https://i.loli.net/2019/09/12/d1MlhBKkIQ7uDgs.jpg"></a><br><a href="https://sm.ms/image/GCNHeT3znA51Eqt" target="_blank"><img src="https://i.loli.net/2019/09/12/GCNHeT3znA51Eqt.jpg"></a><br><a href="https://sm.ms/image/ouEkChiFIq8VNDW" target="_blank"><img src="https://i.loli.net/2019/09/12/ouEkChiFIq8VNDW.jpg"></a></p><p>K-NN能很好地处理少量输入变量（p）的情况，但当输入量非常大时就会出现问题。  </p><h2 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h2><p>支持向量机既可用于回归也可用于分类。它基于定义决策边界的决策平面。决策平面（超平面）可将一组属于不同类的对象分离开。</p><p><a href="https://sm.ms/image/SIw1KX9NGdnfY7s" target="_blank"><img src="https://i.loli.net/2019/09/12/SIw1KX9NGdnfY7s.jpg"></a></p><p>在支持向量的帮助下，SVM通过寻找超平面进行分类，并使两个类之间的边界距离最大化。</p><p><a href="https://sm.ms/image/4r8JBhTmC2ntFYz" target="_blank"><img src="https://i.loli.net/2019/09/12/4r8JBhTmC2ntFYz.jpg"></a></p><p>SVM中超平面的学习是通过将问题转化为使用一些某种线性代数转换问题来完成的。（上图的例子是一个线性核，它在每个变量之间具有线性可分性）。</p><p>对于高维数据，使用可使用其他核函数，但高维数据不容易进行分类。具体方法将在之后阐述。</p><h3 id="核支持向量机"><a href="#核支持向量机" class="headerlink" title="核支持向量机"></a>核支持向量机</h3><p>核支持向量机将核函数引入到SVM算法中，并将其转换为所需的形式，将数据映射到可分的高维空间。</p><p>核函数的类型包括：</p><p><a href="https://sm.ms/image/9MXo82Y6StNZrOW" target="_blank"><img src="https://i.loli.net/2019/09/12/9MXo82Y6StNZrOW.jpg"></a></p><ul><li><p>前文讨论的就是线性SVM。</p></li><li><p>多项式核中需要指定多项式的次数。它允许在输入空间中使用曲线进行分割。</p></li><li><p>径向基核（radial basis function, RBF）可用于非线性可分变量。使用平方欧几里德距离，参数的典型值会导致过度拟合。sklearn中默认使用RBF。</p></li><li><p>类似于与逻辑回归类似，sigmoid核用于二分类问题。</p></li></ul><p><a href="https://sm.ms/image/4MDKNmzP26lBIUh" target="_blank"><img src="https://i.loli.net/2019/09/12/4MDKNmzP26lBIUh.jpg"></a></p><h3 id="径向基核（RBF：Radial-Basis-Function-）"><a href="#径向基核（RBF：Radial-Basis-Function-）" class="headerlink" title="径向基核（RBF：Radial Basis Function ）"></a>径向基核（RBF：Radial Basis Function ）</h3><p>RBF核支持向量机的决策区域实际上也是一个线性决策区域。RBF核支持向量机的实际作用是构造特征的非线性组合，将样本映射到高维特征空间，再利用线性决策边界分离类。</p><p><a href="https://sm.ms/image/9p1qE7lGF6QScYm" target="_blank"><img src="https://i.loli.net/2019/09/12/9p1qE7lGF6QScYm.jpg"></a></p><p>因此，可以得出经验是：对线性问题使用线性支持向量机，对非线性问题使用非线性核函数，如RBF核函数。</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯分类器建立在贝叶斯定理的基础上，基于特征之间互相独立的假设（假定类中存在一个与任何其他特征无关的特征）。即使这些特征相互依赖，或者依赖于其他特征的存在，朴素贝叶斯算法都认为这些特征都是独立的。这样的假设过于理想，朴素贝叶斯因此而得名。</p><p><a href="https://sm.ms/image/6vg1DwypuzBiLeV" target="_blank"><img src="https://i.loli.net/2019/09/12/6vg1DwypuzBiLeV.jpg"></a></p><p>在朴素贝叶斯的基础上，高斯朴素贝叶斯根据二项（正态）分布对数据进行分类。</p><p><a href="https://sm.ms/image/wuVQl1qF9Bgfyt5" target="_blank"><img src="https://i.loli.net/2019/09/12/wuVQl1qF9Bgfyt5.jpg"></a></p><p>P(class|data) 表示给定特征（属性）后数据属于某类（目标）的后验概率。给定数据，其属于各类的概率大小就是我们要计算的值。</p><p>P(class)表示某类的先验概率。</p><p>P(data|class)表示似然，是指定类别时特征出现的概率。</p><p>P(data)表示特征或边际似然的先验概率。</p><p><a href="https://sm.ms/image/cGoCjiKS6dyfrDz" target="_blank"><img src="https://i.loli.net/2019/09/12/cGoCjiKS6dyfrDz.jpg"></a></p><p><strong>步骤:</strong></p><p><strong>1、计算先验概率</strong></p><p>P(class) = 类中数据点的数量/观测值的总数量</p><p>P(yellow) = 10/17</p><p>P(green) = 7/17</p><p><strong>2、计算边际似然</strong></p><p>P(data) = 与观测值相似的数据点的数量/观测值的总数量</p><p>P(?) = 4/17</p><p>该值用于检查各个概率。</p><p><strong>3、计算似然</strong></p><p>P(data/class) = 类中与观测值相似的数量/类中点的总数量</p><p>P(?/yellow) = 1/7</p><p>P(?/green) = 3/10</p><p><strong>4、计算各类的后验概率</strong></p><p><a href="https://sm.ms/image/VBUrNiq3HLOk5Ix" target="_blank"><img src="https://i.loli.net/2019/09/12/VBUrNiq3HLOk5Ix.jpg"></a></p><p><strong>5、分类</strong></p><p><a href="https://sm.ms/image/ECulc8Zj19aV4sN" target="_blank"><img src="https://i.loli.net/2019/09/12/ECulc8Zj19aV4sN.jpg"></a></p><p>某一点归于后验概率高的类别，因为从上可知其属于绿色类的概率是75%根据其75%的概率这个点属于绿色类。</p><p>多项式、伯努利朴素贝叶斯是计算概率的其他模型。朴素贝叶斯模型易于构建，不需要复杂的参数迭代估计，这使得它对非常大的数据集特别有用。</p><h2 id="决策树分类"><a href="#决策树分类" class="headerlink" title="决策树分类"></a>决策树分类</h2><p><strong>决策树以树状结构构建分类或回归模型</strong>。它通过将数据集不断拆分为更小的子集来使决策树不断生长。最终长成具有决策节点（包括根节点和内部节点）和叶节点的树。最初决策树算法它采用采用Iterative Dichotomiser 3（ID3）算法来确定分裂节点的顺序。</p><p><a href="https://sm.ms/image/hQLl2H65fwUaxA3" target="_blank"><img src="https://i.loli.net/2019/09/12/hQLl2H65fwUaxA3.jpg"></a></p><p>信息熵和信息增益用于被用来构建决策树。</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息熵是衡量元素无序状态程度的一个指标，即衡量信息的不纯度。</p><p><a href="https://sm.ms/image/gRXyfz1eojrQ5BH" target="_blank"><img src="https://i.loli.net/2019/09/12/gRXyfz1eojrQ5BH.jpg"></a></p><p>信息熵是衡量元素的无序状态的程度的一个指标，或者说，衡量信息的不纯度。</p><p><a href="https://sm.ms/image/gRXyfz1eojrQ5BH" target="_blank"><img src="https://i.loli.net/2019/09/12/gRXyfz1eojrQ5BH.jpg"></a></p><p>直观上说地理解，信息熵表示一个事件的确定性程度。信息熵度量样本的同一性，如果样本全部属于同一类，则信息熵为0；如果样本等分成不同的类别，则信息熵为1。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益测量独立属性间信息熵的变化。它试图估计每个属性本身包含的信息，构造决策树就是要找到具有最高信息增益的属性（即纯度最高的分支）。</p><p><a href="https://sm.ms/image/T9KFHY5frNRgAUk" target="_blank"><img src="https://i.loli.net/2019/09/13/T9KFHY5frNRgAUk.jpg"></a></p><p>信息增益测量独立属性间的信息熵的变化。它试图估计每个属性本身包含的信息，构造决策树就是要找到具有最高信息增益的属性（即纯度最高的分支）。</p><p><a href="https://sm.ms/image/T9KFHY5frNRgAUk" target="_blank"><img src="https://i.loli.net/2019/09/13/T9KFHY5frNRgAUk.jpg"></a></p><p>其中Gain（(T,X）)是特征X的信息增益。Entropy(T)是整个集合的信息熵，第二项Entropy(T,X)是特征X的信息熵。</p><p>采用信息熵进行节点选择时，通过对该节点各个属性信息增益进行排序，选择具有最高信息增益的属性作为划分节点，过滤掉其他属性。</p><p>决策树模型存在的一个问题是容易过拟合。因为在其决策树构建过程中试图通过生成长一棵完整的树来拟合训练集，因此却降低了测试集的准确性。</p><p><a href="https://sm.ms/image/zK6R4baDiCWENPj" target="_blank"><img src="https://i.loli.net/2019/09/13/zK6R4baDiCWENPj.jpg"></a></p><p>通过剪枝技术可以减少小决策树的过拟合问题。</p><h2 id="分类的集成算法"><a href="#分类的集成算法" class="headerlink" title="分类的集成算法"></a>分类的集成算法</h2><p>集成算法是一个模型组。从技术上说，集成算法是单独训练几个有监督模型，并将训练好的模型以不同的方式进行融合，从而达到最终的得预测结果。集成后的模型比其中任何一个单独的模型都有更高的预测能力。</p><p><a href="https://sm.ms/image/bwTqQKcEfJyzA9t" target="_blank"><img src="https://i.loli.net/2019/09/13/bwTqQKcEfJyzA9t.jpg"></a></p><h2 id="随机森林分类器"><a href="#随机森林分类器" class="headerlink" title="随机森林分类器"></a>随机森林分类器</h2><p>随机森林分类器是一种基于<strong>装袋（bagging）</strong>的集成算法，即<strong>自举助聚合法(bootstrap aggregation)</strong>。集成算法结合了多个相同或不同类型的算法来对对象进行分类（例如，SVM的集成，基于朴素贝叶斯的集成或基于决策树的集成）。</p><p><a href="https://sm.ms/image/nbhWdHzm5eVSyjf" target="_blank"><img src="https://i.loli.net/2019/09/13/nbhWdHzm5eVSyjf.jpg"></a></p><p>集成的基本思想是算法的组合提升了最终的结果。</p><p><a href="https://sm.ms/image/aOwBtyY5fh9mEMg" target="_blank"><img src="https://i.loli.net/2019/09/13/aOwBtyY5fh9mEMg.jpg"></a></p><p>深度太大的决策树容易受过拟合的影响。但是随机森林通过在随机子集上构建决策树防止过拟合，主要原因是它会对所有树的结果进行投票的结果是所有树的分类结果的投票，从而消除了单棵树的偏差。</p><p>随机森林在决策树生增长的同时为模型增加了额外的随机性。它在分割节点时，不是搜索全部样本最重要的特征，而是在随机特征子集中搜索最佳特征。这种方式使得决策树具有多样性，从而能够得到更好的模型。</p><h2 id="梯度提升分类器"><a href="#梯度提升分类器" class="headerlink" title="梯度提升分类器"></a>梯度提升分类器</h2><p>梯度提升分类器是一种提升集成算法。提升(boosting)算法是为了减少偏差而对弱分类器的而进行的一种集成方法。与装袋（bagging）方法构建预测结果池不同，提升算法是一种分类器的串行方法，它把每个输出作为下一个分类器的输入。通常，在装袋算法中，每棵树在原始数据集的子集上并行训练，并用所有树预测结果的均值作为模型最终的预测结果；梯度提升模型，采用串行方式而非并行模式获得预测结果。每棵决策树预测前一棵决策树的误差，因而使误差获得提升。</p><p><a href="https://sm.ms/image/tEHDn3slOJewTBM" target="_blank"><img src="https://i.loli.net/2019/09/13/tEHDn3slOJewTBM.jpg"></a></p><ul><li><p>使用浅层决策树初始化预测结果。</p></li><li><p>计算残差值（实际预测值）。</p></li><li><p>构建另一棵浅层决策树，将上一棵树的残差作为输入进行预测。</p></li><li><p>用新预测值和学习率的乘积作为最新预测结果，更新原有预测结果。</p></li><li><p>重复步骤2-4，进行一定次数的迭代（迭代的次数即为构建的决策树的个数）。</p></li></ul><p><a href="https://sm.ms/image/qG8XnbMNEH9gLJZ" target="_blank"><img src="https://i.loli.net/2019/09/13/qG8XnbMNEH9gLJZ.jpg"></a></p><p>如果想了解更多关于梯度提升分类器的知识，可参考：<br><a href="https://medium.com/mlreview/gradient-boosting-from-scratch-1e317ae4587d%20/t%20_blank" target="_blank" rel="noopener">https://medium.com/mlreview/gradient-boosting-from-scratch-1e317ae4587d%20/t%20_blank</a></p><h1 id="分类器的性能"><a href="#分类器的性能" class="headerlink" title="分类器的性能"></a>分类器的性能</h1><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>混淆矩阵是一张表，这张表通过对比已知分类结果的测试数据的预测值和真实值表来描述衡量分类器的性能。在二分类的情况下，混淆矩阵是展示预测值和真实值四种不同结果组合的表。</p><p><a href="https://sm.ms/image/ym8d16RupiQEPC7" target="_blank"><img src="https://i.loli.net/2019/09/13/ym8d16RupiQEPC7.jpg"></a></p><p>多分类问题的混淆矩阵可以帮助你确认错误模式。</p><p>对于二元分类器：</p><p><a href="https://sm.ms/image/RdBiusjJKlto6Ef" target="_blank"><img src="https://i.loli.net/2019/09/13/RdBiusjJKlto6Ef.jpg"></a></p><h2 id="假正例-amp-假负例"><a href="#假正例-amp-假负例" class="headerlink" title="假正例&amp;假负例"></a>假正例&amp;假负例</h2><p>假正例和假负例用来衡量模型预测的分类效果。假正例是指模型错误地将负例预测为正例。假负例是指模型错误地将正例预测为负例。主对角线的值越大（主对角线为真正例和真负例），模型就越好；副对角线给出模型的最差预测结果。</p><h3 id="假正例"><a href="#假正例" class="headerlink" title="假正例"></a>假正例</h3><p>下面给出一个假正例的例子。比如：模型将一封邮件分类为垃圾邮件（正例），但这封邮件实际并不是垃圾邮件。这就像一个警示，错误如果能被修正就更好，但是与假负例相比，它并不是一个严重的问题。</p><p>作者注：个人观点，这个例子举的不太好，对垃圾邮件来说，相比于错误地将垃圾邮件分类为正常邮件（假负例），将正常邮件错误地分类为垃圾邮件（假正例）是更严重的问题。</p><p><strong>假正例（I型错误）</strong>——原假设正确而拒绝原假设。</p><p><a href="https://sm.ms/image/qDQwrXGZvluAy8H" target="_blank"><img src="https://i.loli.net/2019/09/13/qDQwrXGZvluAy8H.jpg"></a></p><h3 id="假负例"><a href="#假负例" class="headerlink" title="假负例"></a>假负例</h3><p>假负例的一个例子。例如，该模型预测一封邮件不是垃圾邮件（负例），但实际上这封邮件是垃圾邮件。这就像一个危险的信号，错误应该被及早纠正，因为它比假正例更严重。</p><p><strong>假负例（II型错误）</strong>——原假设错误而接受原假设。</p><p><a href="https://sm.ms/image/kXrLH8BYd4MmjyO" target="_blank"><img src="https://i.loli.net/2019/09/13/kXrLH8BYd4MmjyO.jpg"></a></p><p>上图能够很容易地说明上述指标。左图男士的测试结果是假正例因为男性不能怀孕；右图女士是假负例因为很明显她怀孕了。</p><p>从混淆矩阵，我们能计算出准确率、精度、召回率和F-1值。</p><h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>准确率是模型预测正确的部分。</p><p><a href="https://sm.ms/image/SAI9hiXOxDgdECL" target="_blank"><img src="https://i.loli.net/2019/09/13/SAI9hiXOxDgdECL.jpg"></a></p><p>准确率的公式为：</p><p><a href="https://sm.ms/image/4kvMm2a8619yAhN" target="_blank"><img src="https://i.loli.net/2019/09/13/4kvMm2a8619yAhN.jpg"></a></p><p>当数据集不平衡，也就是正样本和负样本的数量存在显著差异时，单独依靠准确率不能评价模型的性能。精度和召回率是衡量不平衡数据集的更好的指标。</p><h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>精度是指在所有预测为正例的分类中，预测正确的程度为正例的效果。</p><p><a href="https://sm.ms/image/CAPjQGaoKhsgWT5" target="_blank"><img src="https://i.loli.net/2019/09/13/CAPjQGaoKhsgWT5.jpg"></a></p><p>精度越高越好。</p><h2 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h2><p>召回率是指在所有预测为正例（被正确预测为真的和没被正确预测但为真的）的分类样本中，召回率是指预测正确的程度。它，也被称为敏感度或真正率（TPR）。</p><p><a href="https://sm.ms/image/nyrg3OEvlFjeN5p" target="_blank"><img src="https://i.loli.net/2019/09/13/nyrg3OEvlFjeN5p.jpg"></a></p><p>召回率越高越好。</p><h2 id="F-1值"><a href="#F-1值" class="headerlink" title="F-1值"></a>F-1值</h2><p>通常实用的做法是将精度和召回率合成一个指标F-1值更好用，特别是当你需要一种简单的方法来衡量两个分类器性能时。F-1值是精度和召回率的调和平均值。</p><p><a href="https://sm.ms/image/sUOuF9yPM25THRk" target="_blank"><img src="https://i.loli.net/2019/09/13/sUOuF9yPM25THRk.jpg"></a></p><p>普通的通常均值将所有的值平等对待，而调和平均值给予较低的值更高的权重，从而能够更多地惩罚极端值。所以，如果精度和召回率都很高，则分类器将得到很高的F-1值。</p><h2 id="接受者操作曲线（ROC）和曲线下的面积（AUC）"><a href="#接受者操作曲线（ROC）和曲线下的面积（AUC）" class="headerlink" title="接受者操作曲线（ROC）和曲线下的面积（AUC）"></a>接受者操作曲线（ROC）和曲线下的面积（AUC）</h2><p>ROC曲线是衡量分类器性能的一个很重要指标，它代表模型准确预测的程度。ROC曲线通过绘制真正率和假正率的关系来衡量分类器的敏感度。如果分类器性能优越，则真正率将增加，曲线下的面积会接近于1.如果分类器类似于随机猜测，真正率将随假正率线性增加。AUC值越大，模型效果越好。</p><p><a href="https://sm.ms/image/ws8rUCdbfl92ZQv" target="_blank"><img src="https://i.loli.net/2019/09/13/ws8rUCdbfl92ZQv.jpg"></a></p><h2 id="累积精度曲线"><a href="#累积精度曲线" class="headerlink" title="累积精度曲线"></a>累积精度曲线</h2><p>CAP代表一个模型沿y轴为真正率的累积百分比与沿x轴的该分类样本累积百分比。CAP不同于接受者操作曲线（ROC，绘制的是真正率与假正率的关系）。与ROC曲线相比，CAP曲线很少使用。</p><p><a href="https://sm.ms/image/5C7Vdg2txwN6QWA" target="_blank"><img src="https://i.loli.net/2019/09/13/5C7Vdg2txwN6QWA.jpg"></a></p><p>以考虑一个预测客户是否会购买产品的模型为例，如果随机选择客户，他有50%的概率会购买产品。客户购买产品的累积数量会线性地增长到对应客户总量的最大值，这个曲线称为CAP随机曲线，为上图中的蓝色线。而一个完美的预测，准确地确定预测了哪些客户会购买产品，这样，在所有样本中只需选择最少的客户就能达到最大购买量。这在CAP曲线上产生了一条开始陡峭一旦达到最大值就会维持在1的折线，称为CAP的完美曲线，也被称为理想曲线，为上图中灰色的线。</p><p>最后，一个真实的模型应该能尽可能最大化地正确预测，接近于理想模型曲线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起分类算法，相信学过机器学习的同学都能侃上一二。&lt;/p&gt;
&lt;p&gt;可是，你能够如数家珍地说出所有常用的分类算法，以及他们的特征、优缺点吗？比如说，你可以快速地回答下面的问题么:&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用cython加速代码运行</title>
    <link href="http://yoursite.com/2019/09/10/%E4%BD%BF%E7%94%A8cython%E5%8A%A0%E9%80%9F%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C/"/>
    <id>http://yoursite.com/2019/09/10/使用cython加速代码运行/</id>
    <published>2019-09-10T09:09:22.000Z</published>
    <updated>2019-09-29T11:11:43.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>毫无疑问，Python是社区最喜爱的编程语言!到目前为止，它是最容易使用的语言之一，因为python代码是用一种直观的、人类可读的方式编写的。</p><p>然而，你经常会反复听到一些对Python的抱怨，尤其是来自C语言爱好者的抱怨，这些抱怨无非就是Python很慢。</p><a id="more"></a><p>是的，他们并没有说错。</p><p>与许多其他编程语言相比，Python确实很慢。Benchmark game有一些比较不同编程语言在不同任务上的速度的可靠基准。</p><blockquote><p><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/gpp-python3.html?source=post_page" target="_blank" rel="noopener">https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/gpp-python3.html?source=post_page</a></p></blockquote><p>对于Python，我们有几种不同的方法可以加快速度:</p><blockquote><p>1.使用多进程库来使用所有的CPU核心<br><a href="https://towardsdatascience.com/heres-how-you-can-get-a-2-6x-speed-up-on-your-data-pre-processing-with-python-847887e63be5" target="_blank" rel="noopener">https://towardsdatascience.com/heres-how-you-can-get-a-2-6x-speed-up-on-your-data-pre-processing-with-python-847887e63be5</a><br>2.如果你使用Numpy、panda或Scikit-Learn，使用Rapids来加速GPU上的处理。<br><a href="https://towardsdatascience.com/heres-how-you-can-accelerate-your-data-science-on-gpu-4ecf99db3430" target="_blank" rel="noopener">https://towardsdatascience.com/heres-how-you-can-accelerate-your-data-science-on-gpu-4ecf99db3430</a></p></blockquote><p>如果你所做的实际上可以并行化，比如数据预处理或矩阵运算，这些都是很好的方法。</p><p>但是如果你的代码是纯Python的呢?如果你不得不使用一个很大的for循环，且不能将数据放入矩阵中，因为数据必须按顺序处理，那会怎样?有没有办法加快Python本身的速度呢?</p><p>答案是肯定的，<strong>这就是Cython来加速原生Python代码的地方</strong>。</p><h1 id="什么是Cython？"><a href="#什么是Cython？" class="headerlink" title="什么是Cython？"></a>什么是Cython？</h1><p>Cython是Python和C/C++之间的一个中间步骤。它允许你编写纯Python代码，并且只需要做一些小修改，然后将其直接翻译成C代码。</p><p>你对Python代码所做的惟一调整就是向每个变量添加类型信息。通常，我们可以像这样在Python中声明一个变量:</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><p>使用Cython，我们将向该变量添加一个类型:</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef int x = <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><p>这告诉Cython，我们的变量是浮点类型，就像我们在C中所做的一样。对于纯Python，变量的类型是动态确定的。Cython中类型的显式声明使转换为C成为可能，因为显式类型声明是必须的。</p><p>安装Cython只需要一行简单的pip命令:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cython</span><br></pre></td></tr></table></figure><h1 id="Cython中的类型"><a href="#Cython中的类型" class="headerlink" title="Cython中的类型"></a>Cython中的类型</h1><p>使用Cython时，变量和函数分别有不同的类型。</p><p>对于变量我们有以下类型:</p><ul><li><p>cdef int a, b, c</p></li><li><p>cdef char *s</p></li><li><p>cdef float x = 0.5 (单精度)</p></li><li><p>cdef double x = 63.4 (双精度)</p></li><li><p>cdef list names</p></li><li><p>cdef dict goals_for_each_play</p></li><li><p>cdef object card_deck</p></li></ul><p>注意所有这些类型都来自C/C++ ! 而对于方法我们有以下类型:</p><ul><li>def — 常规python函数，仅从python调用。</li><li>cdef — 不能从python的代码中访问Cython的函数。即必须在Cython内调用</li><li>cpdef — C 和 Python. 可以从C和Python中访问</li></ul><p>了解了Cython类型之后，我们就可以直接实现加速了!</p><h1 id="如何使用Cython加速python代码"><a href="#如何使用Cython加速python代码" class="headerlink" title="如何使用Cython加速python代码"></a>如何使用Cython加速python代码</h1><p>我们要做的第一件事是设置Python代码基准:用于计算数值阶乘的for循环。原生Python代码如下:</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    y = <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(x+<span class="hljs-number">1</span>):</span><br><span class="line">        y *= i</span><br><span class="line">    <span class="hljs-keyword">return</span> y</span><br></pre></td></tr></table></figure><p>相同功能的Cython方法看起来非常相似。首先，我们将确保Cython代码文件具有<strong>.pyx</strong>扩展名。对代码本身的惟一更改是，我们已经声明了每个变量和函数的类型。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpdef int test(int x):</span><br><span class="line">    cdef int y = <span class="hljs-number">1</span></span><br><span class="line">    cdef int i</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(x+<span class="hljs-number">1</span>):</span><br><span class="line">        y *= i</span><br><span class="line">    <span class="hljs-keyword">return</span> y</span><br></pre></td></tr></table></figure><p>Boom ! 可以看到我们的C代码已经编译好了，可以使用了!</p><p>你将看到，在Cython代码所在的文件夹中，你拥有运行C代码所需的所有文件，包括<strong>run_cython.c</strong>文件。如果你感兴趣，可以查看一下Cython生成的C代码!</p><p>现在我们准备测试我们新的并且超级快的C代码!查看下面的代码，它实现了一个速度测试，将原生Python代码与Cython代码进行比较。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> run_python</span><br><span class="line"><span class="hljs-keyword">import</span> run_cython</span><br><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"></span><br><span class="line">number = <span class="hljs-number">10</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">run_python.test(number)</span><br><span class="line">end =  time.time()</span><br><span class="line"></span><br><span class="line">py_time = end - start</span><br><span class="line">print(<span class="hljs-string">"Python time = &#123;&#125;"</span>.format(py_time))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">run_cython.test(number)</span><br><span class="line">end =  time.time()</span><br><span class="line"></span><br><span class="line">cy_time = end - start</span><br><span class="line">print(<span class="hljs-string">"Cython time = &#123;&#125;"</span>.format(cy_time))</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"Speedup = &#123;&#125;"</span>.format(py_time / cy_time))</span><br></pre></td></tr></table></figure><p>代码非常直观，我们以与普通Python相同的方式导入文件，并以与普通Python相同的方式运行函数!</p><p>Cython几乎可以让你在所有原生Python代码上获得良好的加速，而不需要太多额外的工作。需要注意的关键是，循环次数越多，处理的数据越多，Cython可以提供的帮助就越多。</p><p>下表显示了Cython为不同的数值阶乘带来的加速性能。当数值为10000000的时候，可以看到，我们的Cython加速超过了<strong>36</strong>倍。</p><p><a href="https://sm.ms/image/S5Htu6AUNiP7zOw" target="_blank"><img src="https://i.loli.net/2019/09/10/S5Htu6AUNiP7zOw.png"></a></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>目前我的运行存在有</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DistutilsPlatformError: Unable to find vcvarsall.bat</span><br></pre></td></tr></table></figure><p>错误,正在想办法解决,希望可以能尽快进入到一个c与python共存的世界</p><p><strong>注意:</strong>该问题我已经解决，现在给出方法:</p><ol><li><p>安装vsstudio2019，教程在:<a href="https://b23.tv/av52977238" target="_blank" rel="noopener">cython加速你的代码运行</a></p></li><li><p>参考文章:<a href="https://blog.csdn.net/rookie_is_me/article/details/88421373" target="_blank" rel="noopener">cython加速python使用</a></p></li><li><p>我运行的代码源文件:<a href="https://www.lanzous.com/i64faxi" target="_blank" rel="noopener">下载</a></p></li><li><p><a href="https://www.jianshu.com/p/cfcc2c04a6f5" target="_blank" rel="noopener">使用笔记</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;毫无疑问，Python是社区最喜爱的编程语言!到目前为止，它是最容易使用的语言之一，因为python代码是用一种直观的、人类可读的方式编写的。&lt;/p&gt;
&lt;p&gt;然而，你经常会反复听到一些对Python的抱怨，尤其是来自C语言爱好者的抱怨，这些抱怨无非就是Python很慢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Cython" scheme="http://yoursite.com/tags/Cython/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习入门》阅读笔记</title>
    <link href="http://yoursite.com/2019/09/07/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/07/《深度学习入门》阅读笔记/</id>
    <published>2019-09-07T02:20:41.000Z</published>
    <updated>2019-09-28T01:37:34.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-Python入门"><a href="#第1章-Python入门" class="headerlink" title="第1章 Python入门"></a>第1章 Python入门</h1><h2 id="1-5-4-Numpy的N维数组"><a href="#1-5-4-Numpy的N维数组" class="headerlink" title="1.5.4  Numpy的N维数组"></a>1.5.4  Numpy的N维数组</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])</span><br><span class="line">b = np.array([[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]])</span><br><span class="line">print(a+b)</span><br><span class="line">print(a*b)</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>注意</strong>:数学上，一维数组称为向量；二维数组称为矩阵；可以将一般化后的向量或矩阵等统称为张量。</p><h2 id="1-5-5-广播"><a href="#1-5-5-广播" class="headerlink" title="1.5.5 广播"></a>1.5.5 广播</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])</span><br><span class="line">b = np.array([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>])</span><br><span class="line">print(a*b)</span><br></pre></td></tr></table></figure><h2 id="1-6-3-显示图像"><a href="#1-6-3-显示图像" class="headerlink" title="1.6.3 显示图像"></a>1.6.3 显示图像</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">from</span> matplotlib.image <span class="hljs-keyword">import</span> imread</span><br><span class="line">img = imread(<span class="hljs-string">'图片名称'</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="第2章-感知机"><a href="#第2章-感知机" class="headerlink" title="第2章 感知机"></a>第2章 感知机</h1><p>感知机是神经网络(深度学习)的起源算法。</p><h2 id="2-3-3-使用权重和偏置的实现"><a href="#2-3-3-使用权重和偏置的实现" class="headerlink" title="2.3.3 使用权重和偏置的实现"></a>2.3.3 使用权重和偏置的实现</h2><p>权重值是控制输入信号的重要参数；偏置值调整了神经元被激活的容易程度。</p><h2 id="2-4-2-线性和非线性"><a href="#2-4-2-线性和非线性" class="headerlink" title="2.4.2 线性和非线性"></a>2.4.2 线性和非线性</h2><p>单层感知机的局限性在于它只能表示由一条直线分割的区间。</p><h2 id="2-5-2-异或门的实现"><a href="#2-5-2-异或门的实现" class="headerlink" title="2.5.2 异或门的实现"></a>2.5.2 异或门的实现</h2><p>叠加了多层的感知机称为多层感知机。</p><p>感知机的层数叫法问题。</p><h2 id="2-6-从与非门到计算机"><a href="#2-6-从与非门到计算机" class="headerlink" title="2.6 从与非门到计算机"></a>2.6 从与非门到计算机</h2><p>实际上，使用感知机甚至可以表示计算机！</p><h1 id="第3章-神经网络"><a href="#第3章-神经网络" class="headerlink" title="第3章 神经网络"></a>第3章 神经网络</h1><p>当拥有感知机的同时我们也知道了两个消息：</p><ol><li><p>好消息：对于复杂的函数，感知机也能通过叠加层数来有可能性的实现。</p></li><li><p>坏消息是：<strong>设定权重的工作在感知机中仍只能是由人工进行的</strong>。</p></li></ol><p>而神经网络的出现就是为了解决来自感知机的坏消息。</p><h3 id="3-1-3-激活函数登场"><a href="#3-1-3-激活函数登场" class="headerlink" title="3.1.3 激活函数登场"></a>3.1.3 激活函数登场</h3><p>激活函数的作用在于决定如何来激活输入信号的总和。</p><p><img src="https://i.loli.net/2019/09/07/UgvDeCzXq1MoBdV.png" alt="微信截图_20190907111807.png"></p><h3 id="3-2-激活函数"><a href="#3-2-激活函数" class="headerlink" title="3.2 激活函数"></a>3.2 激活函数</h3><p>阶跃函数：函数以阈值为界，一旦输入超过阈值，就切换输出。</p><p>实际上，<strong>如果将激活函数从阶跃函数换成其他函数，我们就可以进入到神经网络的世界了</strong>。</p><h3 id="3-2-5-sigmiod函数和阶跃函数的比较"><a href="#3-2-5-sigmiod函数和阶跃函数的比较" class="headerlink" title="3.2.5 sigmiod函数和阶跃函数的比较"></a>3.2.5 sigmiod函数和阶跃函数的比较</h3><p>sigmoid函数是一条平滑的曲线，输出随着输入发生连续性变化；而阶跃函数以0为界，输出发生急剧性的变化。<br>sigmoid函数的平滑性对神经网络的学习具有重要的意义。</p><p>也就是说，相对于感知机中的神经元只能返回0或1的信号，神经网络中返回的是连续的实数值信号。</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li><p>两者的图像结构均表示为：“输入小时，输出接近0（为0）；输入大时，随着输入的增大，输出靠近1（为1）”。</p></li><li><p>不管输入的大小为多少，输出信号的值始终在0到1之间。</p></li><li><p>均为非线性函数。</p></li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li><p>阶跃函数：“竹筒敲石”。</p></li><li><p>sigmoid函数：“水车”。</p></li></ul><h3 id="3-2-6-非线性函数"><a href="#3-2-6-非线性函数" class="headerlink" title="3.2.6 非线性函数"></a>3.2.6 非线性函数</h3><p>输出值为输入值的常数倍的函数称为线性函数。</p><p>为了发挥叠加层的优势，神经网络必须使用非线性函数。</p><h3 id="3-5-输出层的设计"><a href="#3-5-输出层的设计" class="headerlink" title="3.5 输出层的设计"></a>3.5 输出层的设计</h3><p>神经网络可以使用在分类和回归问题上，不过需要根据情况改变<strong>输出层的激活函数</strong> ，一般而言，回归问题用恒等函数，分类问题用softmax函数。</p><p>softmax函数python实现：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">softmax</span><span class="hljs-params">(a)</span>:</span></span><br><span class="line">exp_a = np.exp(a)</span><br><span class="line">sum_exp_a = np.sum(exp_a)</span><br><span class="line">y = exp_a / sum_exp_a</span><br><span class="line"><span class="hljs-keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="3-5-2-使用softmax函数时的注意事项"><a href="#3-5-2-使用softmax函数时的注意事项" class="headerlink" title="3.5.2 使用softmax函数时的注意事项"></a>3.5.2 使用softmax函数时的注意事项</h3><p>softmax函数的分子进行了指数的运算，可能会产生一些超大值，如果这些超大值进行除法运算，会出现”不确定”的情况，这就是产生了溢出问题。</p><p>改进的softmax函数python实现：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">softmax</span><span class="hljs-params">(a)</span>:</span></span><br><span class="line">c = np.max(a)</span><br><span class="line">exp_a = np.exp(a - c)</span><br><span class="line">sum_exp_a = np.sum(exp_a)</span><br><span class="line">y = exp_a / sum_exp_a</span><br><span class="line"><span class="hljs-keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="3-5-4-输出层的神经元数量"><a href="#3-5-4-输出层的神经元数量" class="headerlink" title="3.5.4 输出层的神经元数量"></a>3.5.4 输出层的神经元数量</h3><p>输出层的神经元数量需要根据需要解决的问题来决定。对于分类问题，输出层的神经元的数量一般设为类别的数量。</p><h2 id="第4章-神经网络的学习"><a href="#第4章-神经网络的学习" class="headerlink" title="第4章 神经网络的学习"></a>第4章 神经网络的学习</h2><p>“学习”是指从训练数据中自动获取<strong>最优权重参数</strong>的过程。</p><h3 id="4-1-1-数据驱动"><a href="#4-1-1-数据驱动" class="headerlink" title="4.1.1 数据驱动"></a>4.1.1 数据驱动</h3><p>对于一个数字“5”的识别，我们可以采用一些方法来识别：</p><ul><li><p>人暴力想出一个算法识别，得出答案。-人参与</p></li><li><p>人想到特征量（如一个横，一个类似s构成了5），然后采用机器学习（SVM，KNN）得出答案。-人参与</p></li><li><p>神经网络（深度学习）利用数据学习，机器自己识别判断。-完全机器</p></li></ul><p>深度学习也被称为端到端的机器学习。</p><p>神经网络的优点是对所有问题都可以采用同样的流程来解决，不管解决的是识别数字还是人脸，神经网络都是通过不断的学习所提供的数据，尝试发现待解决的问题。</p><h3 id="4-1-2-训练数据和测试数据"><a href="#4-1-2-训练数据和测试数据" class="headerlink" title="4.1.2 训练数据和测试数据"></a>4.1.2 训练数据和测试数据</h3><ul><li><p>训练数据：也称<strong>监督数据</strong>，用来训练新的模型的数据。</p></li><li><p>测试数据：为了检验模型的泛化能力。</p></li></ul><p>泛化能力指处理未被观察过的数据（不包含在训练数据中的数据）的能力。</p><p>获得泛化能力是机器学习的最终目标。</p><h3 id="4-4-1-梯度法"><a href="#4-4-1-梯度法" class="headerlink" title="4.4.1 梯度法"></a>4.4.1 梯度法</h3><p>根据寻找最小值还是最大值，寻找最小值的梯度法称为梯度下降法，寻找最大值的梯度法称为梯度上升法。但是通过反转损失函数的符号，求最大和最小值会变成相同的问题，所以一般来说，神经网络（深度学习）中，梯度法指的是梯度下降法。</p><h2 id="第5章-误差反向传播法"><a href="#第5章-误差反向传播法" class="headerlink" title="第5章 误差反向传播法"></a>第5章 误差反向传播法</h2><h3 id="5-4-简单层的实现"><a href="#5-4-简单层的实现" class="headerlink" title="5.4 简单层的实现"></a>5.4 简单层的实现</h3><p>Affine层是负责矩阵乘积的。</p><h2 id="第6章-与学习相关的技巧"><a href="#第6章-与学习相关的技巧" class="headerlink" title="第6章 与学习相关的技巧"></a>第6章 与学习相关的技巧</h2><h3 id="6-1-3-SGD的缺点"><a href="#6-1-3-SGD的缺点" class="headerlink" title="6.1.3 SGD的缺点"></a>6.1.3 SGD的缺点</h3><p>为了改正SGD的缺点，我们可以使用优化算法Momentum，AdaGrad，Adam等。</p><h2 id="第7章-卷积神经网络"><a href="#第7章-卷积神经网络" class="headerlink" title="第7章 卷积神经网络"></a>第7章 卷积神经网络</h2><h2 id="第8章-深度学习"><a href="#第8章-深度学习" class="headerlink" title="第8章 深度学习"></a>第8章 深度学习</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章-Python入门&quot;&gt;&lt;a href=&quot;#第1章-Python入门&quot; class=&quot;headerlink&quot; title=&quot;第1章 Python入门&quot;&gt;&lt;/a&gt;第1章 Python入门&lt;/h1&gt;&lt;h2 id=&quot;1-5-4-Numpy的N维数组&quot;&gt;&lt;a href=&quot;#1-5-4-Numpy的N维数组&quot; class=&quot;headerlink&quot; title=&quot;1.5.4  Numpy的N维数组&quot;&gt;&lt;/a&gt;1.5.4  Numpy的N维数组&lt;/h2&gt;&lt;figure class=&quot;highlight python hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = np.array([[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;],[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = np.array([[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;],[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a+b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a*b)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习VS深度学习的区别</title>
    <link href="http://yoursite.com/2019/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0VS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/05/机器学习VS深度学习的区别/</id>
    <published>2019-09-05T10:25:57.000Z</published>
    <updated>2019-09-17T03:22:22.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文我们主要涉及到:</p><ol><li>数据相关性</li><li>硬件依赖性</li><li>特征工程</li><li>解决问题方法</li><li>执行时间</li><li>可解释性</li></ol></blockquote><a id="more"></a><h2 id="1-数据的相关性"><a href="#1-数据的相关性" class="headerlink" title="1.数据的相关性"></a>1.数据的相关性</h2><p>深度学习与传统机器学习最重要的区别是，随着数据量的增加，其性能也随之提高。当数据很小的时候，深度学习算法并不能很好地执行，这是因为深度学习算法需要大量的数据才能完全理解它。下图便能很好的说明这个事实：<br><img src="https://i.loli.net/2019/09/05/im2Guo3AgBKPe48.jpg" alt="微信图片_20190905183052.jpg"><br>从上图我们可以看到，随着数据量的增大，深度学习的性能会越来越好，而传统机器学习方法性能表现却趋于平缓；但传统的机器学习算法在数据量较小的情况下，比深度学习有着更好的表现。</p><h2 id="2-硬件的依赖性"><a href="#2-硬件的依赖性" class="headerlink" title="2.硬件的依赖性"></a>2.硬件的依赖性</h2><p>深度学习算法在很大程度上依赖于高端机器，而传统的机器学习算法可以在低端机器上工作。这是因为深度学习算法对GPU有较高的要求，GPU是其工作的一个组成部分。因为深度学习算法要固有地执行大量的矩阵乘法运算，而使用GPU可以有效地优化这些操作，这就免不了对GPU的依赖。而相比之下，机器学习算法对硬件配置没有很高的要求。</p><h2 id="3-特征工程"><a href="#3-特征工程" class="headerlink" title="3.特征工程"></a>3.特征工程</h2><p>特征工程是将领域知识应用到特征抽取的创建过程，以降低数据的复杂性为目的。但这一过程在训练时间和如何提取特征方面十分地困难。</p><p>在机器学习中，大多数应用的特征需要由专家识别，然后根据域和数据类型手工编码。</p><p>例如，特征可以是像素值、形状、纹理、位置和方向，大多数机器学习算法的性能取决于特征识别和提取的准确程度。</p><p>而深度学习算法则试图从数据中学习更高级的特性。这是深度学习一个非常独特的部分，也是有别于传统机器学习的一部分。因此，深度学习减少了为每个问题开发新的特征抽取的任务，而是像卷积神经网络（CNN）这样尝试学习低层次的特征，如：早期层次的边缘和线条，然后是人脸的一部分，最后才是人脸的高层次表示。这样的方式相较于机器学习，在训练时间和成本上有较高的提升。<br><img src="https://i.loli.net/2019/09/05/NQHcKtC39vSuEW1.jpg" alt="微信图片_20190905183242.jpg"></p><h2 id="4-解决问题方法"><a href="#4-解决问题方法" class="headerlink" title="4.解决问题方法"></a>4.解决问题方法</h2><p>在使用传统的机器学习算法解决问题时，通常的做法是将问题分解成不同的部分，然后单独解决，最后结合起来得到结果。相比之下，深度学习更提倡端到端地解决问题。让我们举个例子来理解这一点。<br><img src="https://i.loli.net/2019/09/05/2unZ7tYbkBUJSf4.jpg" alt="微信图片_20190905183339.jpg"><br>如图所示是一个多对象检测任务，我们的目标是哟啊确定对象是什么以及它在图像中的位置。</p><p>在典型的机器学习方法中，我们会将问题分为两个步骤：对象检测和对象识别。首先，我们将使用一个边界检测算法，如：GrabCut，来浏览图像并找到图像中所有可能的对象；然后，在所有已识别的对象中，我们再使用对象识别算法（如：SVM）来识别相关对象，最后再判断对象的位置。</p><p>不同于传统机器学习算法，在深度学习的方法中，我们将进行端到端的学习过程。例如，使用YOLO算法（一种深度学习算法）。我们往YOLO网络中传入一张图像，它将给出对象的具体位置和名称。是不是方便了很多呢？</p><h2 id="5-执行时间"><a href="#5-执行时间" class="headerlink" title="5.执行时间"></a>5.执行时间</h2><p>通常，深度学习算法需要很长的时间来训练，这是因为在深度学习算法中有太多的参数，所以训练这些参数的时间比平时要长。即使比较先进的深度学习算法Resnet，从零开始完全训练也需要大约两周的时间。相比之下，机器学习所需的训练时间要少得多，从几秒钟到几个小时不等。</p><p>相较于训练时间，测试时间就要短很多。在测试时，深度学习算法的运行时间要短得多。但是，如果将其与k近邻机器学习算法进行比较，测试时间会随着数据大小的增加而增加。但这并不适用于所有机器学习算法，因为其中一些算法的测试时间也很短。</p><h2 id="6-可解释性"><a href="#6-可解释性" class="headerlink" title="6.可解释性"></a>6.可解释性</h2><p>最后，我们将可解释性作为比较机器学习和深度学习的一个因素。这一因素也是深度学习难以在工业中取得大规模应用的主要原因。</p><p>我们举个例子：假设我们使用深度学习为论文自动评分，它在得分方面的表现相当出色，接近于人类的表现。但有一个问题：深度学习并没有揭示它为什么会给出那个分数。事实上，从数学中我们可以发现深度神经网络的哪些节点被激活，但是我们不知道神经元应该做什模型以及这些神经元层共同在做什么，所以我们无法对结果进解释。</p><p>而相较于深度学习，类似于决策树这样的机器学习算法为我们提供了清晰的规则，告诉我们什么是它的选择以及为什么选择了它，很容易解释算法背后的推理。因此，决策树和线性/逻辑回归等机器学习算法主要用于工业中需要可解释性的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文我们主要涉及到:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据相关性&lt;/li&gt;
&lt;li&gt;硬件依赖性&lt;/li&gt;
&lt;li&gt;特征工程&lt;/li&gt;
&lt;li&gt;解决问题方法&lt;/li&gt;
&lt;li&gt;执行时间&lt;/li&gt;
&lt;li&gt;可解释性&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Git操作</title>
    <link href="http://yoursite.com/2019/09/04/Git%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/09/04/Git操作/</id>
    <published>2019-09-04T12:41:56.000Z</published>
    <updated>2019-09-17T03:29:43.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Git简介"><a href="#一-Git简介" class="headerlink" title="一.Git简介"></a>一.Git简介</h2><p>Git 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具。</p><a id="more"></a><p>Git 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从实用主和深入探索(后期更新)2个方面去谈谈如何在项目中使用 Git，一般来说，看完实用主义这一节就可以开始在项目中动手用。</p><blockquote><p>说明：本文的操作都是基于Windows系统</p></blockquote><h2 id="二-实用主义"><a href="#二-实用主义" class="headerlink" title="二.实用主义"></a>二.实用主义</h2><h3 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1.准备阶段"></a>1.准备阶段</h3><blockquote><p>工具准备</p></blockquote><p>进入 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>下载合适你的安装包。</p><blockquote><p>账号准备</p></blockquote><p>进入Github网站 注册一个账号就可以使用了。</p><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h3><p>所谓实用主义，就是掌握了以下知识就可以玩转 Git，轻松应对90%以上的需求。以下是实用主义型的Git命令列表，先大致看一下:</p><ul><li><p>git clone</p></li><li><p>git config</p></li><li><p>git branch</p></li><li><p>git checkout</p></li><li><p>git status</p></li><li><p>git add</p></li><li><p>git commit</p></li><li><p>git push</p></li><li><p>git pull</p></li><li><p>git log</p></li><li><p>git tag</p></li></ul><h4 id="1-git-clone"><a href="#1-git-clone" class="headerlink" title="(1)git clone"></a>(1)git clone</h4><blockquote><p>从git服务器拉取代码</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/user/repo.git</span><br></pre></td></tr></table></figure><h4 id="2-git-config"><a href="#2-git-config" class="headerlink" title="(2)git config"></a>(2)git config</h4><blockquote><p>配置开发者用户名和邮箱</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name user</span><br><span class="line">git config user.email user@qq.com</span><br></pre></td></tr></table></figure><h4 id="3-git-branch"><a href="#3-git-branch" class="headerlink" title="(3)git branch"></a>(3)git branch</h4><blockquote><p>创建、重命名、查看、删除项目分支，通过Git做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch daily/0.0.0</span><br></pre></td></tr></table></figure><p>创建一个名为daily/0.0.0的日常开发分支，分支名只要不包括特殊字符即可。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m daily/0.0.0 daily/0.0.1</span><br></pre></td></tr></table></figure><p>如果觉得之前的分支名不合适，可以为新建的分支重命名，重命名分支名为daily/0.0.1。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>通过不带参数的branch命令可以查看当前项目分支列表。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d daily/0.0.1</span><br></pre></td></tr></table></figure><p>如果分支已经完成使命则可以通过-d参数将分支删除，这里为了继续下一步操作，暂不执行删除操作。</p><h4 id="4-git-checkout"><a href="#4-git-checkout" class="headerlink" title="(4)git checkout"></a>(4)git checkout</h4><blockquote><p>切换分支</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout daily/0.0.1</span><br></pre></td></tr></table></figure><h4 id="5-git-status"><a href="#5-git-status" class="headerlink" title="(5)git status"></a>(5)git status</h4><blockquote><p>查看文件变动状态<br>通过任何你喜欢的编辑器对项目中的 README.md 文件做一些改动，保存。</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>通过git status命令可以看到文件当前状态Changes not staged for commit:(改动文件未提交到暂存区）</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">On branch daily/0.0.1</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>..." to discard changes in working directory)</span><br><span class="line">    modified:   README.md</span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><h4 id="6-git-add"><a href="#6-git-add" class="headerlink" title="(6)git add"></a>(6)git add</h4><blockquote><p>添加文件变动到暂存区</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure><p>通过指定文件名README.md可以将该文件添加到暂存区，如果想添加所有文件可用git add. 命令，这时候可通过git status看到文件当前状态Changes to be committed:（文件已提交到暂存区）</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On branch daily/0.0.1</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>..." to unstage)</span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure><h4 id="7-git-commit"><a href="#7-git-commit" class="headerlink" title="(7)git commit"></a>(7)git commit</h4><blockquote><p>提交文件变动到版本库</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m '这里写提交原因'</span><br></pre></td></tr></table></figure><p>通过-m参数可直接在命令行里输入提交描述文本。</p><h4 id="8-git-push"><a href="#8-git-push" class="headerlink" title="(8)git push"></a>(8)git push</h4><blockquote><p>将本地的代码改动推送到服务器</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin daily/0.0.1</span><br></pre></td></tr></table></figure><p>origin 指代的是当前的git服务器地址，这行命令的意思是把 daily/0.0.1 分支推送到服务器，当看到命令行返回如下字符表示推送成功了。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local objects.</span><br><span class="line">To https://github.com/gafish/gafish.github.com.git</span><br><span class="line"> * [new branch]      daily/0.0.1 -&gt; daily/0.0.1</span><br></pre></td></tr></table></figure><p>现在我们回到Github网站的项目首页，点击Branch:master下拉按钮，就会看到刚才推送的daily/00.1分支了。</p><h4 id="9-git-pull"><a href="#9-git-pull" class="headerlink" title="(9)git pull"></a>(9)git pull</h4><blockquote><p>将服务器上的最新代码拉取到本地</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin daily/0.0.1</span><br></pre></td></tr></table></figure><p>如果其它项目成员对项目做了改动并推送到服务器，我们需要将最新的改动更新到本地，这里我们来模拟一下这种情况。</p><p>进入Github网站的项目首页，再进入daily/0.0.1分支，在线对README.md文件做一些修改并保存，然后在命令中执行以上命令，它将把刚才在线修改的部分拉取到本地，用编辑器打开README.md，你会发现文件已经跟线上的内容同步了。</p><p>如果线上代码做了变动，而你本地的代码也有变动，拉取的代码就有可能会跟你本地的改动冲突，一般情况下Git会自动处理这种冲突合并，但如果改动的是同一行，那就需要手动来合并代码，编辑文件，保存最新的改动，再通过git add .和git commit -m ‘xxx’来提交合并。</p><h4 id="10-git-log"><a href="#10-git-log" class="headerlink" title="(10)git log"></a>(10)git log</h4><blockquote><p>查看版本提交记录</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>通过以上命令，我们可以查看整个项目的版本提交记录，它里面包含了提交人、日期、提交原因等信息，得到的结果如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit c334730f8dba5096c54c8ac04fdc2b31ede7107a</span><br><span class="line">Author: gafish <span class="hljs-tag">&lt;<span class="hljs-name">gafish@qqqq.com</span>&gt;</span></span><br><span class="line">Date:   Wed Jan 11 09:44:13 2017 +0800</span><br><span class="line">    Update README.md</span><br><span class="line">commit ba6e3d21fcb1c87a718d2a73cdd11261eb672b2a</span><br><span class="line">Author: gafish <span class="hljs-tag">&lt;<span class="hljs-name">gafish@qqqq.com</span>&gt;</span></span><br><span class="line">Date:   Wed Jan 11 09:31:33 2017 +0800</span><br><span class="line">    test</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>提交记录可能会非常多，按J键往下翻，按K键往上翻，按Q键退出查看。</p><h4 id="11-git-tag"><a href="#11-git-tag" class="headerlink" title="(11)git tag"></a>(11)git tag</h4><blockquote><p>为项目标记里程碑</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag publish/0.0.1</span><br><span class="line">git push origin publish/0.0.1</span><br></pre></td></tr></table></figure><p>当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以publish/0.0.1为标记名并发布，当看到命令行返回如下内容则表示发布成功了。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/gafish/gafish.github.com.git</span><br><span class="line"> * [new tag]         publish/0.0.1 -&gt; publish/0.0.1</span><br></pre></td></tr></table></figure><h4 id="12-gitignore"><a href="#12-gitignore" class="headerlink" title="(12).gitignore"></a>(12).gitignore</h4><blockquote><p>设置哪些内容不需要推送到服务器，这是一个配置文件</p></blockquote><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>.gitignore 不是Git命令，而在项目中的一个文件，通过设置.gitignore的内容告诉Git哪些文件应该被忽略不需要推送到服务器，通过以上命令可以创建一个.gitignore文件，并在编辑器中打开文件，每一行代表一个要忽略的文件或目录，如：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.html</span><br><span class="line">build/</span><br></pre></td></tr></table></figure><p>以上内容的意思是Git将忽略demo.html文件 和build/目录，这些内容不会被推送到服务器上。</p><p>小结</p><p>通过掌握以上这些基本命令就可以在项目中开始用起来了，如果追求实用，那关于Git的学习就可以到此结束了，偶尔遇到的问题也基本上通过Google/百度也能找到答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-Git简介&quot;&gt;&lt;a href=&quot;#一-Git简介&quot; class=&quot;headerlink&quot; title=&quot;一.Git简介&quot;&gt;&lt;/a&gt;一.Git简介&lt;/h2&gt;&lt;p&gt;Git 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git常用操作" scheme="http://yoursite.com/tags/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
</feed>
