<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教书的先生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-30T04:41:14.662Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王荣胜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keras学习资源</title>
    <link href="http://yoursite.com/2019/09/30/Keras%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2019/09/30/Keras学习资源/</id>
    <published>2019-09-30T04:33:59.000Z</published>
    <updated>2019-09-30T04:41:14.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Keras简介"><a href="#Keras简介" class="headerlink" title="Keras简介"></a>Keras简介</h2><p>Keras是Python中以CNTK、Tensorflow或者Theano为计算后台的一个深度学习建模环境。</p><a id="more"></a><p>相对于其他深度学习的框架，如Tensorflow、Theano、Caffe等，Keras在实际应用中有一些显著的优点，其中最主要的优点就是Keras已经高度模块化了，支持现有的常见模型（CNN、RNN等），更重要的是建模过程相当方便快速，使用Keras可以快速地搭建深度网络，极大的加快了开发速度。此外，Keras具有用户友好性、模块化、易扩展、与Python协作友好的特点。</p><h2 id="Keras学习手册"><a href="#Keras学习手册" class="headerlink" title="Keras学习手册"></a>Keras学习手册</h2><ul><li><p>Keras官方手册，非常详细的官方文档，文档中详细的介绍了从Keras每个知识点的用法，一步步带你从入门到精通。<br><a href="https://keras.io/" target="_blank" rel="noopener">https://keras.io/</a> </p></li><li><p>Keras中文官方手册，该中文官方手册是对对Keras英文官方手册最好的还原，适合所有阶段的Keras学习者阅读。<br><a href="https://keras.io/zh/" target="_blank" rel="noopener">https://keras.io/zh/</a></p></li><li><p>Keras中文文档，另一个非官方的Keras中文文档，笔者花了近两年的时间在维护，文档也一直在更新，包含ConvLSTM2D、SimpleRNNCellKeras、GRUCell等最新的内容，非常用心的一份Keras文档。<br><a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://keras-cn.readthedocs.io/en/latest/</a></p></li><li><p>安装Keras库进行深度学习，国外一篇比较火的博客，旨在演示如何安装Keras库进行深度学习。<br><a href="http://www.pyimagesearch.com/2016/07/18/installing-keras-for-deep-learning/" target="_blank" rel="noopener">http://www.pyimagesearch.com/2016/07/18/installing-keras-for-deep-learning/</a></p></li><li><p>黄海广博士力荐的Keras github项目，这个github的repository主要是博主在学习Keras的一些记录及练习，满满都是干货，建议大家看一下。<br><a href="https://github.com/erhwenkuo/deep-learning-with-keras-notebooks" target="_blank" rel="noopener">https://github.com/erhwenkuo/deep-learning-with-keras-notebooks</a></p></li><li><p>磐创AI Keras系列教程总结，从CNN到RNN，以入门、基础为主的讲解，适合小白学习。<br><a href="http://www.keraschina.com" target="_blank" rel="noopener">http://www.keraschina.com</a></p></li></ul><h2 id="Keras学习视频"><a href="#Keras学习视频" class="headerlink" title="Keras学习视频"></a>Keras学习视频</h2><ul><li><p>Waterloo大学关于Keras的课程，该视频在YouTube上有很高的播放率，课程质量非常高<br><a href="https://www.youtube.com/watch?v=Tp3SaRbql4k" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Tp3SaRbql4k</a></p></li><li><p>CERN使用Keras进行深度学习系列教程，比较详细、权威的一个Keras系列教程视频。<br><a href="http://cds.cern.ch/record/2157570?ln=en" target="_blank" rel="noopener">http://cds.cern.ch/record/2157570?ln=en</a></p></li><li><p>莫烦Keras视频教程，莫烦老师的视频在B站、YouTube上都有很高的播放量，强烈推荐给大家。<br><a href="https://www.bilibili.com/video/av16910214/" target="_blank" rel="noopener">https://www.bilibili.com/video/av16910214/</a></p></li><li><p>再为大家推荐YouTube上另一个大佬Sentdex的Keras教学视频，还配套有相应的文本教程和笔记。<br><a href="https://www.youtube.com/watch?v=wQ8BIBpya2k" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wQ8BIBpya2k</a></p></li></ul><p><a href="https://pythonprogramming.net/introduction-deep-learning-python-tensorflow-keras/" target="_blank" rel="noopener">https://pythonprogramming.net/introduction-deep-learning-python-tensorflow-keras/</a> </p><h2 id="Keras代码案例"><a href="#Keras代码案例" class="headerlink" title="Keras代码案例"></a>Keras代码案例</h2><h3 id="Keras-amp-NLP代码案例"><a href="#Keras-amp-NLP代码案例" class="headerlink" title="Keras&amp;NLP代码案例"></a>Keras&amp;NLP代码案例</h3><ul><li><p>用LSTM在IMDB影评数据集做文本分类<br><a href="https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py" target="_blank" rel="noopener">https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py</a></p></li><li><p>路透社主题分类<br><a href="https://github.com/fchollet/keras/blob/master/examples/reuters_mlp.py" target="_blank" rel="noopener">https://github.com/fchollet/keras/blob/master/examples/reuters_mlp.py</a></p></li><li><p>LSTM做文本生成<br><a href="https://github.com/fchollet/keras/blob/master/examples/lstm_text_generation.py" target="_blank" rel="noopener">https://github.com/fchollet/keras/blob/master/examples/lstm_text_generation.py</a></p></li><li><p>在IMDB数据集上使用FastText<br><a href="https://github.com/fchollet/keras/blob/master/examples/imdb_fasttext.py" target="_blank" rel="noopener">https://github.com/fchollet/keras/blob/master/examples/imdb_fasttext.py</a></p></li><li><p>基于LSTM的BABI数据集网络<br><a href="https://github.com/kerasteam/keras/blob/master/examples/reuters_mlp.py" target="_blank" rel="noopener">https://github.com/kerasteam/keras/blob/master/examples/reuters_mlp.py</a></p></li><li><p>预训练词向量<br><a href="https://github.com/kerasteam/keras/blob/master/examples/pretrained_word_embeddings.py" target="_blank" rel="noopener">https://github.com/kerasteam/keras/blob/master/examples/pretrained_word_embeddings.py</a></p></li><li><p>字符级卷积神经网络做文本分类<br><a href="https://github.com/johnb30/py_crepe" target="_blank" rel="noopener">https://github.com/johnb30/py_crepe</a></p></li><li><p>LSTM预测一个人的性别<br><a href="https://github.com/divamgupta/lstm-gender-predictor" target="_blank" rel="noopener">https://github.com/divamgupta/lstm-gender-predictor</a></p></li></ul><h3 id="Keras-amp-CV代码案例"><a href="#Keras-amp-CV代码案例" class="headerlink" title="Keras&amp;CV代码案例"></a>Keras&amp;CV代码案例</h3><ul><li><p>使用CNN进行MNIST<br><a href="https://github.com/fchollet/keras/blob/master/examples/mnist_cnn.py" target="_blank" rel="noopener">https://github.com/fchollet/keras/blob/master/examples/mnist_cnn.py</a></p></li><li><p>Inception V3<br><a href="https://github.com/fchollet/keras/blob/master/examples/inception_v3.py" target="_blank" rel="noopener">https://github.com/fchollet/keras/blob/master/examples/inception_v3.py</a></p></li><li><p>VGG16<br><a href="https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3" target="_blank" rel="noopener">https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3</a></p></li><li><p>FractalNet<br><a href="https://github.com/snf/keras-fractalnet" target="_blank" rel="noopener">https://github.com/snf/keras-fractalnet</a></p></li><li><p>可视问答<br><a href="https://github.com/avisingh599/visual-qa" target="_blank" rel="noopener">https://github.com/avisingh599/visual-qa</a></p></li><li><p>VGG-CAM<br><a href="https://github.com/tdeboissiere/VGG16CAM-keras" target="_blank" rel="noopener">https://github.com/tdeboissiere/VGG16CAM-keras</a></p></li><li><p>ResNet 50<br><a href="https://github.com/keras-team/keras/pull/3266/files" target="_blank" rel="noopener">https://github.com/keras-team/keras/pull/3266/files</a></p></li><li><p>对象分割<br><a href="https://github.com/abbypa/NNProject_DeepMask" target="_blank" rel="noopener">https://github.com/abbypa/NNProject_DeepMask</a></p></li><li><p>fcn、segnet、u-net等常用的图像分割模型<br><a href="https://github.com/divamgupta/image-segmentation-keras" target="_blank" rel="noopener">https://github.com/divamgupta/image-segmentation-keras</a></p></li></ul><h2 id="Keras项目"><a href="#Keras项目" class="headerlink" title="Keras项目"></a>Keras项目</h2><ul><li><p>RocAlphaGo，这个项目是DeepMind 2016年《自然》杂志的一个学生主导的实施项目，使用了Python+keras实现，代码清晰性更好。<br><a href="https://github.com/Rochester-NRT/RocAlphaG" target="_blank" rel="noopener">https://github.com/Rochester-NRT/RocAlphaG</a></p></li><li><p>BetaGo，项目是使用keras的深度学习Go机器人。<br><a href="https://github.com/maxpumperla/betago" target="_blank" rel="noopener">https://github.com/maxpumperla/betago</a></p></li><li><p>DeepJazz，使用Keras深度学习驱动的爵士乐生成系统。<br><a href="https://github.com/jisungk/deepjazz" target="_blank" rel="noopener">https://github.com/jisungk/deepjazz</a></p></li><li><p>dataset-sts，语义文本相似度数据集集线器。<br><a href="https://github.com/brmson/dataset-sts" target="_blank" rel="noopener">https://github.com/brmson/dataset-sts</a></p></li><li><p>NMT-Keras，利用球面进行神经机器翻译。<br><a href="https://github.com/lvapeab/nmt-keras" target="_blank" rel="noopener">https://github.com/lvapeab/nmt-keras</a></p></li><li><p>Headline generator，利用循环神经网络独立生成新闻标题的实现。<br><a href="https://github.com/udibr/headlines" target="_blank" rel="noopener">https://github.com/udibr/headlines</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Keras简介&quot;&gt;&lt;a href=&quot;#Keras简介&quot; class=&quot;headerlink&quot; title=&quot;Keras简介&quot;&gt;&lt;/a&gt;Keras简介&lt;/h2&gt;&lt;p&gt;Keras是Python中以CNTK、Tensorflow或者Theano为计算后台的一个深度学习建模环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="学习资料" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>人工智能中的数学知识</title>
    <link href="http://yoursite.com/2019/09/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/09/30/人工智能中的数学知识/</id>
    <published>2019-09-30T03:57:14.000Z</published>
    <updated>2019-09-30T04:15:35.062Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习和深度学习中所用的数学知识主要来自以下几门课：</p><ol><li><p>高等数学/微积分</p></li><li><p>线性代数与矩阵论</p></li><li><p>概率论与信息论</p></li></ol><a id="more"></a><ol start="4"><li><p>最优化方法</p></li><li><p>图论/离散数学</p></li></ol><p>总体来说需要如下知识点，这些知识点一般都是CS&amp;EE专业在大一和大二必修和选修的课程，大家可以查漏补缺。</p><h2 id="1-1-微积分"><a href="#1-1-微积分" class="headerlink" title="1.1 微积分"></a>1.1 微积分</h2><ul><li><p>函数极限</p></li><li><p>上确界与下确界</p></li><li><p>导数与偏导数</p></li><li><p>单调性与极值</p></li><li><p>函数的凹凸性</p></li><li><p>泰勒级数</p></li><li><p>牛顿-莱布尼兹公式</p></li><li><p>Lipschitz连续性</p></li><li><p>Hessian矩阵</p></li></ul><h2 id="1-2-线性代数与矩阵运算"><a href="#1-2-线性代数与矩阵运算" class="headerlink" title="1.2 线性代数与矩阵运算"></a>1.2 线性代数与矩阵运算</h2><ul><li><p>线性空间与线性映射</p></li><li><p>行列式求解</p></li><li><p>常见的矩阵运算</p></li><li><p>特征值与特征向量</p></li><li><p>广义特征值</p></li><li><p>奇异值分解</p></li></ul><h2 id="1-3-概率论与数理统计"><a href="#1-3-概率论与数理统计" class="headerlink" title="1.3 概率论与数理统计"></a>1.3 概率论与数理统计</h2><ul><li><p>概率空间与事件</p></li><li><p>独立性与条件概率</p></li><li><p>贝叶斯公式</p></li><li><p>随机变量与概率公式</p></li><li><p>大数定理与中心极限定理</p></li><li><p>Jensen不等式</p></li><li><p>常见的概率分布</p></li><li><p>协方差</p></li><li><p>参数估计：矩估计/极大似然估计/区间估计</p></li><li><p>随机算法</p></li><li><p>信息论基础</p></li></ul><h2 id="1-4-最优化方法"><a href="#1-4-最优化方法" class="headerlink" title="1.4 最优化方法"></a>1.4 最优化方法</h2><ul><li><p>凸优化介绍，凸函数与凸集合</p></li><li><p>拉格朗日乘数法与KKT条件</p></li><li><p>常见的凸优化问题</p></li></ul><h2 id="1-5-图论"><a href="#1-5-图论" class="headerlink" title="1.5 图论"></a>1.5 图论</h2><ul><li><p>图概念</p></li><li><p>常见的图</p></li><li><p>路径搜索问题</p></li><li><p>最大流问题</p></li><li><p>拉普拉斯矩阵</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习和深度学习中所用的数学知识主要来自以下几门课：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;高等数学/微积分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线性代数与矩阵论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;概率论与信息论&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="数学基础" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AI学习资料</title>
    <link href="http://yoursite.com/2019/09/29/AI%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>http://yoursite.com/2019/09/29/AI学习资料/</id>
    <published>2019-09-29T12:58:25.000Z</published>
    <updated>2019-09-29T12:59:56.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="国外课程"><a href="#国外课程" class="headerlink" title="国外课程"></a>国外课程</h1><h2 id="斯坦福公开课程：概率和统计"><a href="#斯坦福公开课程：概率和统计" class="headerlink" title="斯坦福公开课程：概率和统计"></a>斯坦福公开课程：概率和统计</h2><p>课程名称：《Probability and Statistics》</p><a id="more"></a><p>学习地址：<a href="https://online.stanford.edu/courses/gse-yprobstat-probability-and-statistics" target="_blank" rel="noopener">https://online.stanford.edu/courses/gse-yprobstat-probability-and-statistics</a></p><h2 id="MIT-公开课线性代数"><a href="#MIT-公开课线性代数" class="headerlink" title="MIT 公开课线性代数"></a>MIT 公开课线性代数</h2><p>课程名称：《Linear Algebra》</p><p>讲师：Gilbert Strang</p><p>学习地址：<a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/" target="_blank" rel="noopener">https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/</a></p><h2 id="斯坦福-2017-季-CS231n-深度视觉识别课程视频"><a href="#斯坦福-2017-季-CS231n-深度视觉识别课程视频" class="headerlink" title="斯坦福 2017 季 CS231n 深度视觉识别课程视频"></a>斯坦福 2017 季 CS231n 深度视觉识别课程视频</h2><p>课程名称：《Convolutional Neural Networks for Visual Recognition》</p><p>讲师：Fei-Fei Li、Justin Johnson、Serena Yeung</p><p>国外学习地址：<a href="https://www.youtube.com/playlist?list=PLzUTmXVwsnXod6WNdg57Yc3zFx_f-RYsq" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLzUTmXVwsnXod6WNdg57Yc3zFx_f-RYsq</a></p><p>国内学习地址：<a href="https://www.bilibili.com/video/av13260183/" target="_blank" rel="noopener">https://www.bilibili.com/video/av13260183/</a></p><h2 id="Fastai-推出的【2019-年面向程序员的深度学习实战课程】"><a href="#Fastai-推出的【2019-年面向程序员的深度学习实战课程】" class="headerlink" title="Fastai 推出的【2019 年面向程序员的深度学习实战课程】"></a>Fastai 推出的【2019 年面向程序员的深度学习实战课程】</h2><p>课程名称：《Practical Deep Learning for Coders, v3》</p><p>讲师：Jeremy Howard</p><p>国外学习地址：<a href="https://course.fast.ai" target="_blank" rel="noopener">https://course.fast.ai</a></p><p>国内学习地址：<a href="https://www.bilibili.com/video/av41718196/" target="_blank" rel="noopener">https://www.bilibili.com/video/av41718196/</a></p><h2 id="2019-斯坦福CS224n深度学习自然语言处理课程"><a href="#2019-斯坦福CS224n深度学习自然语言处理课程" class="headerlink" title="2019 斯坦福CS224n深度学习自然语言处理课程"></a>2019 斯坦福CS224n深度学习自然语言处理课程</h2><p>课程名称：《CS224n: Natural Language Processing with Deep Learning》</p><p>讲师：Chris Manning</p><p>国外学习地址：<a href="https://www.youtube.com/playlist?list=PLU40WL8Ol94IJzQtileLTqGZuXtGlLMP" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLU40WL8Ol94IJzQtileLTqGZuXtGlLMP</a>_</p><p>国内学习地址：<a href="https://www.bilibili.com/video/av46216519/" target="_blank" rel="noopener">https://www.bilibili.com/video/av46216519/</a></p><h2 id="斯坦福机器学习课程"><a href="#斯坦福机器学习课程" class="headerlink" title="斯坦福机器学习课程"></a>斯坦福机器学习课程</h2><p>课程名称：《Machine Learning（Coursera）》</p><p>讲师：Andrew Ng</p><p>学习地址：<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">https://www.coursera.org/learn/machine-learning</a></p><h2 id="斯坦福概率图模型专项课程"><a href="#斯坦福概率图模型专项课程" class="headerlink" title="斯坦福概率图模型专项课程"></a>斯坦福概率图模型专项课程</h2><p>课程名称：《Probabilistic Graphical Models Specialization(Coursera)》</p><p>讲师：Daphne Koller</p><p>学习地址：<a href="https://www.coursera.org/specializations/probabilistic-graphical-models" target="_blank" rel="noopener">https://www.coursera.org/specializations/probabilistic-graphical-models</a></p><h2 id="DeepMind-强化学习导论课程"><a href="#DeepMind-强化学习导论课程" class="headerlink" title="DeepMind 强化学习导论课程"></a>DeepMind 强化学习导论课程</h2><p>课程名称：《Introduction to Reinforcement Learning》</p><p>讲师：David Silver</p><p>国外学习地址：<a href="https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ</a></p><p>国内学习地址：<a href="https://www.bilibili.com/video/av24060851/" target="_blank" rel="noopener">https://www.bilibili.com/video/av24060851/</a></p><h2 id="全栈深度学习训练营-课程视频-：为熟悉深度学习基础知识的开发人员提供的实践指导课程"><a href="#全栈深度学习训练营-课程视频-：为熟悉深度学习基础知识的开发人员提供的实践指导课程" class="headerlink" title="全栈深度学习训练营(课程视频)：为熟悉深度学习基础知识的开发人员提供的实践指导课程"></a>全栈深度学习训练营(课程视频)：为熟悉深度学习基础知识的开发人员提供的实践指导课程</h2><p>课程名称：《Full Stack Deep Learning Bootcamp》</p><p>Github 地址：<a href="https://github.com/full-stack-deep-learning/fsdl-text-recognizer-project" target="_blank" rel="noopener">https://github.com/full-stack-deep-learning/fsdl-text-recognizer-project</a></p><p>国外学习地址：<a href="https://fullstackdeeplearning.com/march2019" target="_blank" rel="noopener">https://fullstackdeeplearning.com/march2019</a></p><p>国内学习地址：<a href="https://www.bilibili.com/video/av49643298" target="_blank" rel="noopener">https://www.bilibili.com/video/av49643298</a></p><h2 id="跟顶级Kagglers学习如何赢取数据科学竞赛"><a href="#跟顶级Kagglers学习如何赢取数据科学竞赛" class="headerlink" title="跟顶级Kagglers学习如何赢取数据科学竞赛"></a>跟顶级Kagglers学习如何赢取数据科学竞赛</h2><p>课程名称：《How to Win a Data Science Competition: Learn from Top Kagglers（Coursera）》</p><p>讲师：Dmitry Ulyanov、Alexander Guschin、Mikhail Trofimov、Dmitry Altukhov、Marios Michailidis</p><p>学习地址：<a href="https://www.coursera.org/learn/competitive-data-science" target="_blank" rel="noopener">https://www.coursera.org/learn/competitive-data-science</a></p><h2 id="CS188-伯克利《人工智能导论》课程，含视频-资料"><a href="#CS188-伯克利《人工智能导论》课程，含视频-资料" class="headerlink" title="CS188 伯克利《人工智能导论》课程，含视频+资料"></a>CS188 伯克利《人工智能导论》课程，含视频+资料</h2><p>课程名称：《BerkeleyX: CS188.1x Artificial Intelligence》</p><p>国外学习地址：<a href="https://inst.eecs.berkeley.edu/~cs188/fa18/" target="_blank" rel="noopener">https://inst.eecs.berkeley.edu/~cs188/fa18/</a></p><p>国内学习地址：<a href="https://www.bilibili.com/video/av39489278/" target="_blank" rel="noopener">https://www.bilibili.com/video/av39489278/</a></p><h2 id="Fast-ai-发布的课程：从零开始学深度学习"><a href="#Fast-ai-发布的课程：从零开始学深度学习" class="headerlink" title="Fast.ai 发布的课程：从零开始学深度学习"></a>Fast.ai 发布的课程：从零开始学深度学习</h2><p>课程名称：《Deep Learning from the Foundations》</p><p>讲师：Jeremy Howard</p><p>学习地址：<a href="https://www.fast.ai/2019/06/28/course-p2v3/" target="_blank" rel="noopener">https://www.fast.ai/2019/06/28/course-p2v3/</a></p><h2 id="CS230-斯坦福深度学习课程（2018-年秋）"><a href="#CS230-斯坦福深度学习课程（2018-年秋）" class="headerlink" title="CS230 斯坦福深度学习课程（2018 年秋）"></a>CS230 斯坦福深度学习课程（2018 年秋）</h2><p>课程名称：《CS230: Deep Learning | Autumn 2018》</p><p>讲师：Andrew Ng、Kian Katanforoosh</p><p>国外学习地址：<a href="https://www.youtube.com/playlist?list=PLoROMvodv4rOABXSygHTsbvUz4G_YQhOb" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLoROMvodv4rOABXSygHTsbvUz4G_YQhOb</a></p><p>国内学习地址：<a href="https://www.bilibili.com/video/av47055599/" target="_blank" rel="noopener">https://www.bilibili.com/video/av47055599/</a></p><h2 id="deeplearning-ai-上线的-TensorFlow-实践课程，面向使用-TensorFlow-的开发者"><a href="#deeplearning-ai-上线的-TensorFlow-实践课程，面向使用-TensorFlow-的开发者" class="headerlink" title="deeplearning.ai 上线的 TensorFlow 实践课程，面向使用 TensorFlow 的开发者"></a>deeplearning.ai 上线的 TensorFlow 实践课程，面向使用 TensorFlow 的开发者</h2><p>课程名称：《TensorFlow in Practice》</p><p>讲师：Andrew Ng</p><p>学习地址：<a href="https://www.deeplearning.ai/tensorflow-in-practice/" target="_blank" rel="noopener">https://www.deeplearning.ai/tensorflow-in-practice/</a></p><h2 id="UC-Berkeley《动手学深度学习》，李沐新书配套课程"><a href="#UC-Berkeley《动手学深度学习》，李沐新书配套课程" class="headerlink" title="UC Berkeley《动手学深度学习》，李沐新书配套课程"></a>UC Berkeley《动手学深度学习》，李沐新书配套课程</h2><p>课程名称：《Dive into Deep Learning》</p><p>讲师：Alex Smola、Mu Li</p><p>学习地址：<a href="https://www.youtube.com/playlist?list=PLZSO_6-bSqHQHBCoGaObUljoXAyyqhpFW" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLZSO_6-bSqHQHBCoGaObUljoXAyyqhpFW</a></p><h2 id="MIT的Python机器学习课程"><a href="#MIT的Python机器学习课程" class="headerlink" title="MIT的Python机器学习课程"></a>MIT的Python机器学习课程</h2><p>课程名称：《Machine Learning with Python-From Linear Models to Deep Learning》</p><p>学习地址：<a href="https://www.edx.org/course/machine-learning-with-python-from-linear-models-to-deep-learning" target="_blank" rel="noopener">https://www.edx.org/course/machine-learning-with-python-from-linear-models-to-deep-learning</a></p><h2 id="斯坦福-CS224U-自然语言理解课程"><a href="#斯坦福-CS224U-自然语言理解课程" class="headerlink" title="斯坦福 CS224U 自然语言理解课程"></a>斯坦福 CS224U 自然语言理解课程</h2><p>课程名称：《CS224U：Natural Language Understanding》</p><p>学习地址：<a href="http://web.stanford.edu/class/cs224u/index.html" target="_blank" rel="noopener">http://web.stanford.edu/class/cs224u/index.html</a></p><h1 id="国内顶尖大学的计算机课程"><a href="#国内顶尖大学的计算机课程" class="headerlink" title="国内顶尖大学的计算机课程:"></a>国内顶尖大学的计算机课程:</h1><h2 id="中国科学技术大学课程资源"><a href="#中国科学技术大学课程资源" class="headerlink" title="中国科学技术大学课程资源"></a>中国科学技术大学课程资源</h2><p>课程名称：《USTC-Course》</p><p>Github 地址：<a href="https://github.com/USTC-Resource/USTC-Course" target="_blank" rel="noopener">https://github.com/USTC-Resource/USTC-Course</a></p><h2 id="浙江大学"><a href="#浙江大学" class="headerlink" title="浙江大学"></a>浙江大学</h2><p>Github 地址：<a href="https://github.com/QSCTech/zju-icicles" target="_blank" rel="noopener">https://github.com/QSCTech/zju-icicles</a></p><h2 id="清华大学课程"><a href="#清华大学课程" class="headerlink" title="清华大学课程"></a>清华大学课程</h2><p>Github 地址：<a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener">https://github.com/PKUanonym/REKCARC-TSC-UHT</a></p><h2 id="北京大学课程"><a href="#北京大学课程" class="headerlink" title="北京大学课程"></a>北京大学课程</h2><p>Github 地址：<a href="https://github.com/lib-pku/libpku" target="_blank" rel="noopener">https://github.com/lib-pku/libpku</a></p><h1 id="台湾老师的课程"><a href="#台湾老师的课程" class="headerlink" title="台湾老师的课程"></a>台湾老师的课程</h1><h2 id="陈蕴侬应用深度学习"><a href="#陈蕴侬应用深度学习" class="headerlink" title="陈蕴侬应用深度学习"></a>陈蕴侬应用深度学习</h2><p>课程名称：《107 Spring - Applied Deep Learning, Taiwan University》</p><p>讲师：Yun-Nung (Vivian) Chen</p><p>学习地址：<a href="https://www.bilibili.com/video/av46656764/https://www.csie.ntu.edu.tw/~miulab/s107-adl/" target="_blank" rel="noopener">https://www.bilibili.com/video/av46656764/https://www.csie.ntu.edu.tw/~miulab/s107-adl/</a></p><h2 id="台大林轩田老师《机器学习基石》课程"><a href="#台大林轩田老师《机器学习基石》课程" class="headerlink" title="台大林轩田老师《机器学习基石》课程"></a>台大林轩田老师《机器学习基石》课程</h2><p>课程名称：《机器学习基石》</p><p>讲师：林轩田</p><p>学习地址：<a href="https://www.bilibili.com/video/av12463015/" target="_blank" rel="noopener">https://www.bilibili.com/video/av12463015/</a></p><h2 id="台大林轩田老师课程"><a href="#台大林轩田老师课程" class="headerlink" title="台大林轩田老师课程"></a>台大林轩田老师课程</h2><p>课程名称：《机器学习技法》</p><p>讲师：林轩田</p><p>学习地址：<a href="https://www.bilibili.com/video/av12469267/" target="_blank" rel="noopener">https://www.bilibili.com/video/av12469267/</a></p><h2 id="NTU-大学，李宏毅最新机器学习课程（2019）"><a href="#NTU-大学，李宏毅最新机器学习课程（2019）" class="headerlink" title="NTU 大学，李宏毅最新机器学习课程（2019）"></a>NTU 大学，李宏毅最新机器学习课程（2019）</h2><p>课程名称：《Machine Learning》</p><p>讲师：李宏毅 </p><p>学习地址：<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML19.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML19.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;国外课程&quot;&gt;&lt;a href=&quot;#国外课程&quot; class=&quot;headerlink&quot; title=&quot;国外课程&quot;&gt;&lt;/a&gt;国外课程&lt;/h1&gt;&lt;h2 id=&quot;斯坦福公开课程：概率和统计&quot;&gt;&lt;a href=&quot;#斯坦福公开课程：概率和统计&quot; class=&quot;headerlink&quot; title=&quot;斯坦福公开课程：概率和统计&quot;&gt;&lt;/a&gt;斯坦福公开课程：概率和统计&lt;/h2&gt;&lt;p&gt;课程名称：《Probability and Statistics》&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="学习资料" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>人工智能，机器学习，数据挖掘</title>
    <link href="http://yoursite.com/2019/09/29/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://yoursite.com/2019/09/29/人工智能，机器学习，数据挖掘/</id>
    <published>2019-09-29T12:55:22.000Z</published>
    <updated>2019-09-29T12:57:32.303Z</updated>
    
    <content type="html"><![CDATA[<p>说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。例如京东会根据你的浏览行为和用户的相似性，利用算法为你推荐你需要的产品；又比如美颜相机，会基于你面部特征的分析，通过算法精细你的美颜效果。还有众所周知的谷歌DeepMind，当AlphaGo打败了韩国职业围棋高手Lee Se-dol时，媒体描述这场人机对战的时候，提到了人工智能AI、机器学习、深度学习等术语。没错，这三项技术都为AlphaGo的胜利立下了汗马功劳，然而它们并不是一回事。</p><a id="more"></a><p>人工智能和机器学习的同时出现，机器学习和深度学习的交替使用……使大部分读者雾里看花，这些概念究竟有何区别，我们可以通过下面一个关系图来进行区分。</p><p><img src="https://i.loli.net/2019/08/31/fmbgJWRBzT5hMI4.jpg" alt="1.jpg"></p><center>图一：人工智能、机器学习、深度学习的关系</center><p>人工智能包括了机器学习和深度学习，机器学习包括了深度学习。人工智能是机器学习的父类，机器学习则是深度学习的父类。</p><p>人工智能（Artificial Intelligence，AI）是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的与人类智能相似的方式作出反应的智能机器，它不是人的智能，但能像人那样思考、也可能超过人的智能。</p><p>人工智能实际应用：机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。人工智能目前也分为：强人工智能(BOTTOM-UPAI)和弱人工智能(TOP-DOWNAI)。</p><p>机器学习（Machine Learning，ML）是人工智能的核心，属于人工智能的一个分支。机器学习是指从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法，所以机器学习的核心是数据、算法（模型）、算力（计算机运算能力）。</p><p>机器学习应用领域：数据挖掘、数据分类、计算机视觉、自然语言处理(NLP)、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用等。</p><p>深度学习（Deep Learning，DL）：是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据。</p><p>数据挖掘（Data Mining，DM），顾名思义是指利用机器学习技术从海量数据中“挖掘”隐藏信息，主要应用于图像、声音、文本。在商业环境中，企业希望让存放在数据库中的数据能“说话”，支持决策。所以数据挖掘更偏向于应用。</p><p><img src="https://i.loli.net/2019/08/31/uHUkLpMN87ZtrYV.jpg" alt="2.jpg"></p><center>图二：数据挖掘与机器学习的关系</center><p>机器学习是数据挖掘的一种重要方法，但机器学习是另一门学科，并不从属于数据挖掘，二者相辅相成。数据挖掘是机器学习和数据库的交叉，主要利用机器学习提供的技术来分析海量数据，利用数据库界提供的技术来管理海量数据。</p><p>不管是人工智能、机器学习、深度学习还是数据挖掘，目前都在解决共同目标时发挥了自己的优势，并为社会生产和人类生活提供便利，帮助我们探索过去、展示现状、预测未来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。例如京东会根据你的浏览行为和用户的相似性，利用算法为你推荐你需要的产品；又比如美颜相机，会基于你面部特征的分析，通过算法精细你的美颜效果。还有众所周知的谷歌DeepMind，当AlphaGo打败了韩国职业围棋高手Lee Se-dol时，媒体描述这场人机对战的时候，提到了人工智能AI、机器学习、深度学习等术语。没错，这三项技术都为AlphaGo的胜利立下了汗马功劳，然而它们并不是一回事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透工具</title>
    <link href="http://yoursite.com/2019/09/29/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/09/29/内网穿透工具/</id>
    <published>2019-09-29T12:49:53.000Z</published>
    <updated>2019-09-29T12:51:46.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>如何让任何地方都能访问自己家里的笔记本上的应用？</p></li><li><p>如何让局域网的服务器可以被任何地方访问到？</p></li></ul><a id="more"></a><p>有很多类似的需求，我们可以统一用一个解决方案：<strong>内网穿透</strong>。下面介绍几种常用的内网穿透方式，从此旧电脑不再变废柴。</p><h1 id="几种方式"><a href="#几种方式" class="headerlink" title="几种方式"></a>几种方式</h1><h2 id="Ngrok"><a href="#Ngrok" class="headerlink" title="Ngrok"></a>Ngrok</h2><p>简介：一个通过任何NAT或防火墙为您的本地主机服务器提供即时访问、安全的URL的命令。类似花生壳，分为服务端和客户端，也可以自己搭建服务端。</p><p>工具主页：<a href="https://ngrok.com/" target="_blank" rel="noopener">https://ngrok.com/</a></p><h2 id="autossh"><a href="#autossh" class="headerlink" title="autossh"></a>autossh</h2><p>简介：autossh是一个程序，用于启动ssh的副本并进行监控，在死亡或停止传输流量时根据需要重新启动它。这个想法来自rstunnel（Reliable SSH Tunnel），但是在C中实现。作者的观点是，它不像匆匆忙忙的工作那么容易。使用端口转发环路或远程回显服务进行连接监视。在遇到连接拒绝等快速故障时，关闭连接尝试的速度。在OpenBSD，Linux，Solaris，Mac OS X，Cygwin和AIX上编译和测试; 应该在其他BSD上工作。免费软件。</p><p>工具主页：<a href="http://www.harding.motd.ca/autossh/" target="_blank" rel="noopener">http://www.harding.motd.ca/autossh/</a></p><h2 id="Natapp"><a href="#Natapp" class="headerlink" title="Natapp"></a>Natapp</h2><p>简介：基于ngrok的国内收费内网穿透工具，类似花生壳，有免费版本，比花生壳好。免费版本：提供http,https,tcp全隧道穿透，随机域名/TCP端口，不定时强制更换域名/端口，自定义本地端口</p><p>工具主页：<a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a> </p><h2 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h2><p>简介：frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p>工具主页：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><h2 id="Lanproxy"><a href="#Lanproxy" class="headerlink" title="Lanproxy"></a>Lanproxy</h2><p>简介：lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。</p><p>工具主页：<a href="https://github.com/ffay/lanproxy" target="_blank" rel="noopener">https://github.com/ffay/lanproxy</a></p><h2 id="Spike"><a href="#Spike" class="headerlink" title="Spike"></a>Spike</h2><p>简介：Spike是一个可以用来将你的内网服务暴露在公网的快速的反向代理，基于ReactPHP，采用IO多路复用模型。采用php实现。</p><p>工具主页：<a href="https://github.com/slince/spike" target="_blank" rel="noopener">https://github.com/slince/spike</a></p><h2 id="花生壳"><a href="#花生壳" class="headerlink" title="花生壳"></a>花生壳</h2><p>简介：商业化比较成功的内网穿透。个人开发很不推荐，收费贵，企业可以考虑使用。</p><p>工具主页：<a href="https://hsk.oray.com/" target="_blank" rel="noopener">https://hsk.oray.com/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何让任何地方都能访问自己家里的笔记本上的应用？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何让局域网的服务器可以被任何地方访问到？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="内网穿透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    
      <category term="内网穿透工具" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>机器学习开源工具</title>
    <link href="http://yoursite.com/2019/09/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/09/29/机器学习开源工具/</id>
    <published>2019-09-29T12:46:50.000Z</published>
    <updated>2019-09-29T12:49:00.777Z</updated>
    
    <content type="html"><![CDATA[<p>从事机器学习方面的工作，不会用工具将极大地阻碍工作效率。但现在工具那么多，我们该如何选择呢？本文针对非开发者、模型部署、NLP、语音、视觉、强化学习、数据挖掘等多个不同人群，提供了10个必须掌握的模型。</p><a id="more"></a><p>在厦门人工智能峰会上，依图科技联合创始人、CEO朱珑介绍到短短的5年时间机器的算法水平又提升了100万倍！过去或许只能从1万人中识别出1个人，后来发展到1000万、1亿、10亿甚至20亿人中识别出这个人！与此同时，算力方面提升了10万倍。从过去用1万量级规模的数据做训练，到百万规模的数据做训练，到现在用10亿的数据集做训练，又提升了1万倍！</p><p>我们已经深刻地体会到，人工智能的飞速增长刺激了当今就业市场对机器学习技能的巨大需求。机器学习社区现在非常活跃，各种开源工具层出不穷，让人有点目不暇接，有点不知道该如何选择。那么本篇将为你介绍10个最应该了解的机器学习开源工具，走起！</p><h1 id="非开发者应该用什么？"><a href="#非开发者应该用什么？" class="headerlink" title="非开发者应该用什么？"></a>非开发者应该用什么？</h1><p>不会开发，不会编程，也能用机器学习？答案是可以的，只要你会用工具。这里为初学者推荐两个工具：</p><h2 id="Knime"><a href="#Knime" class="headerlink" title="Knime"></a>Knime</h2><p>Knime是一款出色的工具，可让你无需编写任何代码即可完成端到端的数据科学工作流程。</p><p>它甚至配备了一个拖放式界面，UI清晰，操作简单直观，可以说是懒人福音了。</p><p>操作起来非常简单，首先使用该工具进行数据收集和转换；完成后，你可以创建一个模型并将其可视化。在生产方面，你可以部署和管理数据科学项目。</p><p>最后，你可以通过使用Knime生成洞察来利用你的实现。</p><p>官网：<br><a href="https://www.knime.com/" target="_blank" rel="noopener">https://www.knime.com/</a></p><h2 id="Uber-Ludwig"><a href="#Uber-Ludwig" class="headerlink" title="Uber Ludwig"></a>Uber Ludwig</h2><p>Uber Ludwig是另一款适合初学者的优秀工具。有了它，你可以快速测试和训练深度学习模型。用户可以选择启用懒人模式（拖拽界面），或者直接操作代码。</p><p>使用起来比Knime稍微复杂一点点。需要先加载CSV文件来训练数据。通过使用预先训练的模型，你可以预测输出目标。最后，你可以使用可用的可视化选项可视化你的数据。</p><p>如果你是编程的初学者，你还可以在Python中使用他们扩展的API和训练模型。</p><p>GitHub地址：<br><a href="https://uber.github.io/ludwig/user_guide/" target="_blank" rel="noopener">https://uber.github.io/ludwig/user_guide/</a></p><h1 id="模型部署用什么工具？"><a href="#模型部署用什么工具？" class="headerlink" title="模型部署用什么工具？"></a>模型部署用什么工具？</h1><p>模型部署是机器学习的关键方面之一。为了帮助你完成此过程，这里列出了几个工具。</p><h2 id="TensorFlow-js"><a href="#TensorFlow-js" class="headerlink" title="TensorFlow.js"></a>TensorFlow.js</h2><p>TensorFlow.js允许你直接从Web构建和部署机器学习模型。它使用JavaScript在Web上运行。</p><p>你也可以使用Node.js。有了它，你不仅可以运行现有模型，还可以重新训练现有模型。</p><p>它提供了直观的API，允许你使用JavaScript构建和训练模型，在Web浏览器上也是如此。</p><p>如果你想在移动设备上进行开发，还可以查看TensorFlow Lite。</p><p>官方地址：<br><a href="https://www.tensorflow.org/js/" target="_blank" rel="noopener">https://www.tensorflow.org/js/</a></p><h2 id="MLFlow"><a href="#MLFlow" class="headerlink" title="MLFlow"></a>MLFlow</h2><p>MLFlow让你可以解决端到端的机器学习生命周期问题。它有三个主要组件。</p><p>MLflow跟踪 - 通过记录和比较结果和参数来处理实验<br>MLflow项目 - 允许你将项目打包成其他成员的可重用表单<br>MLflow模型 - 帮助你在不同平台中部署和管理ML库</p><p>MLFlow的另一个惊人功能是它与库无关。这意味着你可以将其与其他机器学习库一起使用而不会出现任何兼容性问题。为了实现library-agonistic行为，它使用REST API和CLI。</p><p>官方地址：<br><a href="https://github.com/databricks/mlflow" target="_blank" rel="noopener">https://github.com/databricks/mlflow</a></p><h1 id="NLP、计算机视觉和音频用什么工具？"><a href="#NLP、计算机视觉和音频用什么工具？" class="headerlink" title="NLP、计算机视觉和音频用什么工具？"></a>NLP、计算机视觉和音频用什么工具？</h1><p>还有其他方便的工具可用于在机器学习中执行不同的操作。</p><h2 id="Detectron"><a href="#Detectron" class="headerlink" title="Detectron"></a>Detectron</h2><p>如果你正在寻找最先进的物体检测算法，那么你可以使用Detectron。</p><p>它由Facebook开发，是AI Research软件系统的一部分。它利用Caffe2深度学习框架和Python。</p><p>官方地址：<br><a href="https://github.com/facebookresearch/Detectron" target="_blank" rel="noopener">https://github.com/facebookresearch/Detectron</a></p><h2 id="SimpleCV"><a href="#SimpleCV" class="headerlink" title="SimpleCV"></a>SimpleCV</h2><p>SimpleCV，一个开源框架，允许你构建计算机视觉应用程序。它类似于OpenCV，使你可以访问高级计算机视觉库。这意味着你不必担心错综复杂的概念。</p><p>有了它，你可以制作计算机视觉项目，而无需在基础知识上投入太多时间。毕竟，出于某种原因，它被命名为SimpleCV。</p><p>官方地址：<br><a href="http://simplecv.org/" target="_blank" rel="noopener">http://simplecv.org/</a></p><h2 id="Tesseract-OCR"><a href="#Tesseract-OCR" class="headerlink" title="Tesseract OCR"></a>Tesseract OCR</h2><p>Tesseract OCR是一款功能强大的光学字符识别软件，可让你识别语言。</p><p>它支持100多种语言，也可以编程识别新语言。</p><p>官方地址：<br><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></p><h1 id="强化学习用什么工具？"><a href="#强化学习用什么工具？" class="headerlink" title="强化学习用什么工具？"></a>强化学习用什么工具？</h1><p>如果你想训练智能体，那么你需要帮助强化学习。</p><h2 id="Open-AI-Gym"><a href="#Open-AI-Gym" class="headerlink" title="Open AI Gym"></a>Open AI Gym</h2><p>Open AI Gym让你训练你的智能体做几乎任何事情，包括散步、玩游戏等等。它借助易于使用的强化学习任务套件来实现。</p><p>官方地址：<br><a href="https://gym.openai.com/" target="_blank" rel="noopener">https://gym.openai.com/</a></p><h2 id="Unity-ML-Agents"><a href="#Unity-ML-Agents" class="headerlink" title="Unity ML Agents"></a>Unity ML Agents</h2><p>Unity ML Agents是Unity提供的开源统一插件，让你开发可在游戏中使用的智能体。</p><p>官方网址：<br><a href="https://unity3d.com/machine-learninghttps://unity3d.com/machine-learning" target="_blank" rel="noopener">https://unity3d.com/machine-learninghttps://unity3d.com/machine-learning</a></p><h1 id="数据挖掘用什么工具？"><a href="#数据挖掘用什么工具？" class="headerlink" title="数据挖掘用什么工具？"></a>数据挖掘用什么工具？</h1><p>如果你希望收集数据科学项目的数据，可以使用以下工具。</p><h2 id="Weka"><a href="#Weka" class="headerlink" title="Weka"></a>Weka</h2><p>Weka用于数据挖掘任务。它借助于为数据挖掘设计的机器学习算法来实现。有了它，你可以找到很多东西，包括分类、准备、回归、聚类、可视化和关联规则挖掘。</p><p>该项目是开源的，使用GNU许可。</p><p>官方网址：<br><a href="http://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="noopener">http://www.cs.waikato.ac.nz/ml/weka/</a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>机器学习正在改变我们与世界互动的方式。它使我们的生活更轻松，并确保我们建立一个未来世界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从事机器学习方面的工作，不会用工具将极大地阻碍工作效率。但现在工具那么多，我们该如何选择呢？本文针对非开发者、模型部署、NLP、语音、视觉、强化学习、数据挖掘等多个不同人群，提供了10个必须掌握的模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python常用包介绍</title>
    <link href="http://yoursite.com/2019/09/29/python%E5%B8%B8%E7%94%A8%E5%8C%85%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/09/29/python常用包介绍/</id>
    <published>2019-09-29T12:42:03.000Z</published>
    <updated>2019-09-29T12:45:46.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的常用包有哪些，分别有什么作用？"><a href="#Python的常用包有哪些，分别有什么作用？" class="headerlink" title="Python的常用包有哪些，分别有什么作用？"></a>Python的常用包有哪些，分别有什么作用？</h1><h2 id="Python常用包"><a href="#Python常用包" class="headerlink" title="Python常用包"></a>Python常用包</h2><p>1、Numpy（数值运算库）</p><p>2、Scipy（科学计算库）</p><a id="more"></a><p>3、Matplotlib（基础可视化库）</p><p>4、Pandas（数据处理库）</p><p>5、Seaborn（高级可视化库）</p><p>6、Scikit-learn（流行的机器学习库）</p><h2 id="各自作用"><a href="#各自作用" class="headerlink" title="各自作用"></a>各自作用</h2><p>1、Numpy是最为流行的机器学习和数据科学包，Numpy包支持在多维数据上的数学运算，提供数据结构以及相应高效的处理函数，很多更高级的扩展库(包括Scipy、Matplotlib、Pandas等库）都依赖于Numpy库；</p><p>2、Scipy包用于科学计算，提供矩阵支持，以及矩阵相关的数值计算模块，其功能包含有最优化、线性代数、积分、插值、拟合、信号处理和图像处理以及其他科学工程中常用的计算；</p><p>3、Pandas用于管理数据集，强大、灵活的数据分析和探索工具，其带有丰富的数据处理函数，支持序列分析功能，支持灵活处理缺失数据等；</p><p>● Pandas基本的数据结构是Series和DataFrame；</p><p>● Series就是序列，类似一维数组；</p><p>● DataFrame相当于一张二维的表格，类似二维数组，它的每一列都是一个Series；</p><p>● 为了定位Series中的元素，Pandas提供了Index对象，每个Series都会带有一个对应的Index，用来标记不用的元素；</p><p>● DataFrame相当于多个带有同样Index的Series的组合（本质是Series的容器）；</p><p>4、Matplotlib库用于数据可视化，强大的数据可视化工具以及作图库，其主要用于二维绘图，也可以进行简单的三维绘图；</p><p>5、Seaborn库是基于Matplotlib的高级可视化库；</p><p>6、Sklearn库包含大量机器学习算法的实现，其提供了完善的机器学习工具箱，支持预处理、回归、分类、聚类、降维、预测和模型分析等强大的机器学习库，近乎一半的机器学习和数据科学项目使用该包。</p><h1 id="sklearn的常用包有哪些，分别有什么作用？"><a href="#sklearn的常用包有哪些，分别有什么作用？" class="headerlink" title="sklearn的常用包有哪些，分别有什么作用？"></a>sklearn的常用包有哪些，分别有什么作用？</h1><h2 id="sklearn库的结构"><a href="#sklearn库的结构" class="headerlink" title="sklearn库的结构"></a>sklearn库的结构</h2><p>sklearn主要是用于机器学习，所以sklearn的模块也都是围绕机器学习算法的。sklearn因此可以分为这几个部分：Classification（分类），Regression（回归），Clustering（聚类），Dimensionality reduction（降维），Model selection（模型选择），Preprocessing（预处理）。</p><p>1.分类算法包括SVM（sklearn.svm.SVC等）、近邻（sklearn.neighbors）、随机森林（sklearn.ensemble.RandomForestClassifier）等。</p><p>2.回归算法包括SVR（sklearn.svm.SVR）、岭回归（sklearn.linear_model.Ridge）、Lasso（sklearn.linear_model.Lasso）等。</p><p>3.聚类算法包括K均值（sklearn.cluster.KMeans）、谱聚类（sklearn.cluster.SpectralClustering）等。</p><p>4.降维算法包括PCA（如sklearn.decomposition.PCA）、特征选择（sklearn.feature_selection，包括单变量特征选择等）、非负矩阵分解（如sklearn.decomposition.NMF、LatentDirichletAllocation）。</p><p>5.模型选择方法包括网格搜索（sklearn.model_selection.GridSearchCV）、交叉验证（有很多，比如sklearn.model_selection.KFold、cross_val_score）、评估指标（sklearn.model_selection.metrics，包括precision、recall、accuracy等）。</p><p>6.预处理方法包括基本的预处理方法（sklearn.preprocessing，包括标准化、类别化、离散化等）、特征抽取（sklearn.feature_extraction，包括文本特征抽取方法bag of words、tf-idf等）。</p><h2 id="机器学习主要步骤中sklearn应用"><a href="#机器学习主要步骤中sklearn应用" class="headerlink" title="机器学习主要步骤中sklearn应用"></a>机器学习主要步骤中sklearn应用</h2><p>1.数据集：sklearn.datasets中提供了很多数据集，初学时可将其作为基础数据。</p><p>2.数据预处理：sklearn.preprocessing，包括：降维、数据归一化、特征提取和特征转换（one-hot）等</p><p>3.选择模型并训练：分类、回归、聚类、集成等算法，涉及的模型主要是sklearn.linear_model、sklearn.cluster、sklearn.ensemble。</p><p>4.模型评分：sklearn.metrics，包括准确率、召回率等，算法自身也带有评分方法score。</p><p>5.模型的保存与恢复：可以用python的pickle方法（pickle.dump、pickle.load），或者sklearn.externals.joblib（joblib.dump、joblib.load）。</p><h1 id="什么是正则化、如何理解正则化以及正则化的作用？"><a href="#什么是正则化、如何理解正则化以及正则化的作用？" class="headerlink" title="什么是正则化、如何理解正则化以及正则化的作用？"></a>什么是正则化、如何理解正则化以及正则化的作用？</h1><p>正则化-Regularization（也称为惩罚项或范数）就是通过对模型的参数在“数量”和“大小”方面做相应的调整，从而降低模型的复杂度，以达到避免过拟合的效果。</p><h2 id="如何理解正则化"><a href="#如何理解正则化" class="headerlink" title="如何理解正则化"></a>如何理解正则化</h2><p>如果我们的目标仅仅是最小化损失函数（即经验风险最小化），那么模型的复杂度势必会影响到模型的整体性能；引入正则化（即结构风险最小化）可以理解为衡量模型的复杂度，同时结合经验风险最小化，进一步训练优化算法。</p><h2 id="正则化的作用"><a href="#正则化的作用" class="headerlink" title="正则化的作用"></a>正则化的作用</h2><p>正则化可以限制模型的复杂度，从而尽量避免过拟合的发生；模型之所以出现过拟合的主要原因是学习到了过多噪声，即模型过于复杂（也可以通过简化模型或增加数据集等方法尽量避免过拟合的发生）。</p><h2 id="正则化的常见类型"><a href="#正则化的常见类型" class="headerlink" title="正则化的常见类型:"></a>正则化的常见类型:</h2><p>（1）L1正则化</p><p>可以通过稀疏化（减少参数“数量”）来降低模型复杂度的，即可以将参数值减小到0。</p><p>（2）L2正则化</p><p>可以通过减少参数值“大小”来降低模型的复杂度，即只能将参数值不断减小，但永远不会减小为0，只能尽量接近于0。</p><h2 id="关联概念"><a href="#关联概念" class="headerlink" title="关联概念"></a>关联概念</h2><p>过拟合、正则化、经验风险最小化、结构风险最小化、损失函数、模型复杂度、范数</p><h1 id="bias和variance是什么？"><a href="#bias和variance是什么？" class="headerlink" title="bias和variance是什么？"></a>bias和variance是什么？</h1><h2 id="解释1"><a href="#解释1" class="headerlink" title="解释1"></a>解释1</h2><p>bias 偏差 ：模型的期望（或平均）预测和正确值之间的差别；</p><p>variance 方差 ：模型之间的多个拟合预测之间的偏离程度。</p><h2 id="解释2"><a href="#解释2" class="headerlink" title="解释2"></a>解释2</h2><p>bias和variance分别从两个方面来描述了我们学习到的模型与真实模型之间的差距；</p><p>bias是 “用所有可能的训练数据集训练出的所有模型的输出的平均值” 与 “真实模型”的输出值之间的差异；</p><p>variance则是“不同的训练数据集训练出的模型”的输出值之间的差异。</p><h2 id="解释3"><a href="#解释3" class="headerlink" title="解释3"></a>解释3</h2><p>首先 Error = bias + variance</p><p>Error反映的是整个模型的准确度，bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性；</p><p>更准确地讲Error分成3个部分：Error = bias + variance + noise;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python的常用包有哪些，分别有什么作用？&quot;&gt;&lt;a href=&quot;#Python的常用包有哪些，分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;Python的常用包有哪些，分别有什么作用？&quot;&gt;&lt;/a&gt;Python的常用包有哪些，分别有什么作用？&lt;/h1&gt;&lt;h2 id=&quot;Python常用包&quot;&gt;&lt;a href=&quot;#Python常用包&quot; class=&quot;headerlink&quot; title=&quot;Python常用包&quot;&gt;&lt;/a&gt;Python常用包&lt;/h2&gt;&lt;p&gt;1、Numpy（数值运算库）&lt;/p&gt;
&lt;p&gt;2、Scipy（科学计算库）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python常用包" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>简历制作</title>
    <link href="http://yoursite.com/2019/09/29/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/09/29/简历制作/</id>
    <published>2019-09-29T12:21:08.000Z</published>
    <updated>2019-09-29T12:24:47.459Z</updated>
    
    <content type="html"><![CDATA[<p>越长大越孤单</p><a id="more"></a><h1 id="简历制作一"><a href="#简历制作一" class="headerlink" title="简历制作一"></a><a href="http://jianli.sqdxwz.com" target="_blank" rel="noopener">简历制作一</a></h1><p><strong>演示</strong>:</p><p><a href="https://sm.ms/image/54mpnv6RDh9toya" target="_blank"><img src="https://i.loli.net/2019/08/19/54mpnv6RDh9toya.png"></a></p><h1 id="简历制作二"><a href="#简历制作二" class="headerlink" title="简历制作二"></a><a href="https://www.farbox.com/service/app/~resume?utm_source=qdan.me#/" target="_blank" rel="noopener">简历制作二</a></h1><p><strong>演示</strong>:</p><p><a href="https://sm.ms/image/F5yb9BK4THJrYep" target="_blank"><img src="https://i.loli.net/2019/08/19/F5yb9BK4THJrYep.png"></a></p><h1 id="简历制作三"><a href="#简历制作三" class="headerlink" title="简历制作三"></a><a href="https://www.visualcv.com/resume-templates/" target="_blank" rel="noopener">简历制作三</a></h1><p><strong>演示</strong>:</p><p><a href="https://sm.ms/image/wkWlg7bc1ur3CJY" target="_blank"><img src="https://i.loli.net/2019/08/19/wkWlg7bc1ur3CJY.png"></a></p><h1 id="简历制作四"><a href="#简历制作四" class="headerlink" title="简历制作四"></a><a href="https://cvmkr.com/?utm_source=qdan.me#/" target="_blank" rel="noopener">简历制作四</a></h1><p><strong>演示</strong>:</p><p><a href="https://sm.ms/image/ZhbDMdN83pvIzwY" target="_blank"><img src="https://i.loli.net/2019/08/19/ZhbDMdN83pvIzwY.png"></a></p><h1 id="简历制作五"><a href="#简历制作五" class="headerlink" title="简历制作五"></a><a href="https://github.com/apachecn/LxxyxResume" target="_blank" rel="noopener">简历制作五</a></h1><p><strong>演示</strong>:</p><p><a href="https://sm.ms/image/BL6ynQTMPkUf2sh" target="_blank"><img src="https://i.loli.net/2019/08/21/BL6ynQTMPkUf2sh.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越长大越孤单&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="简历制作" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>打造一份优雅的简历</title>
    <link href="http://yoursite.com/2019/09/29/%E6%89%93%E9%80%A0%E4%B8%80%E4%BB%BD%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2019/09/29/打造一份优雅的简历/</id>
    <published>2019-09-29T11:54:50.000Z</published>
    <updated>2019-09-29T12:30:57.682Z</updated>
    
    <content type="html"><![CDATA[<p>正所谓是金九银十，希望这个简历对所有人有所帮助。</p><a id="more"></a><p>另外，简历的制作其实并不是一蹴而就的事，当你知道了写简历的套路，平时就会有意识的积累素材，所以什么时候都可以学习如何打造一份优雅的简历。</p><p>简历是什么？在我看来，在面试之前，直接代表你这个人。虽然简历不会说话，但是简历的内容会让面试官直接在脑海里勾勒出你的形象。如果简历排版非常精致，你就会被塑造成一位细心、得体的形象；反之，如果简历里出现了错别字，那粗心这个标签就会打到你身上了。</p><p>所以，对待简历一定要重视！它是找工作过程中的第一道关卡，过了这一关，才有在面试中展示自我的机会。当然，平时的积累，个人的真实水平，临场发挥、人脉、运气也都很重要。这篇文章假设那些因素大家都一样，只比拼简历，就看谁简历写得好。</p><p>好的简历就是你的名片，不好的简历可能就是你的黑历史。接下来我们进入正题，说说简历该怎么写。</p><p>先贴一份完成了的简历。为了不暴露隐私，简历中的信息都是虚构的，但是写法都是按照模板来的，所以仍然不失一份精彩的样例，可以细看研究的。</p><img src="https://i.loli.net/2019/09/29/I5CVQvLTuWGhx7J.jpg"><p>顺便说一句，这张图片，可以自由传播。如果你仔细研究一下简历中的三个项目，你肯定会被我的才华折服的。</p><p>接下来就按简历模板里各个板块的顺序，详细解释每个部分该怎么写。</p><h2 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h2><p>直接写名字，电话号码，邮箱，其他信息不用填写。</p><p>我找工作那会，实验室的信号不是太好，所以在手机号码后面还留了个座机号码，防止联系不上，这是细节。</p><p>关于电子邮箱，校招的同学可以留学校的邮箱；对于社招，gmail.com，163.com，foxmail.com 都不错，qq.com 也是可以的，只是需要把邮箱前缀改成一些有意义的，例如姓名的缩写之类的，这在邮箱设置里直接设置就好了，一定不要出现一些“中二”的邮箱名，例如“今夜无眠”之类的绝对不要出现。</p><p>有些同学问，需不需要挂个相片上去？其实，在抬头右侧空白部分，是可以挂上的。但是，我建议男生一率不要挂照片（当然如果你有吴彦祖的风彩当我没说），女生可以适当挂上证件照，前提是颜值是你的一大优势。</p><p>当然，一些国企事业单位会强制要求你贴上照片，那就贴好了。但也不要随便找一个白拍照就放上去了，找一家正规的照相馆，化好妆，照片精修后的效果肯定可以提高你在面试官那里的第一印象，这是好的开始。</p><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p>这块直接从最高学历写起，写到本科即可。包括时间，学位，学校，专业，排名这些信息。有些可以体现你实力的东西是可以备注上的，例如优秀毕业生，免试推荐研究生，这些是可以在挂号里备注上的。</p><p>有些人说，这样是不是太高调了？借用 caoz 的一句话：你矜持，你活该。</p><p>最后，关于排名，如果你是专业第一名，就直接写上；否则，就计算一下你的排名大概占比百分之多少。如果班级排名高，就按班级的排名来，如果学校排名高，就写学校的排名。总之，按最高的来写。研究生一般没有排名这个说法，那你就估个数好了，填上 Top 5%，一般没有问题。</p><p>这里教大家一个小技巧，你看前面贴出来的简历是不是排列得很整齐？让你自己动手做，你不一定排得这么整齐。教你一招：</p><img src="https://i.loli.net/2019/09/29/t9SsoYaLldkHziw.jpg"><p>通过表格，能自动地让文字对齐。写完之后，只需要将表格的边框设置为不可见就行了！深藏功与名！隐藏表格边框后的效果是这样的：</p><img src="https://i.loli.net/2019/09/29/BNpA5q8cmC6VT9w.jpg"><p>有没有惊艳到？如果你早就知道了这个技巧，当我没说。</p><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>如实写就好了，校招同学这一项可以写下实习经历，如果没有实习，这一项整体就不要了。社招同学不要在这上面弄虚作假，因为社招入职都会做尽调，被查出不诚信就尴尬了。</p><p>同样，可以用到上面提到的用表格排版的小技巧。</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p>找互联网工作的同学，一定刷过《剑指 offer》这本书，书里面的题在面试过程中出场率还是挺高的。但是，很多同学都只看了其中的题目部分，对于前两章可能就略读了，甚至直接跳过去了。其实，书的前两章是讲如何面试的，同样写得很精彩，值得细细研究。</p><p>咱们这篇文章不说面试，只说简历。但书里面有一个非常好的点 —— 描述项目的 STAR 模型：</p><img src="https://i.loli.net/2019/09/29/WjQuHUDaBYcyZ5d.jpg"><p>项目经历这一项按照这个模型来写就 OK 了。</p><p>先简述项目背景，为什么要做它，要简短、清晰，也就是 Situation；</p><p>再来说你负责哪一块，做了哪些有价值的工作，这一块要学会提炼，不能是简单的工作罗列，尽量让人觉得这是有技术含量的，包含 Task&amp;Action；</p><p>最后，就是这件事完成的效果如何，是性能提升了 100 倍还是从零到一完成了某个复杂的系统，关键在于你要用数字来表达。例如，我经过一系列的优化过程，使得系统响应时间缩短为原来的 50%，或者说响应时间提升 1 倍，平均响应时间达到 1 ms 等等。</p><p>举个例子来说：</p><img src="https://i.loli.net/2019/09/29/EUqwQ9Zo1ngLXBe.jpg"><p>最开始一行，项目的简要信息。首先 项目的起止时间，这个要斟酌一下，太长显得效率太低，太短可能又显得不深入。不是要教大家不诚信，这块适当“优化”下没太大问题；然后是 地点，可以是学校，也可以是公司，照实写；接着是 项目名，简短、清晰；最后是你的 角色，一般可以写项目总负责人，核心参与者，项目主导者等等，不要太浮夸，也不要太低下。</p><p>接着，项目介绍。主要是讲清楚你做这个事的背景是什么。注意，不能说“这是实验室项目要求”或者“老师指定我做的”，要写这个项目的背景，业界是个什么进展，本项目它能解决什么问题，价值在哪，这是应该写的。有些项目确实垃圾，但编也得编一个高大上的介绍，毕竟它代表了你的水平不是嘛？</p><p>接着，个人职责。先是概要的一句话，例如负责系统的整体架构，打上一个句号，这是总起，后面用更细致的话来解释。例如，充分调研市面上的相关系统，反复设计修改，设计出一套高可用、高性能、可扩展的系统架构。一般要列三点，多了太长，少了显得工作量少。所以，要挑选最重要的点来说，例如，设计并实现了某个算法，性能是之前的多少倍。</p><p>最后，项目成果。这块一定要挑最亮点的来说，而且一定要能用数字量化。常见的就是性能提升了多少倍，支持了多少并发，支持了多少用户，不可用时长为 0，发表文章专利多少篇……</p><p>重要词语、数字用加粗来突出显示。这些加粗就是你最擅长的点，也是面试官可能会问你。所以你想让他问你什么，就加粗吧！</p><h2 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h2><p>这一项比较好搞定，把你的技能罗列出来，注意是和工作相关的。你找互联网的工作，写上一句“熟悉 office 的操作”就不太合适了吧。可以写：熟练掌握常见的数据结构和算法，熟悉 C/C++，熟悉 mysql/codis/etcd/zookper……</p><p>英语听说读写能力也可以写上，例如“能熟练进行英文的听说读写”。</p><p>唯一需要注意的是，不要也不能写“精通”。“精通”是一个非常强的词，很少人能做到。这里并不是谦虚的问题，还涉及到一个预期管理的问题，也就是面对“精通”和“熟悉”，面试官对你的期待是不一样的。</p><p>如果你写上“熟悉 Golang”，那么当面试官问你一个比较深入的问题时（例如 Golang 的 map 是怎么进行扩容的），你答上来了，他会觉得你水平比较高，而且还很谦虚。相反，你写的是“精通 Golang”，面试过程中，只要有一个问题没答上，那是不是一下子印象就下去了？</p><p>还写人写“精通 C/C++”，要知道，就是 C++ 的作者，他也不能完全掌握 C++ 的特性啊，即使 C++ 编译器，也不是所有的特性它都支持。换句话说，即使是编译器，也不能说它精通 C++。</p><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>这一栏，可以展示你在工作技能之外的特性。例如，我看到有师兄这样写：</p><blockquote><p>高中班主任这样评价我：你是一个严于律己的人，一个精诚团结的人，一个志向远大的人。</p></blockquote><p>面试官可能会问：班主任为什么要这么评价？这时，他就掉入你提前挖好的“坑”，因为一个可以展示你优秀品质的故事正在等着他，这是你提前准备的已经演练了无数遍了。而且，面试进程也在你的掌握之中了。</p><p>注意，不要太多，也不要太浮夸，着重展示你是一个可以合作，善于沟通，工作积极的人。</p><h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><p>这块说一下其他未尽事项。</p><p>校招简历一般只要一页，就算你有再多内容要写，也只能压缩到一页，把那些最重要的，最能展示你能力的那部分内容保留下来，其他的干掉。</p><p>社招简历也不要超过两页，这样显得简练，展示的也都是高质量的项目，不能是简单的罗列，要总结升华。这样也可以打印到一页纸上，方便面试官，也就是方便你自己。</p><p>工作中，有一项非常重要的能力就是总结、提炼、升华。可能实验室的项目是一些企业的横向项目，就是 1+1=2 的事，非常简单，可能你觉得没啥可写的。这就是你发挥能力的时候了，从这些日常操作中，总结出一些高大上的东西来。如果不会，多参考一下优秀学长学姐的简历。</p><p>总之，你写到简历上的项目一定是经过总结升华的，这需要经过你无数次的修改。</p><p>还有一点要注意的是，发给别人的简历一定要是 pdf 格式，有些同学直接把 word 版 丟给别人，不同软件版本的电脑上可能会有兼容性问题啊，可能会有乱码，而且 word 版可能会被篡改。另外，打印简历的时候，也是要用 pdf 版本，不会出问题。</p><p>简历文件命名也是一个要注意的点。一般用 “码农桃花源-桃花源工作室-18888888888”，也就是“姓名-学校/公司-手机”这样的格式。这样，方便 HR 或者面试官联系你，因为只看文件名就能知道你的联系方式，和一些最重要的信息。再说一次，方便面试官就是方便你自己。</p><p>还有一个点，针对不同职位的简历应该是不一样的。这时，你可以把你的项目进行组合，不同职位的简历对应不同的项目组合，有的放矢。有些人会用 git 的不同分支维护不同的简历版本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简历是你的代表，无声代表你这个人；它也是一个面试索引，能引导面试官的提问。所以如果你特别擅长某个方面，一定要在简历上突出。这相当于给面试官“挖坑”，如果他进坑了，那问的问题一定要你早就烂熟于心的，因为那是你准备无数遍的精彩故事、优化案例。</p><p>这样，面试官整个过程都是受你的引导，在你的框框里，不知不觉，在你讲述你擅长内容的过程中，面试进程被你掌握了。面试官接下来的问题，也会是围绕你的回答、故事展开。</p><p><strong>简历模板</strong>:</p><p>你可以去<a href="https://uppez.github.io/Download/" target="_blank" rel="noopener">Download</a> 下载简历模板或者是去<a href="https://uppez.github.io/2019/09/29/简历制作/#more" target="_blank" rel="noopener">简历制作</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正所谓是金九银十，希望这个简历对所有人有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="简历" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>初识Numpy</title>
    <link href="http://yoursite.com/2019/09/28/%E5%88%9D%E8%AF%86Numpy/"/>
    <id>http://yoursite.com/2019/09/28/初识Numpy/</id>
    <published>2019-09-28T01:19:02.000Z</published>
    <updated>2019-09-29T11:15:15.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Numpy简介"><a href="#Numpy简介" class="headerlink" title="Numpy简介"></a>Numpy简介</h2><p>NumPy 是 Numerical Python 的简称，它是 Python 中的科学计算基本软件包。NumPy 为 Python 提供了大量数学库，使我们能够高效地进行数字计算。更多可点击<a href="http://www.numpy.org" target="_blank" rel="noopener">Numpy官网</a> 查看。</p><a id="more"></a><p>关于Numpy需要知道的几点：</p><ul><li><p>NumPy 数组在创建时有固定的大小，不同于Python列表（可以动态增长）。更改ndarray的大小将创建一个新的数组并删除原始数据。</p></li><li><p>NumPy 数组中的元素都需要具有相同的数据类型，因此在存储器中将具有相同的大小。数组的元素如果也是数组（可以是 Python 的原生 array，也可以是 ndarray）的情况下，则构成了多维数组。</p></li><li><p>NumPy 数组便于对大量数据进行高级数学和其他类型的操作。通常，这样的操作比使用Python的内置序列可能更有效和更少的代码执行。</p></li></ul><p>所以，Numpy 的核心是ndarray对象，这个对象封装了同质数据类型的n维数组。起名 ndarray 的原因就是因为是 n-dimension-array 的简写。接下来本节所有的课程都是围绕着ndarray来讲的，理论知识较少，代码量较多，所以大家在学习的时候，多自己动动手，尝试自己去运行一下代码。</p><h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><ul><li>由python list创建</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 1维数组</span></span><br><span class="line">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  </span><br><span class="line">print(type(a), a.shape, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>'&gt; <span class="hljs-params">(<span class="hljs-number">3</span>,)</span> 1 2 3</span></span><br><span class="line"><span class="hljs-class"></span></span><br><span class="line"><span class="hljs-class"># 重新赋值</span></span><br><span class="line">a[0] = 5                 </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2维数组</span></span><br><span class="line">b = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])   </span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</span><br><span class="line"> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]</span><br><span class="line"></span><br><span class="line">print(b[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><ul><li>由numpy内置函数创建</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 创建2x2的全0数组</span></span><br><span class="line">a = np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))  </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">0.</span>  <span class="hljs-number">0.</span>]</span><br><span class="line"> [ <span class="hljs-number">0.</span>  <span class="hljs-number">0.</span>]]</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment"># 创建1x2的全1数组</span></span><br><span class="line">b = np.ones((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))  </span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">1.</span>  <span class="hljs-number">1.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 创建2x2定值为7的数组</span></span><br><span class="line">c = np.full((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), <span class="hljs-number">7</span>) </span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">7</span> <span class="hljs-number">7</span>]</span><br><span class="line"> [<span class="hljs-number">7</span> <span class="hljs-number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 创建2x2的单位矩阵（对角元素为1）</span></span><br><span class="line">d = np.eye(<span class="hljs-number">2</span>)        </span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">1.</span>  <span class="hljs-number">0.</span>]</span><br><span class="line"> [ <span class="hljs-number">0.</span>  <span class="hljs-number">1.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个对角线为10,20,30,50的对角矩阵</span></span><br><span class="line">d_1 = np.diag([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>]) </span><br><span class="line">print(d_1)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">10</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</span><br><span class="line"> [ <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</span><br><span class="line"> [ <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30</span> <span class="hljs-number">0</span>]</span><br><span class="line"> [ <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">50</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的0-14的数组</span></span><br><span class="line">e = np.arange(<span class="hljs-number">15</span>)   </span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的4-9的数组</span></span><br><span class="line">e_1 = np.arange(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>)  </span><br><span class="line">print(e_1)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的1-13且以间隔为3的数组</span></span><br><span class="line">e_2 = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-number">3</span>)  </span><br><span class="line">print(e_2)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[ <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个一维的范围在0-10，长度为6的数组</span></span><br><span class="line">f = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>)  </span><br><span class="line">print(f)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="hljs-comment">#各个元素的间隔相等，为(10-0)/(6-1) = 2，若不想包含末尾的10，可以添加参数endpoint = False</span></span><br><span class="line">[ <span class="hljs-number">0.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">10.</span>]  </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#把arange创建的一维数组转换为3行4列的二维数组</span></span><br><span class="line">g = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)  </span><br><span class="line">print(g)                        </span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="hljs-comment">#注意：使用reshape转换前后的数据量应该相同，12 = 3x4</span></span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],              </span><br><span class="line"> [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line"> [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]              </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2x2的随机数组(矩阵),取值范围在[0.0,1.0)（包含0，不包含1）</span></span><br><span class="line">h = np.random.random((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) </span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[ <span class="hljs-number">0.72776966</span>  <span class="hljs-number">0.94164821</span>]</span><br><span class="line"> [ <span class="hljs-number">0.04652655</span>  <span class="hljs-number">0.2316599</span> ]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个取值范围在[4,15)，2行2列的随机整数矩阵</span></span><br><span class="line">i = np.random.randint(<span class="hljs-number">4</span>,<span class="hljs-number">15</span>,size = (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))  </span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">6</span>, <span class="hljs-number">5</span>],</span><br><span class="line"> [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建一个从均值为0，标准差为0.1的正态分布中随机抽样的3x3矩阵</span></span><br><span class="line">j = np.random.normal(<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>,size = (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))  </span><br><span class="line">print(j)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[<span class="hljs-number">-0.20783767</span>, <span class="hljs-number">-0.12406401</span>, <span class="hljs-number">-0.11775284</span>],</span><br><span class="line"> [ <span class="hljs-number">0.02037018</span>,  <span class="hljs-number">0.02898423</span>, <span class="hljs-number">-0.02548213</span>],</span><br><span class="line"> [<span class="hljs-number">-0.0149878</span> ,  <span class="hljs-number">0.05277648</span>,  <span class="hljs-number">0.08332239</span>]]</span><br></pre></td></tr></table></figure><h2 id="访问、删除、增加ndarray中的元素"><a href="#访问、删除、增加ndarray中的元素" class="headerlink" title="访问、删除、增加ndarray中的元素"></a>访问、删除、增加ndarray中的元素</h2><p>这里主要是提供了一些访问、更改或增加ndarray中某一元素的基础方法。</p><h3 id="访问-amp-修改"><a href="#访问-amp-修改" class="headerlink" title="访问&amp;修改"></a>访问&amp;修改</h3><p>类似于访问python list中元素的方式，按照元素的index进行访问或更改。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#访问某一元素，这里可以自己多尝试</span></span><br><span class="line"><span class="hljs-comment">#访问一维数组的某一元素，中括号内填写index</span></span><br><span class="line">print(np.arange(<span class="hljs-number">6</span>)[<span class="hljs-number">3</span>]) </span><br><span class="line">out:<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#访问二维数组的某一元素，中括号内填写[行,列]</span></span><br><span class="line">print(np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) </span><br><span class="line">out:<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#访问三位数组中的某一元素，中括号内[组，行，列]</span></span><br><span class="line">print(np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) </span><br><span class="line">out:<span class="hljs-number">3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#更改某一元素，用 = 进行赋值和替换即可</span></span><br><span class="line">a = np.arange(<span class="hljs-number">6</span>)</span><br><span class="line">a[<span class="hljs-number">3</span>] = <span class="hljs-number">7</span>      <span class="hljs-comment">#先访问，再重新赋值</span></span><br><span class="line">print(a)</span><br><span class="line">[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可使用np.delete(ndarray, elements, axis)函数进行删除操作。</p><p>这里需要注意的是axis这个参数，在2维数据中，axis = 0表示选择行，axis = 1表示选择列，但不能机械的认为0就表示行，1就表示列，注意前提<strong>2维数据</strong>中。</p><blockquote><p>在三维数据中，axis = 0表示组，1表示行，2表示列。这是为什么呢？提示一下，三位数组的shape中组、行和列是怎样排序的？</p></blockquote><p>所以，axis的赋值一定要考虑数组的shape。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span><br><span class="line"><span class="hljs-comment">#思考下，这里删除axis = 0下的第0个，会是什么结果呢？自己试一下</span></span><br><span class="line">print(np.delete(a,[<span class="hljs-number">0</span>],axis = <span class="hljs-number">0</span>))</span><br></pre></td></tr></table></figure><p>再有一点需要注意的是，如果你想让原数据保留删除后的结果，需要重新赋值一下才可以。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span><br><span class="line">np.delete(a,[<span class="hljs-number">0</span>],axis = <span class="hljs-number">0</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])  <span class="hljs-comment">#原数据并未更改</span></span><br><span class="line"></span><br><span class="line">a = np.delete(a,[<span class="hljs-number">0</span>],axis = <span class="hljs-number">0</span>)  <span class="hljs-comment">#重新赋值</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">array([[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])   <span class="hljs-comment">#原数据已更改</span></span><br></pre></td></tr></table></figure><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>往ndarray中增加元素的办法跟python list也很类似，常用的有两种：</p><ul><li><p>一种是添加（append），就是将新增的元素添加到ndarray的尾部</p></li><li><p>语法为：np.append(ndarray, elements, axis)</p></li><li><p>参数和delete函数一致，用法也一致，这里不再赘述</p></li><li><p>一种是插入（insert），可以让新增元素插入到指定位置</p></li><li><p>语法为：np.insert(ndarray, index, elements, axis)</p></li><li><p>参数中就多了一个index，指示的是插入新元素的位置。</p></li></ul><p>这里值得注意的是，不论是append还是insert，在往多维数组中插入元素时，一定要注意对应axis上的shape要一致。再一个就是，和delete一样，如果你想要更改原数据，需要重新赋值。</p><h2 id="切片和筛选"><a href="#切片和筛选" class="headerlink" title="切片和筛选"></a>切片和筛选</h2><h3 id="ndarray切片"><a href="#ndarray切片" class="headerlink" title="ndarray切片"></a>ndarray切片</h3><p>前面学了选择ndarray中的某个元素的方法，这里我们学习获取ndarray子集的方法——切片。</p><p>对于切片大家并不陌生，在list里面我们也接触过切片，一维的ndarray切片与list无异。需要注意的是，就是理解2维及多维ndarray切片。</p><ul><li>2维矩阵切片</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="hljs-number">4</span>*<span class="hljs-number">4</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]])</span><br><span class="line"></span><br><span class="line">a[:,:<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>],</span><br><span class="line">       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])</span><br></pre></td></tr></table></figure><p>这里可以看出，我们筛选了a矩阵中前三列的所有行，这是如何实现的呢？</p><p>切片的第一个元素:表示的是选择所有行，第二个元素:-1表示的是从第0列至最后一列（不包含），所以结果如上所示。</p><p>再看一个例子：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</span><br></pre></td></tr></table></figure><p>筛选的是第2-3行的所有列。</p><ul><li>一个常用的切片</li></ul><p>以列的形式获取最后一列数据：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a[:,<span class="hljs-number">3</span>:]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([[ <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">7</span>],</span><br><span class="line">       [<span class="hljs-number">11</span>],</span><br><span class="line">       [<span class="hljs-number">15</span>]])</span><br></pre></td></tr></table></figure><p>以一维数组的形式获取最后一列数据：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[:,<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">array([ <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>])</span><br></pre></td></tr></table></figure><p>上面两种方法经常会用到，前者的shape为(4,1)，后者为(4,)。</p><h3 id="ndarray筛选"><a href="#ndarray筛选" class="headerlink" title="ndarray筛选"></a>ndarray筛选</h3><ul><li>选择ndarray的对角线</li></ul><p>所用函数为np.diag(ndarray, k=N)，其中参数k的取值决定了按照哪一条对角线选择数据。</p><p>默认k = 0，取主对角线；</p><p>k = 1时，取主对角线上面1行的元素；</p><p>k = -1时，取主对角线下面1行的元素。</p><p><strong>思考</strong>：这个函数只能选择主对角线上的元素，那如果想要获取副对角线上的元素呢？</p><p>尝试自己搜索一下关键词numpy opposite diagonal寻找答案。</p><p>不建议你直接点getting the opposite diagonal of a numpy array。</p><ul><li>提取ndarray中的唯一值</li></ul><p>所用函数为np.unique(ndarray)，注意unique也可以添加参数axis来控制评判唯一值的轴方向，不好理解可以看示例：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#查看二维数组a中的唯一值</span></span><br><span class="line">a = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],</span><br><span class="line">     [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],</span><br><span class="line">     [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]</span><br><span class="line">print(np.unique(a))    </span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看a中的唯一行（也就是没有重复的行）</span></span><br><span class="line">print(np.unique(a,axis = <span class="hljs-number">0</span>))  </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看a中的唯一列</span></span><br><span class="line">print(np.unique(a,axis = <span class="hljs-number">1</span>))  </span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看a中第一行的唯一值</span></span><br><span class="line">print(np.unique(a[<span class="hljs-number">0</span>]))  </span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure><ul><li>通过布尔运算筛选</li></ul><p>这里在中括号中添加筛选条件，当该条件的结果为True时（即满足条件时），返回该值。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[X &gt; <span class="hljs-number">10</span>] <span class="hljs-comment">#筛选数组X中大于10的数据</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，当输入多个筛选条件时，&amp;表示与，|表示或，~表示非。</p><h2 id="运算与排序"><a href="#运算与排序" class="headerlink" title="运算与排序"></a>运算与排序</h2><h3 id="ndarray运算"><a href="#ndarray运算" class="headerlink" title="ndarray运算"></a>ndarray运算</h3><ul><li>集合运算</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.intersect1d(x,y) <span class="hljs-comment">#取x与y的交集</span></span><br><span class="line">np.setdiff1d(x,y)   <span class="hljs-comment">#取x与y的差集，返回的是在x中且没在y中的元素</span></span><br><span class="line">np.union1d(x,y)     <span class="hljs-comment">#取x与y的并集</span></span><br></pre></td></tr></table></figure><ul><li>算术运算<br>我们可以通过+、-、*、/或np.add、np.substract、np.multiply 、np.divide来对两个矩阵进行元素级的加减乘除运算，因为是元素级的运算，所以两个矩阵的shape必须要一致或者是可广播(Broadcast)。</li></ul><p>这里所谓的可广播，就是指虽然A和B两个矩阵的shape不一致，但是A可以拆分为整数个与B具有相同shape的矩阵，这样在进行元素级别的运算时，就会先将A进行拆分，然后与B进行运算，结果再组合一起就可以。这里的A就是“可广播”矩阵。</p><blockquote><p>上面涉及到的乘法是元素对应相乘，也就是点乘，那矩阵的叉乘呢？可以了解下numpy.matmul函数。</p></blockquote><h3 id="ndarray排序"><a href="#ndarray排序" class="headerlink" title="ndarray排序"></a>ndarray排序</h3><p>我们使用np.sort()和ndarray.sort()来对ndarray进行排序。</p><p>相同的是：</p><p>二者都可以使用参数axis来决定依照哪个轴进行排序，axis = 0时按照列排序，axis = 1时按照行排序；</p><p>不同的是：</p><p>np.sort()不会更改原数组；ndarray.sort()会更改原数组。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Numpy简介&quot;&gt;&lt;a href=&quot;#Numpy简介&quot; class=&quot;headerlink&quot; title=&quot;Numpy简介&quot;&gt;&lt;/a&gt;Numpy简介&lt;/h2&gt;&lt;p&gt;NumPy 是 Numerical Python 的简称，它是 Python 中的科学计算基本软件包。NumPy 为 Python 提供了大量数学库，使我们能够高效地进行数字计算。更多可点击&lt;a href=&quot;http://www.numpy.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Numpy官网&lt;/a&gt; 查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Numpy" scheme="http://yoursite.com/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>南大周志华关于论文内容演讲演示文稿</title>
    <link href="http://yoursite.com/2019/09/25/%E5%8D%97%E5%A4%A7%E5%91%A8%E5%BF%97%E5%8D%8E%E5%85%B3%E4%BA%8E%E8%AE%BA%E6%96%87%E5%86%85%E5%AE%B9%E6%BC%94%E8%AE%B2%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/"/>
    <id>http://yoursite.com/2019/09/25/南大周志华关于论文内容演讲演示文稿/</id>
    <published>2019-09-25T11:45:38.000Z</published>
    <updated>2019-09-25T11:49:48.903Z</updated>
    
    <content type="html"><![CDATA[<p>可以允许不完美，但不能不做~</p><a id="more"></a><ol><li><p>Oneindex下载：<a href="http://pan.sqdxwz.com/?/文档/" target="_blank" rel="noopener">http://pan.sqdxwz.com/?/文档/</a></p></li><li><p>蓝奏云下载：<a href="https://www.lanzous.com/i6ecpmj" target="_blank" rel="noopener">https://www.lanzous.com/i6ecpmj</a></p></li><li><p>网盘(提取码：21yg )备用下载：<a href="https://pan.baidu.com/s/1xXDe3QdrnoiAYojYLl2OuA" target="_blank" rel="noopener">https://pan.baidu.com/s/1xXDe3QdrnoiAYojYLl2OuA</a> </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以允许不完美，但不能不做~&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="周志华论文" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Mish:撼动深度学习ReLU激活函数的新继任者</title>
    <link href="http://yoursite.com/2019/09/25/Mish-%E6%92%BC%E5%8A%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0ReLU%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B0%E7%BB%A7%E4%BB%BB%E8%80%85/"/>
    <id>http://yoursite.com/2019/09/25/Mish-撼动深度学习ReLU激活函数的新继任者/</id>
    <published>2019-09-25T10:55:14.000Z</published>
    <updated>2019-09-25T11:10:41.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对激活函数的研究一直没有停止过，ReLU还是统治着深度学习的激活函数，不过，这种情况有可能会被Mish改变。</p></blockquote><a id="more"></a><p>Diganta Misra的一篇题为“Mish: A Self Regularized Non-Monotonic Neural Activation Function”的新论文介绍了一个新的深度学习激活函数，该函数在最终准确度上比Swish(+.494%)和ReLU(+ 1.671%)都有提高。</p><p>他们的小型FastAI团队使用Mish代替ReLU，打破了之前在FastAI全球排行榜上准确性得分记录的一部分。结合Ranger优化器，Mish激活，Flat + Cosine 退火和自注意力层，他们能够获得12个新的排行榜记录！</p><p><a href="https://sm.ms/image/PZMCh1OpjkRvYqf" target="_blank"><img src="https://i.loli.net/2019/09/25/PZMCh1OpjkRvYqf.jpg"></a></p><p>我们12项排行榜记录中的6项。每条记录都是用Mish而不是ReLU。(蓝色高亮显示，400 epoch的准确率为94.6，略高于我们的20 epoch的准确率为93.8:)</p><p>作为他们自己测试的一部分，对于ImageWoof数据集的5 epoch测试，他们说：</p><blockquote><p>Mish在高显著性水平上优于ReLU (P &lt; 0.0001)。(FastAI论坛@ Seb)</p></blockquote><p>Mish已经在70多个基准上进行了测试，包括图像分类、分割和生成，并与其他15个激活函数进行了比较。</p><h1 id="什么是Mesh"><a href="#什么是Mesh" class="headerlink" title="什么是Mesh"></a>什么是Mesh</h1><p>直接看Mesh的代码会更简单一点，简单总结一下，Mish=x * tanh(ln(1+e^x))。</p><p>其他的激活函数，ReLU是x = max(0,x)，Swish是x * sigmoid(x)。</p><p><strong>PyTorch的Mish实现</strong>：</p><p><a href="https://sm.ms/image/Ya4lGfdXjN3o2qH" target="_blank"><img src="https://i.loli.net/2019/09/25/Ya4lGfdXjN3o2qH.jpg"></a></p><p><strong>Tensorflow中的Mish函数</strong>：</p><p>Tensorflow：x = x *tf.math.tanh(F.softplus(x))</p><h1 id="Mish和其他的激活函数相比怎么样？"><a href="#Mish和其他的激活函数相比怎么样？" class="headerlink" title="Mish和其他的激活函数相比怎么样？"></a>Mish和其他的激活函数相比怎么样？</h1><p>下图显示了Mish与其他一些激活函数的测试结果。这是多达73个测试的结果，在不同的架构，不同的任务上：</p><p><a href="https://sm.ms/image/zrD2FSpymHT13s5" target="_blank"><img src="https://i.loli.net/2019/09/25/zrD2FSpymHT13s5.jpg"></a></p><h1 id="为什么Mish表现这么好？"><a href="#为什么Mish表现这么好？" class="headerlink" title="为什么Mish表现这么好？"></a>为什么Mish表现这么好？</h1><p>以上无边界(即正值可以达到任何高度)避免了由于封顶而导致的饱和。理论上对负值的轻微允许允许更好的梯度流，而不是像ReLU中那样的硬零边界。</p><p>最后，可能也是最重要的，目前的想法是，平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化。</p><p>尽管如此，我测试了许多激活函数，它们也满足了其中的许多想法，但大多数都无法执行。这里的主要区别可能是Mish函数在曲线上几乎所有点上的平滑度。</p><p>这种通过Mish激活曲线平滑性来推送信息的能力如下图所示，在本文的一个简单测试中，越来越多的层被添加到一个测试神经网络中，而没有一个统一的函数。随着层深的增加，ReLU精度迅速下降，其次是Swish。相比之下，Mish能更好地保持准确性，这可能是因为它能更好地传播信息：</p><p><a href="https://sm.ms/image/3udy29EoMmq8KwD" target="_blank"><img src="https://i.loli.net/2019/09/25/3udy29EoMmq8KwD.jpg"></a></p><p>更平滑的激活功能允许信息更深入地流动……注意，随着层数的增加，ReLU快速下降。</p><h1 id="如何把Mish放到你自己的网络中？"><a href="#如何把Mish放到你自己的网络中？" class="headerlink" title="如何把Mish放到你自己的网络中？"></a>如何把Mish放到你自己的网络中？</h1><p>Mish的PyTorch和FastAI的源代码可以在github的两个地方找到：</p><p>1、官方Mish github：<a href="https://github.com/digantamisra98/Mish" target="_blank" rel="noopener">https://github.com/digantamisra98/Mish</a></p><p>2、非官方的Mish使用inline提升速度：<a href="https://github.com/lessw2020/mish" target="_blank" rel="noopener">https://github.com/lessw2020/mish</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReLU有一些已知的弱点，但是通常它执行起来很轻，并且在计算上很轻。Mish具有较强的理论渊源，在测试中，就训练稳定性和准确性而言，Mish的平均性能优于ReLU。</p><p>复杂度只稍微增加了一点(V100 GPU和Mish，相对于ReLU，每epoch增加大约1秒)，考虑到训练稳定性的提高和最终精度的提高，稍微增加一点时间似乎是值得的。</p><p>最终，在今年测试了大量新的激活函数后，Mish在这方面处于领先地位，许多人怀疑它很有可能成为AI未来的新ReLU。</p><p>英文文章地址：<a href="https://medium.com/@lessw/meet-mish-new-state-of-the-art-ai-activation-function-the-successor-to-relu-846a6d93471f" target="_blank" rel="noopener">https://medium.com/@lessw/meet-mish-new-state-of-the-art-ai-activation-function-the-successor-to-relu-846a6d93471f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对激活函数的研究一直没有停止过，ReLU还是统治着深度学习的激活函数，不过，这种情况有可能会被Mish改变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法可视化平台</title>
    <link href="http://yoursite.com/2019/09/25/%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2019/09/25/算法可视化平台/</id>
    <published>2019-09-25T10:47:40.000Z</published>
    <updated>2019-09-25T11:10:00.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无疑，数据结构与算法学习最大的难点之一就是如何在脑中形象化其抽象的逻辑步骤。而图像在很多时候能够大大帮助我们理解其对应的抽象化的东西，而如果这个图像还是我们自己一点点画出来的，那么无疑这个印象是最深刻的了。没错，今天就是算法可视化的网站。</p><a id="more"></a><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ol><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li></ol><p>该网站特点:</p><ul><li><p>算法可视化</p></li><li><p>界面简洁直观</p></li><li><p>过程可控制</p></li></ul><ol start="2"><li><a href="https://visualgo.net/zh/" target="_blank" rel="noopener">https://visualgo.net/zh/</a></li></ol><p>该网站特点：</p><ul><li><p>算法可视化</p></li><li><p>文字讲解</p></li><li><p>复杂度备注</p></li><li><p>图形可操控调整</p></li></ul><ol start="3"><li><a href="https://algorithm-visualizer.org/" target="_blank" rel="noopener">https://algorithm-visualizer.org/</a></li></ol><p>该网站特点：</p><ul><li><p>算法可视化</p></li><li><p>有代码</p></li><li><p>有控制台输出帮助理解</p></li><li><p>算法种类丰富</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;无疑，数据结构与算法学习最大的难点之一就是如何在脑中形象化其抽象的逻辑步骤。而图像在很多时候能够大大帮助我们理解其对应的抽象化的东西，而如果这个图像还是我们自己一点点画出来的，那么无疑这个印象是最深刻的了。没错，今天就是算法可视化的网站。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="可视化" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>即学即用的30个python常用代码</title>
    <link href="http://yoursite.com/2019/09/24/%E5%8D%B3%E5%AD%A6%E5%8D%B3%E7%94%A8%E7%9A%8430%E4%B8%AApython%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/09/24/即学即用的30个python常用代码/</id>
    <published>2019-09-24T03:22:10.000Z</published>
    <updated>2019-09-24T03:27:36.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-检查重复元素"><a href="#1-检查重复元素" class="headerlink" title="1.检查重复元素"></a>1.检查重复元素</h2><p>下面的方法可以检查给定列表中是否有重复的元素。它使用了 set() 属性，该属性将会从列表中删除重复的元素。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">all_unique</span><span class="hljs-params">(lst)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> len(lst) == len(set(lst))  </span><br><span class="line">      </span><br><span class="line">x = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]    </span><br><span class="line">y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]    </span><br><span class="line">all_unique(x) <span class="hljs-comment"># False    </span></span><br><span class="line">all_unique(y) <span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-变位词"><a href="#2-变位词" class="headerlink" title="2.变位词"></a>2.变位词</h2><p>检测两个字符串是否互为变位词（即互相颠倒字符顺序）</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter   </span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anagram</span><span class="hljs-params">(first, second)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> Counter(first) == Counter(second)    </span><br><span class="line">anagram(<span class="hljs-string">"abcd3"</span>, <span class="hljs-string">"3acdb"</span>) <span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="3-检查内存使用情况"><a href="#3-检查内存使用情况" class="headerlink" title="3.检查内存使用情况"></a>3.检查内存使用情况</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> sys    </span><br><span class="line">variable = <span class="hljs-number">30</span>     </span><br><span class="line">print(sys.getsizeof(variable)) <span class="hljs-comment"># 24</span></span><br></pre></td></tr></table></figure><h2 id="4-字节大小计算"><a href="#4-字节大小计算" class="headerlink" title="4.字节大小计算"></a>4.字节大小计算</h2><p>以下方法将以字节为单位返回字符串长度。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byte_size</span><span class="hljs-params">(string)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span>(len(string.encode( utf<span class="hljs-number">-8</span> )))   </span><br><span class="line">     </span><br><span class="line">byte_size( 😀 ) <span class="hljs-comment"># 4    </span></span><br><span class="line">byte_size( Hello World ) <span class="hljs-comment"># 11</span></span><br></pre></td></tr></table></figure><h2 id="5-重复打印字符n次"><a href="#5-重复打印字符n次" class="headerlink" title="5.重复打印字符n次"></a>5.重复打印字符n次</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="hljs-number">2</span>; </span><br><span class="line">s =<span class="hljs-string">"Programming"</span>; print(s * n); </span><br><span class="line"><span class="hljs-comment"># ProgrammingProgramming</span></span><br></pre></td></tr></table></figure><h2 id="6-首字母大写"><a href="#6-首字母大写" class="headerlink" title="6.首字母大写"></a>6.首字母大写</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="hljs-string">"programming is awesome"</span>    </span><br><span class="line">print(s.title()) <span class="hljs-comment"># Programming Is Awesome</span></span><br></pre></td></tr></table></figure><h2 id="7-分块"><a href="#7-分块" class="headerlink" title="7.分块"></a>7.分块</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> ceil </span><br><span class="line">   </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chunk</span><span class="hljs-params">(lst, size)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> list(    </span><br><span class="line">        map(<span class="hljs-keyword">lambda</span> x: lst[x * size:x * size + size],    </span><br><span class="line">            list(range(<span class="hljs-number">0</span>, ceil(len(lst) / size)))))    </span><br><span class="line">chunk([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">2</span>) <span class="hljs-comment"># [[1,2],[3,4],5]</span></span><br></pre></td></tr></table></figure><h2 id="8-压缩"><a href="#8-压缩" class="headerlink" title="8.压缩"></a>8.压缩</h2><p>以下方法使用 fliter() 删除列表中的错误值（如：False, None, 0 和“”）</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compact</span><span class="hljs-params">(lst)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> list(filter(bool, lst))    </span><br><span class="line">compact([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>, <span class="hljs-number">2</span>,   , <span class="hljs-number">3</span>,  a ,  s , <span class="hljs-number">34</span>]) <span class="hljs-comment"># [ 1, 2, 3,  a ,  s , 34 ]</span></span><br></pre></td></tr></table></figure><h2 id="9-间隔数"><a href="#9-间隔数" class="headerlink" title="9.间隔数"></a>9.间隔数</h2><p>以下代码段可以用来转换一个二维数组。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [[ a ,  b ], [ c ,  d ], [ e ,  f ]]    </span><br><span class="line">transposed = zip(*array)    </span><br><span class="line">print(transposed) <span class="hljs-comment"># [( a ,  c ,  e ), ( b ,  d ,  f )]</span></span><br></pre></td></tr></table></figure><h2 id="10-链式比较"><a href="#10-链式比较" class="headerlink" title="10.链式比较"></a>10.链式比较</h2><p>以下代码可以在一行中用各种操作符进行多次比较。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-number">3</span>    </span><br><span class="line">print( <span class="hljs-number">2</span> &lt; a &lt; <span class="hljs-number">8</span>) <span class="hljs-comment"># True    </span></span><br><span class="line">print(<span class="hljs-number">1</span> == a &lt; <span class="hljs-number">2</span>) <span class="hljs-comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="11-逗号分隔"><a href="#11-逗号分隔" class="headerlink" title="11.逗号分隔"></a>11.逗号分隔</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hobbies = [<span class="hljs-string">"basketball"</span>, <span class="hljs-string">"football"</span>, <span class="hljs-string">"swimming"</span>]</span><br><span class="line">print(<span class="hljs-string">"My hobbies are: "</span> + <span class="hljs-string">", "</span>.join(hobbies)) <span class="hljs-comment"># My hobbies are: basketball, football, swimming</span></span><br></pre></td></tr></table></figure><h2 id="12-计算元音字母数"><a href="#12-计算元音字母数" class="headerlink" title="12.计算元音字母数"></a>12.计算元音字母数</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> re    </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_vowels</span><span class="hljs-params">(str)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> len(len(re.findall(r [aeiou] , str, re.IGNORECASE)))    </span><br><span class="line">count_vowels( foobar ) <span class="hljs-comment"># 3    </span></span><br><span class="line">count_vowels( gym ) <span class="hljs-comment"># 0</span></span><br></pre></td></tr></table></figure><h2 id="13-首字母恢复小写"><a href="#13-首字母恢复小写" class="headerlink" title="13.首字母恢复小写"></a>13.首字母恢复小写</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decapitalize</span><span class="hljs-params">(string)</span>:</span>    </span><br><span class="line">    <span class="hljs-keyword">return</span> str[:<span class="hljs-number">1</span>].lower() + str[<span class="hljs-number">1</span>:]    </span><br><span class="line">decapitalize( FooBar ) <span class="hljs-comment">#  fooBar     </span></span><br><span class="line">decapitalize( FooBar ) <span class="hljs-comment">#  fooBar</span></span><br></pre></td></tr></table></figure><h2 id="14-平面化"><a href="#14-平面化" class="headerlink" title="14.平面化"></a>14.平面化</h2><p>以下方法使用递归来展开潜在的深度列表。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spread</span><span class="hljs-params">(arg)</span>:</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:</span><br><span class="line">        <span class="hljs-keyword">if</span> isinstance(i, list):</span><br><span class="line">            ret.extend(i)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret.append(i)</span><br><span class="line">    <span class="hljs-keyword">return</span> ret</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deep_flatten</span><span class="hljs-params">(lst)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    result.extend(</span><br><span class="line">        spread(list(map(<span class="hljs-keyword">lambda</span> x: deep_flatten(x) <span class="hljs-keyword">if</span> type(x) == list <span class="hljs-keyword">else</span> x, lst))))</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line">deep_flatten([<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>], [[<span class="hljs-number">3</span>], <span class="hljs-number">4</span>], <span class="hljs-number">5</span>]) <span class="hljs-comment"># [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="15-差异"><a href="#15-差异" class="headerlink" title="15.差异"></a>15.差异</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">difference</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    set_a = set(a)</span><br><span class="line">    set_b = set(b)</span><br><span class="line">    comparison = set_a.difference(set_b)</span><br><span class="line">    <span class="hljs-keyword">return</span> list(comparison)</span><br><span class="line">difference([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]) <span class="hljs-comment"># [3]</span></span><br></pre></td></tr></table></figure><h2 id="16-寻找差异"><a href="#16-寻找差异" class="headerlink" title="16.寻找差异"></a>16.寻找差异</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">difference_by</span><span class="hljs-params">(a, b, fn)</span>:</span></span><br><span class="line">    b = set(map(fn, b))</span><br><span class="line">    <span class="hljs-keyword">return</span> [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> fn(item) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> b]</span><br><span class="line"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> floor</span><br><span class="line">difference_by([<span class="hljs-number">2.1</span>, <span class="hljs-number">1.2</span>], [<span class="hljs-number">2.3</span>, <span class="hljs-number">3.4</span>],floor) <span class="hljs-comment"># [1.2]</span></span><br><span class="line">difference_by([&#123;  x : <span class="hljs-number">2</span> &#125;, &#123;  x : <span class="hljs-number">1</span> &#125;], [&#123;  x : <span class="hljs-number">1</span> &#125;], <span class="hljs-keyword">lambda</span> v : v[ x ]) <span class="hljs-comment"># [ &#123; x: 2 &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="17-链式函数调用"><a href="#17-链式函数调用" class="headerlink" title="17.链式函数调用"></a>17.链式函数调用</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a + b</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subtract</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> a - b</span><br><span class="line">a, b = <span class="hljs-number">4</span>, <span class="hljs-number">5</span></span><br><span class="line">print((subtract <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> add)(a, b)) <span class="hljs-comment"># 9</span></span><br></pre></td></tr></table></figure><h2 id="18-检查重复元素"><a href="#18-检查重复元素" class="headerlink" title="18.检查重复元素"></a>18.检查重复元素</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_duplicates</span><span class="hljs-params">(lst)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> len(lst) != len(set(lst))</span><br><span class="line">    </span><br><span class="line">x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]</span><br><span class="line">y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</span><br><span class="line">has_duplicates(x) <span class="hljs-comment"># True</span></span><br><span class="line">has_duplicates(y) <span class="hljs-comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="19-合并两个字典"><a href="#19-合并两个字典" class="headerlink" title="19.合并两个字典"></a>19.合并两个字典</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_two_dicts</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">    c = a.copy()   <span class="hljs-comment"># make a copy of a </span></span><br><span class="line">    c.update(b)    <span class="hljs-comment"># modify keys and values of a with the ones from b</span></span><br><span class="line">    <span class="hljs-keyword">return</span> c</span><br><span class="line">a = &#123;  x : <span class="hljs-number">1</span>,  y : <span class="hljs-number">2</span>&#125;</span><br><span class="line">b = &#123;  y : <span class="hljs-number">3</span>,  z : <span class="hljs-number">4</span>&#125;</span><br><span class="line">print(merge_two_dicts(a, b)) <span class="hljs-comment"># &#123; y : 3,  x : 1,  z : 4&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#在python3.5版本后你还可以：</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_dictionaries</span><span class="hljs-params">(a, b)</span></span></span><br><span class="line">   return &#123;**a, **b&#125;</span><br><span class="line">a = &#123;  x : <span class="hljs-number">1</span>,  y : <span class="hljs-number">2</span>&#125;</span><br><span class="line">b = &#123;  y : <span class="hljs-number">3</span>,  z : <span class="hljs-number">4</span>&#125;</span><br><span class="line">print(merge_dictionaries(a, b)) <span class="hljs-comment"># &#123; y : 3,  x : 1,  z : 4&#125;</span></span><br></pre></td></tr></table></figure><h2 id="20-将两个列表转化成一个字典"><a href="#20-将两个列表转化成一个字典" class="headerlink" title="20.将两个列表转化成一个字典"></a>20.将两个列表转化成一个字典</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dictionary</span><span class="hljs-params">(keys, values)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> dict(zip(keys, values))</span><br><span class="line">    </span><br><span class="line">keys = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]    </span><br><span class="line">values = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line">print(to_dictionary(keys, values)) <span class="hljs-comment"># &#123; a : 2,  c : 4,  b : 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="21-使用枚举"><a href="#21-使用枚举" class="headerlink" title="21.使用枚举"></a>21.使用枚举</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下方法将字典作为输入，然后仅返回该字典中的键。</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> enumerate(list): </span><br><span class="line">    print(<span class="hljs-string">"Value"</span>, element, <span class="hljs-string">"Index "</span>, index, )</span><br><span class="line"><span class="hljs-comment"># ( Value ,  a ,  Index  , 0)</span></span><br><span class="line"><span class="hljs-comment"># ( Value ,  b ,  Index  , 1)</span></span><br><span class="line"><span class="hljs-comment">#( Value ,  c ,  Index  , 2)</span></span><br><span class="line"><span class="hljs-comment"># ( Value ,  d ,  Index  , 3)</span></span><br></pre></td></tr></table></figure><h2 id="22-计算需要的时间"><a href="#22-计算需要的时间" class="headerlink" title="22.计算需要的时间"></a>22.计算需要的时间</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">a = <span class="hljs-number">1</span></span><br><span class="line">b = <span class="hljs-number">2</span></span><br><span class="line">c = a + b</span><br><span class="line">print(c) <span class="hljs-comment">#3</span></span><br><span class="line">end_time = time.time()</span><br><span class="line">total_time = end_time - start_time</span><br><span class="line">print(<span class="hljs-string">"Time: "</span>, total_time)</span><br><span class="line"><span class="hljs-comment"># ( Time:  , 1.1205673217773438e-05)</span></span><br></pre></td></tr></table></figure><h2 id="23-Try-else指令"><a href="#23-Try-else指令" class="headerlink" title="23.Try else指令"></a>23.Try else指令</h2><p>你可以将 else 子句作为 try/except 块的一部分，如果没有抛出异常，则执行该子句。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    <span class="hljs-number">2</span>*<span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-keyword">except</span> TypeError:</span><br><span class="line">    print(<span class="hljs-string">"An exception was raised"</span>)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">"Thank God, no exceptions were raised."</span>)</span><br><span class="line"><span class="hljs-comment">#Thank God, no exceptions were raised.</span></span><br></pre></td></tr></table></figure><h2 id="24-查找最常见元素"><a href="#24-查找最常见元素" class="headerlink" title="24.查找最常见元素"></a>24.查找最常见元素</h2><p>以下方法返回列表中出现的最常见元素。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">most_frequent</span><span class="hljs-params">(list)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> max(set(list), key = list.count)</span><br><span class="line">  </span><br><span class="line">list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]</span><br><span class="line">most_frequent(list)</span><br></pre></td></tr></table></figure><h2 id="25-回文"><a href="#25-回文" class="headerlink" title="25.回文"></a>25.回文</h2><p>以下方法可检查给定的字符串是否为回文结构。该方法首先将字符串转换为小写，然后从中删除非字母数字字符。最后，它会将新的字符串与反转版本进行比较。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">palindrome</span><span class="hljs-params">(string)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">from</span> re <span class="hljs-keyword">import</span> sub</span><br><span class="line">    s = sub( [W_] ,   , string.lower())</span><br><span class="line">    <span class="hljs-keyword">return</span> s == s[::<span class="hljs-number">-1</span>]</span><br><span class="line">palindrome( taco cat ) <span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="26-没有-if-else-语句的简单计算器"><a href="#26-没有-if-else-语句的简单计算器" class="headerlink" title="26.没有 if-else 语句的简单计算器"></a>26.没有 if-else 语句的简单计算器</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> operator</span><br><span class="line">action = &#123;</span><br><span class="line">    <span class="hljs-string">"+"</span>: operator.add,</span><br><span class="line">    <span class="hljs-string">"-"</span>: operator.sub,</span><br><span class="line">    <span class="hljs-string">"/"</span>: operator.truediv,</span><br><span class="line">    <span class="hljs-string">"*"</span>: operator.mul,</span><br><span class="line">    <span class="hljs-string">"**"</span>: pow</span><br><span class="line">&#125;</span><br><span class="line">print(action[ - ](<span class="hljs-number">50</span>, <span class="hljs-number">25</span>)) <span class="hljs-comment"># 25</span></span><br></pre></td></tr></table></figure><h2 id="27-元素顺序打乱"><a href="#27-元素顺序打乱" class="headerlink" title="27.元素顺序打乱"></a>27.元素顺序打乱</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy</span><br><span class="line"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(lst)</span>:</span></span><br><span class="line">    temp_lst = deepcopy(lst)</span><br><span class="line">    m = len(temp_lst)</span><br><span class="line">    <span class="hljs-keyword">while</span> (m):</span><br><span class="line">        m -= <span class="hljs-number">1</span></span><br><span class="line">        i = randint(<span class="hljs-number">0</span>, m)</span><br><span class="line">        temp_lst[m], temp_lst[i] = temp_lst[i], temp_lst[m]</span><br><span class="line">    <span class="hljs-keyword">return</span> temp_lst</span><br><span class="line">  </span><br><span class="line">foo = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span><br><span class="line">shuffle(foo) <span class="hljs-comment"># [2,3,1] , foo = [1,2,3]</span></span><br></pre></td></tr></table></figure><h2 id="28-列表扁平化"><a href="#28-列表扁平化" class="headerlink" title="28.列表扁平化"></a>28.列表扁平化</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spread</span><span class="hljs-params">(arg)</span>:</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:</span><br><span class="line">        <span class="hljs-keyword">if</span> isinstance(i, list):</span><br><span class="line">            ret.extend(i)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret.append(i)</span><br><span class="line">    <span class="hljs-keyword">return</span> ret</span><br><span class="line">spread([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>],<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]) <span class="hljs-comment"># [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><h2 id="29-变量变换"><a href="#29-变量变换" class="headerlink" title="29.变量变换"></a>29.变量变换</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span><span class="hljs-params">(a, b)</span>:</span></span><br><span class="line">  <span class="hljs-keyword">return</span> b, a</span><br><span class="line">a, b = <span class="hljs-number">-1</span>, <span class="hljs-number">14</span></span><br><span class="line">swap(a, b) <span class="hljs-comment"># (14, -1)</span></span><br></pre></td></tr></table></figure><h2 id="30-获取确实键的默认值"><a href="#30-获取确实键的默认值" class="headerlink" title="30.获取确实键的默认值"></a>30.获取确实键的默认值</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; a : <span class="hljs-number">1</span>,  b : <span class="hljs-number">2</span>&#125;</span><br><span class="line">print(d.get( c , <span class="hljs-number">3</span>)) <span class="hljs-comment"># 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-检查重复元素&quot;&gt;&lt;a href=&quot;#1-检查重复元素&quot; class=&quot;headerlink&quot; title=&quot;1.检查重复元素&quot;&gt;&lt;/a&gt;1.检查重复元素&lt;/h2&gt;&lt;p&gt;下面的方法可以检查给定列表中是否有重复的元素。它使用了 set() 属性，该属性将会从列表中删除重复的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight python hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;all_unique&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(lst)&lt;/span&gt;:&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; len(lst) == len(set(lst))  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;all_unique(x) &lt;span class=&quot;hljs-comment&quot;&gt;# False    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;all_unique(y) &lt;span class=&quot;hljs-comment&quot;&gt;# True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python常用代码" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>The Game of Life</title>
    <link href="http://yoursite.com/2019/09/18/The-Game-of-Life/"/>
    <id>http://yoursite.com/2019/09/18/The-Game-of-Life/</id>
    <published>2019-09-18T14:47:02.000Z</published>
    <updated>2019-09-29T11:15:33.580Z</updated>
    
    <content type="html"><![CDATA[<p>#引言</p><p>Python 的 Matplotlib 是最常用的图表绘制以及数据可视化库。我们对折线图、柱状图以及热力图都比较熟悉，但你知道用 Matplotlib 还能做简单的动画吗？</p><a id="more"></a><p>下面就是用 Matplotlib 制作动画的例子。展示的是 John Conway 的 《The Game of Life》，这是一个 Metis（数据科学夏令营）中的编程挑战题目，同时给了我一个机会让我知道Matpltlib可以制作动图。看看结果的动图：</p><p><a href="https://sm.ms/image/CAmo9P5xGeOHMcR" target="_blank"><img src="https://i.loli.net/2019/09/18/CAmo9P5xGeOHMcR.gif"></a></p><p>这篇文章的重点还是主要放在 python 中如何用 Matploylib 制作动画。</p><p>但如果你不太熟悉模拟游戏的话（它更像是可以看的模拟动画，而非可以玩的游戏），我来给大家介绍一下规则：</p><ol><li><p>一开始先设置一个 N×N 的网格（我的动画中用的是 50×50 ）；</p></li><li><p>接着随机地向格子中填充“小细胞”（一开始随机地从 2500 个格子中选取 1500 个进行填充）；</p></li><li><p>如果邻居小细胞少于等于 1 个，那格子中的小细胞会死掉；</p></li><li><p>如果邻居大于等于 4 个的也会死掉；</p></li><li><p>只有 2 个或 3 个邻居时可以生存；</p></li><li><p>空的格子中如果正好有 3 个邻居，则会长出 1 个新的“小细胞”；</p></li></ol><p>通过对规则的阅读我最先想到的是：<a href="https://baike.sogou.com/v9062794.htm?fromTitle=生命游戏" target="_blank" rel="noopener">生命游戏</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>注意:</strong>我运行采用的是<strong>Anaconda3集成环境</strong>；程序运行<strong>两次</strong>，第一次营造运行环境，第二次运行程序输出。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> animation</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns</span><br><span class="line"><span class="hljs-keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Some helper functions</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Initialize the board with starting positions</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_board</span><span class="hljs-params">(pos_list, my_board)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> pos_list:</span><br><span class="line">        my_board[pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> my_board</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Make sure padded border values are always zero</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">force_pad_zero</span><span class="hljs-params">(my_board)</span>:</span></span><br><span class="line">    edge_row_0 = <span class="hljs-number">0</span></span><br><span class="line">    edge_row_1 = my_board.shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span></span><br><span class="line">    edge_col_0 = <span class="hljs-number">0</span></span><br><span class="line">    edge_col_1 = my_board.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> enumerate(my_board):</span><br><span class="line">        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:</span><br><span class="line">            row[:] = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> index == edge_row_1:</span><br><span class="line">            row[:] = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            row[edge_col_0] = <span class="hljs-number">0</span></span><br><span class="line">            row[edge_col_1] = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> my_board:</span><br><span class="line">        col[edge_row_0] = <span class="hljs-number">0</span></span><br><span class="line">        col[edge_row_1] = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">return</span> my_board</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Figure out the number of neighbors for a given cell</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_neighbors</span><span class="hljs-params">(row, col, my_board)</span>:</span></span><br><span class="line">    b = force_pad_zero(my_board)</span><br><span class="line">    num_neighbors = (b[row<span class="hljs-number">-1</span>,col<span class="hljs-number">-1</span>] + b[row+<span class="hljs-number">0</span>,col<span class="hljs-number">-1</span>] + b[row+<span class="hljs-number">1</span>,col<span class="hljs-number">-1</span>] + b[row+<span class="hljs-number">1</span>,col+<span class="hljs-number">0</span>] </span><br><span class="line">                   + b[row+<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>] + b[row+<span class="hljs-number">0</span>,col+<span class="hljs-number">1</span>] + b[row<span class="hljs-number">-1</span>,col+<span class="hljs-number">1</span>] + b[row<span class="hljs-number">-1</span>,col+<span class="hljs-number">0</span>])</span><br><span class="line">    <span class="hljs-keyword">return</span> num_neighbors</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Update the board based on the game rules, each call to update_board is one turn</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_board</span><span class="hljs-params">(my_board)</span>:</span></span><br><span class="line">    old_board = my_board.copy()</span><br><span class="line">    set_zero = []</span><br><span class="line">    set_one = []</span><br><span class="line">    <span class="hljs-comment"># Loop through board and update according to rules</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> enumerate(my_board[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>]):</span><br><span class="line">        <span class="hljs-keyword">for</span> j, col <span class="hljs-keyword">in</span> enumerate(row):</span><br><span class="line">            true_i = i + <span class="hljs-number">1</span></span><br><span class="line">            true_j = j + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment"># Update based on number of neighbors (using calc_neighbors)</span></span><br><span class="line">            <span class="hljs-comment"># set_zero and set_one are lists that tell me the coordinates of cells that require updating</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (((calc_neighbors(true_i, true_j, my_board) &lt;= <span class="hljs-number">1</span>) </span><br><span class="line">                  <span class="hljs-keyword">or</span> (calc_neighbors(true_i, true_j, my_board) &gt;= <span class="hljs-number">4</span>))</span><br><span class="line">                  <span class="hljs-keyword">and</span> my_board[true_i, true_j] != <span class="hljs-number">0</span>):</span><br><span class="line">                set_zero.append([true_i, true_j])</span><br><span class="line">            <span class="hljs-keyword">elif</span> ((calc_neighbors(true_i, true_j, my_board) == <span class="hljs-number">3</span>)</span><br><span class="line">                  <span class="hljs-keyword">and</span> my_board[true_i, true_j] == <span class="hljs-number">0</span>):</span><br><span class="line">                set_one.append([true_i, true_j])</span><br><span class="line">    <span class="hljs-comment"># Update the required cells</span></span><br><span class="line">    <span class="hljs-keyword">for</span> index, val <span class="hljs-keyword">in</span> enumerate(set_zero):</span><br><span class="line">        my_board[val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> index, val <span class="hljs-keyword">in</span> enumerate(set_one):</span><br><span class="line">        my_board[val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> my_board</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Input variables for the board</span></span><br><span class="line">boardsize = <span class="hljs-number">50</span>        <span class="hljs-comment"># board will be X by X where X = boardsize</span></span><br><span class="line">pad = <span class="hljs-number">2</span>               <span class="hljs-comment"># padded border, do not change this!</span></span><br><span class="line">initial_cells = <span class="hljs-number">1500</span>  <span class="hljs-comment"># this number of initial cells will be placed </span></span><br><span class="line">                      <span class="hljs-comment"># in randomly generated positions</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Get a list of random coordinates so that we can initialize </span></span><br><span class="line"><span class="hljs-comment"># board with randomly placed organisms</span></span><br><span class="line">pos_list = []</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(initial_cells):</span><br><span class="line">    pos_list.append([random.randint(<span class="hljs-number">1</span>, boardsize), </span><br><span class="line">                     random.randint(<span class="hljs-number">1</span>, boardsize)])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Initialize the board</span></span><br><span class="line">my_board = np.zeros((boardsize+pad, boardsize+pad))</span><br><span class="line">my_board = init_board(pos_list, my_board)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">##### Animate the board #####</span></span><br><span class="line"><span class="hljs-comment"># This will throw an error the first time you run the code, but the program will run properly if you</span></span><br><span class="line"><span class="hljs-comment"># execute the cell again (there is an error with the animation package that I cannot seem to get rid of)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Required line for plotting the animation</span></span><br><span class="line">%matplotlib notebook</span><br><span class="line"><span class="hljs-comment"># Initialize the plot of the board that will be used for animation</span></span><br><span class="line">fig = plt.gcf()</span><br><span class="line"><span class="hljs-comment"># Show first image - which is the initial board</span></span><br><span class="line">im = plt.imshow(my_board)</span><br><span class="line">plt.show()</span><br><span class="line">plt.savefig(fname=<span class="hljs-string">'game_of_life'</span>, dpi=<span class="hljs-number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Helper function that updates the board and returns a new image of</span></span><br><span class="line"><span class="hljs-comment"># the updated board animate is the function that FuncAnimation calls</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">animate</span><span class="hljs-params">(frame)</span>:</span></span><br><span class="line">    im.set_data(update_board(my_board))</span><br><span class="line">    <span class="hljs-keyword">return</span> im,</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># This line creates the animation</span></span><br><span class="line">anim = animation.FuncAnimation(fig, animate, frames=<span class="hljs-number">200</span>, </span><br><span class="line">                               interval=<span class="hljs-number">50</span>)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望这篇文章能帮到大家。在结束之前，让我来帮助大家脑补更多我们今天学到的动画功能在数据科学上的应用：</p><ul><li><p>一个个地画出蒙特卡洛模拟数据，你能观察到最终的分布是如何逐步形成的；</p></li><li><p>按顺序遍历时间序列数据，可以描绘你的模型或数据在新的观察角度下有什么表现；</p></li><li><p>当你改变输入参数时，比如族群数，可以展现你的算法是如何划分族群的；</p></li><li><p>根据时间或不同的数据子集生成关联热力图，用于观察不同的样本是如何影响你的模型的预期参数的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#引言&lt;/p&gt;
&lt;p&gt;Python 的 Matplotlib 是最常用的图表绘制以及数据可视化库。我们对折线图、柱状图以及热力图都比较熟悉，但你知道用 Matplotlib 还能做简单的动画吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="生命游戏" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>镜像站</title>
    <link href="http://yoursite.com/2019/09/18/%E9%95%9C%E5%83%8F%E7%AB%99/"/>
    <id>http://yoursite.com/2019/09/18/镜像站/</id>
    <published>2019-09-18T14:38:20.000Z</published>
    <updated>2019-09-28T01:36:17.397Z</updated>
    
    <content type="html"><![CDATA[<p>网易镜像：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></p><p>阿里云镜像：<a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a></p><a id="more"></a><p>中国科学技术大学镜像：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p><p>厦门大学镜像：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a></p><p>搜狐镜像：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></p><p>北京交通大学镜像：<a href="http://mirror.bjtu.edu.cn/" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn/</a></p><p>北京理工大学镜像：<a href="http://mirror.bit.edu.cn/web/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/web/</a></p><p>兰州大学镜像：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a></p><p>上海交通大学镜像：<a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a></p><p>清华大学镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>东北大学镜像：<a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a></p><p>浙江大学镜像：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></p><p>东软信息学院：<a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a></p><p>重庆大学镜像：<a href="http://mirrors.cqu.edu.cn/" target="_blank" rel="noopener">http://mirrors.cqu.edu.cn/</a></p><p>大连理工大学镜像：<a href="http://mirror.dlut.edu.cn/" target="_blank" rel="noopener">http://mirror.dlut.edu.cn/</a></p><p>CN99镜像：<a href="http://mirrors.cn99.com/" target="_blank" rel="noopener">http://mirrors.cn99.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网易镜像：&lt;a href=&quot;http://mirrors.163.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.163.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云镜像：&lt;a href=&quot;http://mirrors.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="镜像" scheme="http://yoursite.com/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>AI领域区分介绍</title>
    <link href="http://yoursite.com/2019/09/15/AI%E9%A2%86%E5%9F%9F%E5%8C%BA%E5%88%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/09/15/AI领域区分介绍/</id>
    <published>2019-09-15T09:42:11.000Z</published>
    <updated>2019-09-17T03:21:43.579Z</updated>
    
    <content type="html"><![CDATA[<p>说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。<a id="more"></a>例如京东会根据你的浏览行为和用户的相似性，利用算法为你推荐你需要的产品；又比如美颜相机，会基于你面部特征的分析，通过算法精细你的美颜效果。还有众所周知的谷歌DeepMind，当AlphaGo打败了韩国职业围棋高手Lee Se-dol时，媒体描述这场人机对战的时候，提到了人工智能AI、机器学习、深度学习等术语。没错，这三项技术都为AlphaGo的胜利立下了汗马功劳，然而它们并不是一回事。</p><p>人工智能和机器学习的同时出现，机器学习和深度学习的交替使用……使大部分读者雾里看花，这些概念究竟有何区别，我们可以通过下面一个关系图来进行区分。</p><p><img src="https://i.loli.net/2019/08/31/fmbgJWRBzT5hMI4.jpg" alt="1.jpg"></p><center>图一：人工智能、机器学习、深度学习的关系</center><p>人工智能包括了机器学习和深度学习，机器学习包括了深度学习。人工智能是机器学习的父类，机器学习则是深度学习的父类。</p><p>人工智能（Artificial Intelligence，AI）是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的与人类智能相似的方式作出反应的智能机器，它不是人的智能，但能像人那样思考、也可能超过人的智能。</p><p>人工智能实际应用：机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。人工智能目前也分为：强人工智能(BOTTOM-UPAI)和弱人工智能(TOP-DOWNAI)。</p><p>机器学习（Machine Learning，ML）是人工智能的核心，属于人工智能的一个分支。机器学习是指从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法，所以机器学习的核心是数据、算法（模型）、算力（计算机运算能力）。</p><p>机器学习应用领域：数据挖掘、数据分类、计算机视觉、自然语言处理(NLP)、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用等。</p><p>深度学习（Deep Learning，DL）：是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据。</p><p>数据挖掘（Data Mining，DM），顾名思义是指利用机器学习技术从海量数据中“挖掘”隐藏信息，主要应用于图像、声音、文本。在商业环境中，企业希望让存放在数据库中的数据能“说话”，支持决策。所以数据挖掘更偏向于应用。</p><p><img src="https://i.loli.net/2019/08/31/uHUkLpMN87ZtrYV.jpg" alt="2.jpg"></p><center>图二：数据挖掘与机器学习的关系</center><p>机器学习是数据挖掘的一种重要方法，但机器学习是另一门学科，并不从属于数据挖掘，二者相辅相成。数据挖掘是机器学习和数据库的交叉，主要利用机器学习提供的技术来分析海量数据，利用数据库界提供的技术来管理海量数据。</p><p>不管是人工智能、机器学习、深度学习还是数据挖掘，目前都在解决共同目标时发挥了自己的优势，并为社会生产和人类生活提供便利，帮助我们探索过去、展示现状、预测未来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>为Anaconda3安装tensorflow等</title>
    <link href="http://yoursite.com/2019/09/15/%E4%B8%BAAnaconda3%E5%AE%89%E8%A3%85tensorflow%E7%AD%89/"/>
    <id>http://yoursite.com/2019/09/15/为Anaconda3安装tensorflow等/</id>
    <published>2019-09-15T09:39:38.000Z</published>
    <updated>2019-09-29T11:14:57.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda3介绍"><a href="#Anaconda3介绍" class="headerlink" title="Anaconda3介绍"></a>Anaconda3介绍</h1><p>简单来说，Anaconda是Python的包管理器和环境管理器。</p><p>先来解决一个初学者都会问的问题：我已经安装了Python，那么为什么还需要Anaconda呢？原因有以下几点：</p><a id="more"></a><ol><li><p>Anaconda附带了一大批常用数据科学包，它附带了conda、Python和 150 多个科学包及其依赖项。因此你可以用Anaconda立即开始处理数据。</p></li><li><p>管理包。Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这些包，包括安装、卸载和更新包。</p></li><li><p>管理环境。为什么需要管理环境呢？比如你在A项目中用到了Python2，而新的项目要求使用Python3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候conda就可以帮助你为不同的项目建立不同的运行环境。还有很多项目使用的包版本不同，比如不同的pandas版本，不可能同时安装两个pandas版本。你要做的应该是在项目对应的环境中创建对应的pandas版本。这时候conda就可以帮你做到。</p></li></ol><h1 id="Anaconda3的安装"><a href="#Anaconda3的安装" class="headerlink" title="Anaconda3的安装"></a>Anaconda3的安装</h1><ol><li><a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/" target="_blank" rel="noopener">清华镜像</a></li></ol><p>关于安装过程中的细节,如全局变量设置…可自行百度,下面我们转入正题</p><h1 id="Anaconda3安装tensorflow"><a href="#Anaconda3安装tensorflow" class="headerlink" title="Anaconda3安装tensorflow"></a>Anaconda3安装tensorflow</h1><ol><li><p>打开anaconda安装时自带的Anaconda prompt</p></li><li><p>打开后,输入清华镜像的tensorflow的下载地址(如果你已经在墙外翱翔了,可以省略这一步):</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>接着我们开始创建一个python3.6的环境,因为如果你安装的是最新的anaconda,它默认环境为py3.7,并且在不久之前,tensorflow已经开始支持py3.6,所以我们创建一个py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=3.6</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>启动anaconda中的py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow</span><br></pre></td></tr></table></figure></li></ol><p>如果不能进入,则重新执行第3步骤</p><ol start="5"><li>进入py3.6的环境中后,我们就可以进行安装了(此处我们安装的是CPU版本的tensorflow):<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade --ignore-installed tensorflow</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>当我们不使用tensorflow时,我们就可以使用:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></li></ol><p> 退出该环境</p><ol start="7"><li>开始测试一下是否安装成功:</li></ol><p>重新打开Anaconda Prompt—&gt;activate tensorflow—&gt;python来启动tensorflow，并进入python环境<br> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#TensorFlow使用图(Graph)来表示计算任务；并使用会话(Session)来执行图，通过Session.close()来关闭会话（这是一种显式关闭会话的方式）。会话方式有显式和隐式会话之分。</span></span><br><span class="line"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="hljs-string">'Hello, TensorFlow!'</span>)  <span class="hljs-comment">#初始化一个TensorFlow的常量</span></span><br><span class="line">sess = tf.Session()  <span class="hljs-comment">#启动一个会话</span></span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></p><p>如果可以准确的输出结果,那么恭喜你,安装tensorflow成功!</p><h1 id="Anaconda3安装pytorch"><a href="#Anaconda3安装pytorch" class="headerlink" title="Anaconda3安装pytorch"></a>Anaconda3安装pytorch</h1><ol><li><p>打开anaconda安装时自带的Anaconda prompt</p></li><li><p>创建py3.6环境:</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=3.6</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>启动anaconda中的py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pytorch</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>PyTorch 的官网提供了简单的安装方法，只需简单的命令即可。</li></ol><p>首先，打开 PyTorch 官网安装页面（需自备梯子）：<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">https://pytorch.org/get-started/locally/</a></p><p>然后复制页面中Run this Command后的代码,粘贴在你的命令行,等待安装完成就可以了~</p><h1 id="Anaconda3安装keras"><a href="#Anaconda3安装keras" class="headerlink" title="Anaconda3安装keras"></a>Anaconda3安装keras</h1><p>其实keras是可以与tensorflow在共同环境下使用的,所以我们可以直接将keras安装在我们的tensorflow环境中。</p><ol><li><p>打开anaconda安装时自带的Anaconda prompt</p></li><li><p>创建py3.6环境:</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=3.6</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>启动anaconda中的py3.6环境:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>直接运行命令:<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install keras</span><br><span class="line">或者</span><br><span class="line">pip install keras</span><br></pre></td></tr></table></figure></li></ol><p> 等待安装完成即可~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Anaconda3介绍&quot;&gt;&lt;a href=&quot;#Anaconda3介绍&quot; class=&quot;headerlink&quot; title=&quot;Anaconda3介绍&quot;&gt;&lt;/a&gt;Anaconda3介绍&lt;/h1&gt;&lt;p&gt;简单来说，Anaconda是Python的包管理器和环境管理器。&lt;/p&gt;
&lt;p&gt;先来解决一个初学者都会问的问题：我已经安装了Python，那么为什么还需要Anaconda呢？原因有以下几点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Anaconda" scheme="http://yoursite.com/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>关于论文作者那点事</title>
    <link href="http://yoursite.com/2019/09/15/%E5%85%B3%E4%BA%8E%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/09/15/关于论文作者那点事/</id>
    <published>2019-09-15T09:37:21.000Z</published>
    <updated>2019-09-28T01:38:50.948Z</updated>
    
    <content type="html"><![CDATA[<p>对于论文想必大家可能都有过耳闻,今天做一下一些相关知识的普及~</p><a id="more"></a><p>首先,第一作者和通讯作者之间一直是缠缠绵绵到天涯的关系，很多人对这两者并不陌生，但是在一些细节上的问题又感觉比较绕，我今天特意收集了平时大家提到的关于两者之间的一些问题，做成问答集锦，你想知道的，都在里面啦~</p><h1 id="什么是第一作者？"><a href="#什么是第一作者？" class="headerlink" title="什么是第一作者？"></a>什么是第一作者？</h1><p>第一作者通常主导大部分的实验工作，在一般的情况下，引用一篇论文时，提到的就是第一作者的名字，如 Tomas et al. report that…。</p><p>以第一作者的身份进行论文发表对博士生的科研路是很重要的，不止中国，全球大部分的博士毕业标准都要求学生要作为第一作者发表至少一篇论文。</p><p>对博士后及资深教授来说，作为第一作者的期刊论文发表是争取基金、职称晋升及续聘时的重要因素。据此，期刊论文的作者名单里，第一个名字一直是最抢手的位置。</p><p>在第一作者之后，作者顺序是根据对研究的贡献度排序，贡献度越高的排名越前。不过，有时候可能会有多位作者贡献度相同，这时候就可以列为共同一作、共同二作…</p><p><strong>注意:</strong>第一作者很重要很重要很重要，要毕业、评职称、争基金…没头发可以，没它不行~</p><h1 id="什么是通讯作者？"><a href="#什么是通讯作者？" class="headerlink" title="什么是通讯作者？"></a>什么是通讯作者？</h1><p>通讯作者是课题的总负责人，承担课题的经费、设计、文章的书写和把关，在投稿、同行评审和整个发表流程中负责和期刊沟通。从知识产权的角度来说，研究成果算是通讯作者的。能当通讯作者的人一般有以下几类：</p><ul><li>论文的法定负责人:</li></ul><p>通讯作者也是论文的主要受益人之一。也可以这么说，论文的第一作者是这项科研成果的主要贡献者，而论文的通讯作者是这项成果的责任者和受益人。</p><ul><li>导师、教授、科研项目的主要负责人</li></ul><p>其主要贡献是提供研究指导、研究经费、试验场所、实验室、仪器设备等与实验相关的物质资源。</p><ul><li>论文的任何作者</li></ul><p>要是一篇论文有数个作者，通讯作者可以是他们中的任何一位。至于到底是谁，主要看通讯作者在这项研究中真正起的作用和做出的贡献。要是他在整个实验中做到了关键的作用，那么他就理所当然地即可做第一作者，也可做通讯作者。</p><p><strong>注意:</strong></p><p>对于学生来说，通讯作者一般是他的导师。</p><p>对于研究机构来说，通讯作者一般是项目负责人。</p><p>对于出版机构来说，通讯作者可以是机构老板。</p><p>另外！！！一定要有固定的通讯地址！</p><h1 id="第一作者和通讯作者，谁更重要？"><a href="#第一作者和通讯作者，谁更重要？" class="headerlink" title="第一作者和通讯作者，谁更重要？"></a>第一作者和通讯作者，谁更重要？</h1><p>通讯作者未必是第一作者，但第一作者可以是通讯作者。通讯作者多数情况和第一作者是同一个人，只有在通讯作者和第一作者不一致的时候，才有必要在文章脚注中附加通讯作者的标识。</p><p>所以，总的来说都重要！对于作者来说，第一作者很重要，谁是通讯作者没关系，但是通讯单位很关键，很多单位评职称看通讯单位，不看通讯作者。对于导师来说，通讯作者重要，因为导师永远当通讯作者，至于谁是第一作者不重要。对于出版机构来说，通讯作者非常重要，因为机构老板也常是通讯作者…</p><p><strong>注意:</strong>通讯作者不是随便挂的，一旦出现通讯作者，这篇文章的科研版权就要非常注意了~</p><h1 id="共同一作排序重要吗，会影响评职称吗？"><a href="#共同一作排序重要吗，会影响评职称吗？" class="headerlink" title="共同一作排序重要吗，会影响评职称吗？"></a>共同一作排序重要吗，会影响评职称吗？</h1><p>共同作者排在第一位的是最好，所有东西都可以申请。因为排第一的肯定是第一作者，大家引用的时候都会缩写成“First-Author, et al，但是排在第二位就要小心了，排在第二位的虽然也是共同第一作者，但是有些单位只看第一位的，所以评职称的时候一定要问清楚单位科研处排在第二的共同作者能否评职称。</p><p>不过事无绝对，以下一些例子里面的共同一作和第一作者的贡献量和含金量差不多，排序嘛，就比较随便了···</p><ol><li>按作者名字的字母顺序决定作者排序</li></ol><p><a href="https://sm.ms/image/NpaYABfEITyMwt5" target="_blank"><img src="https://i.loli.net/2019/08/17/NpaYABfEITyMwt5.jpg"></a></p><ol start="2"><li>抛硬币决定作者顺序</li></ol><p><a href="https://sm.ms/image/ZyXo9RD1WfUMC7N" target="_blank"><img src="https://i.loli.net/2019/08/17/ZyXo9RD1WfUMC7N.jpg"></a></p><ol start="3"><li>根据对星战的痴迷程度决定作者顺序</li></ol><p><a href="https://sm.ms/image/PMtcUr7h4k1nfLl" target="_blank"><img src="https://i.loli.net/2019/08/17/PMtcUr7h4k1nfLl.jpg"></a></p><ol start="4"><li>根据申tenure的时间远近决定作者顺序</li></ol><p><a href="https://sm.ms/image/UKyMEtvofZhA4QO" target="_blank"><img src="https://i.loli.net/2019/08/17/UKyMEtvofZhA4QO.jpg"></a></p><p><strong>注意:</strong>国内对作者排序还是很重视的，很多机构和单位甚至只认可排序靠前的，所以能排前面就别排后面啦~</p><h1 id="所有的论文都要有通讯作者吗？"><a href="#所有的论文都要有通讯作者吗？" class="headerlink" title="所有的论文都要有通讯作者吗？"></a>所有的论文都要有通讯作者吗？</h1><p>并不是要求所有的论文都一定要写通讯作者。对于没有通讯作者的稿件，默认第一作者为通讯作者。</p><p>通讯作者多数情况和第一作者是同一个人，这样的话实际上是省略了通讯作者。只有在通讯作者和第一作者不一致的时候，才有必要加通讯作者。不赞成一味地模仿国外杂志，加不加通讯作者应根据需要而定。</p><p><strong>注意:</strong>通讯作者非必须，随意模仿不可取~</p><h1 id="我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？"><a href="#我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？" class="headerlink" title="我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？"></a>我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？</h1><p>目前，最常见的做法是权力最大的排最后，权力排倒数第二，也就是大老板排最后，小老板排倒数第二。一般期刊只能允许两位通讯作者，在文章中标注，列出他们的邮箱，偶尔也会看见有些期刊会有三个通讯，不过也有些期刊不准共同通讯，只能一个人。所以在投稿前一定要仔细阅读稿约。</p><p><strong>注意:</strong>根据权力大小排就对了！</p><h1 id="导师可以既是第一作者，又是通讯作者吗？"><a href="#导师可以既是第一作者，又是通讯作者吗？" class="headerlink" title="导师可以既是第一作者，又是通讯作者吗？"></a>导师可以既是第一作者，又是通讯作者吗？</h1><p>可以。第一作者兼任通讯作者没什么问题，更何况，对单一作者的论文来说，第一作者和通讯作者肯定是同一个人。如果你的教授对研究也出谋划策，拟出初始计划和研究设计，一定要将他列为共同作者。至于具体怎么做，还是需要跟导师商量，达成一致，避免日后产生争议。</p><p><strong>注意:</strong>导师可以既当第一作者，又当通讯作者。</p><h1 id="论文被接受，还能更换作者顺序和通讯作者吗？"><a href="#论文被接受，还能更换作者顺序和通讯作者吗？" class="headerlink" title="论文被接受，还能更换作者顺序和通讯作者吗？"></a>论文被接受，还能更换作者顺序和通讯作者吗？</h1><p>一般来说，期刊对于作者顺序变更不会有太大的意见，但非必要最好避免更换通讯作者，因为期刊编辑和通讯作者之间已经有过交流，有一定的熟悉程度。</p><p>不过，如果有不可抗拒的因素需要换通讯作者跟作者顺序的话，一定要跟编辑沟通解释清楚，因为这会涉及到之后的一系列问题，例如评职称、申奖金等等。另外，修改作者的时候，一定要附上新的版权~</p><p><strong>注意:</strong>作者顺序可以改，通讯作者最好不要改！</p><h1 id="不是通讯作者可以直接和期刊编辑联系吗？"><a href="#不是通讯作者可以直接和期刊编辑联系吗？" class="headerlink" title="不是通讯作者可以直接和期刊编辑联系吗？"></a>不是通讯作者可以直接和期刊编辑联系吗？</h1><p>通讯作者的作用就是期刊编辑最主要的联系窗口，相关的沟通事宜都是通讯作者负责，不是通讯作者最好不要和期刊编辑联系，为避免将事情复杂化，最好是将事情积极反馈给通讯作者，再由通讯作者和期刊编辑沟通。</p><p><strong>注意:</strong>让通讯作者架起沟通的桥梁~</p><h1 id="论文被查出学术不端，负责的应该是第一作者还是通讯作者？"><a href="#论文被查出学术不端，负责的应该是第一作者还是通讯作者？" class="headerlink" title="论文被查出学术不端，负责的应该是第一作者还是通讯作者？"></a>论文被查出学术不端，负责的应该是第一作者还是通讯作者？</h1><p>通讯作者是要对论文的全程进行把关的。特别是对里面内容的真实性，论证的根据等，有没有达到发表的水平。所以，通讯作者，既是一个署名权，更重要的是对这篇学术论文承担的责任。如果这篇文章出问题，通讯作者是第一责任人！当然那些没有被告知，就被别人列为论文的通讯作者，还是会有背黑锅的时候···</p><p><strong>注意:</strong>通讯作者负责就要负到底！</p><h1 id="让有名望的学者当通讯作者是不是能增加论文的投中率？"><a href="#让有名望的学者当通讯作者是不是能增加论文的投中率？" class="headerlink" title="让有名望的学者当通讯作者是不是能增加论文的投中率？"></a>让有名望的学者当通讯作者是不是能增加论文的投中率？</h1><p>如果在学术界口碑好、有名望教授当自己论文的通讯作者，会增加论文的投中率。因为通讯作者需要对论文把关，好口碑的教授一般学风严谨，出任通讯作者也是以自己的名誉来做担保，所以编辑在审查的时候，也会增加对论文的好感度，最后能不能投中关键的还是看论文的质量。</p><p><strong>注意:</strong>论文能不能投中关键还是靠质量~</p><p>最后,提醒一下大家：<strong>研究项目启动前是决定署名作者及其排名顺序的最佳时机</strong>，参与项目的团队成员必须在这些方面达成完全一致，毕竟按劳所得是亘古不变的真理~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于论文想必大家可能都有过耳闻,今天做一下一些相关知识的普及~&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>机器学习分类算法</title>
    <link href="http://yoursite.com/2019/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/12/机器学习分类算法/</id>
    <published>2019-09-12T12:10:45.000Z</published>
    <updated>2019-09-17T03:22:30.083Z</updated>
    
    <content type="html"><![CDATA[<p>说起分类算法，相信学过机器学习的同学都能侃上一二。</p><p>可是，你能够如数家珍地说出所有常用的分类算法，以及他们的特征、优缺点吗？比如说，你可以快速地回答下面的问题么:</p><a id="more"></a><ul><li><p>KNN算法的优缺点是什么？</p></li><li><p>Naive Bayes算法的基本假设是什么？</p></li><li><p>entropy loss是如何定义的？</p></li><li><p>最后，分类算法调参常用的图像又有哪些？</p></li></ul><p>可能真的涉及这些问题时候，我们不能快速的回答，所以我总结了此文~</p><p>机器学习是一种能从数据中学习的计算机编程科学以及艺术，就像下面这句话说得一样。</p><blockquote><p>机器学习是使计算机无需显式编程就能学习的研究领域。——阿瑟·塞缪尔，1959年</p></blockquote><p>不过还有一个更好的定义：</p><blockquote><p>“如果一个程序在使用既有的经验（E）执行某类任务（T）的过程中被认为是“具备学习能力的”，那么它一定需要展现出:利用现有的经验（E），不断改善其完成既定任务（T）的性能（P）的特性。” ——Tom Mitchell, 1997</p></blockquote><p>例如，你的垃圾邮件过滤器是一个机器学习程序，通过学习用户标记好的垃圾邮件和常规非垃圾邮件示例，它可以学会标记垃圾邮件。系统用于学习的示例称为训练集。在此案例中，任务（T）是标记新邮件是否为垃圾邮件，经验（E）是训练数据，性能度量（P） 需要定义。例如，你可以定义正确分类的电子邮件的比例为P。这种特殊的性能度量称为准确度，这是一种有监督的学习方法，常被用于分类任务。</p><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>在监督学习中，算法从有标记数据中学习。在理解数据之后，该算法通过将模式与未标记的新数据关联来确定应该给新数据赋哪种标签。</p><p>监督学习可以分为两类：<strong>分类</strong>和<strong>回归</strong>。</p><p><strong>分类问题预测数据所属的类别</strong>；</p><p>分类的例子包括垃圾邮件检测、客户流失预测、情感分析、犬种检测等。</p><p><strong>回归问题根据先前观察到的数据预测数值</strong>；</p><p>回归的例子包括房价预测、股价预测、身高-体重预测等。</p><h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>分类是一种基于一个或多个自变量确定因变量所属类别的技术。</p><p><a href="https://sm.ms/image/isQALwyZW2k8qXa" target="_blank"><img src="https://i.loli.net/2019/09/12/isQALwyZW2k8qXa.jpg"></a></p><h1 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h1><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>逻辑回归类似于线性回归，适用于因变量不是一个数值字的情况 (例如，一个“是/否”的响应)。它虽然被称为回归，但却是基于根据回归的分类，将因变量分为两类。</p><p><a href="https://sm.ms/image/lXzAYr9EwIxL8su" target="_blank"><img src="https://i.loli.net/2019/09/12/lXzAYr9EwIxL8su.jpg"></a></p><p>如上所述，逻辑回归用于预测二分类的输出。例如，如果信用卡公司构建一个模型来决定是否通过向客户的发行信用卡申请，它将预测客户的信用卡是否会“违约”。</p><p><a href="https://sm.ms/image/AnCUkFxLyr4KqMQ" target="_blank"><img src="https://i.loli.net/2019/09/12/AnCUkFxLyr4KqMQ.jpg"></a></p><p>首先对变量之间的关系进行线性回归以构建模型，分类的阈值假设为0.5。    </p><p><a href="https://sm.ms/image/Th4bsK92YPzqfZO" target="_blank"><img src="https://i.loli.net/2019/09/12/Th4bsK92YPzqfZO.jpg"></a></p><p>然后将Logistic函数应用于回归分析，得到两类的概率。</p><p>该函数给出了事件发生和不发生概率的对数。最后，根据这两类中较高的概率对变量进行分类。</p><p><a href="https://sm.ms/image/DU8lJCFVas4Oiqz" target="_blank"><img src="https://i.loli.net/2019/09/12/DU8lJCFVas4Oiqz.jpg"></a></p><h2 id="K-近邻算法（K-NN）"><a href="#K-近邻算法（K-NN）" class="headerlink" title="K-近邻算法（K-NN）"></a>K-近邻算法（K-NN）</h2><p>K-NN算法是一种最简单的分类算法，通过识别被分成若干类的数据点，以预测新样本点的分类。K-NN是一种非参数的算法，是“懒惰学习”的著名代表，它根据相似性（如，距离函数）对新数据进行分类。</p><p><a href="https://sm.ms/image/sXxPpoTJ1kY5SIV" target="_blank"><img src="https://i.loli.net/2019/09/12/sXxPpoTJ1kY5SIV.jpg"></a><br><a href="https://sm.ms/image/d1MlhBKkIQ7uDgs" target="_blank"><img src="https://i.loli.net/2019/09/12/d1MlhBKkIQ7uDgs.jpg"></a><br><a href="https://sm.ms/image/GCNHeT3znA51Eqt" target="_blank"><img src="https://i.loli.net/2019/09/12/GCNHeT3znA51Eqt.jpg"></a><br><a href="https://sm.ms/image/ouEkChiFIq8VNDW" target="_blank"><img src="https://i.loli.net/2019/09/12/ouEkChiFIq8VNDW.jpg"></a></p><p>K-NN能很好地处理少量输入变量（p）的情况，但当输入量非常大时就会出现问题。  </p><h2 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h2><p>支持向量机既可用于回归也可用于分类。它基于定义决策边界的决策平面。决策平面（超平面）可将一组属于不同类的对象分离开。</p><p><a href="https://sm.ms/image/SIw1KX9NGdnfY7s" target="_blank"><img src="https://i.loli.net/2019/09/12/SIw1KX9NGdnfY7s.jpg"></a></p><p>在支持向量的帮助下，SVM通过寻找超平面进行分类，并使两个类之间的边界距离最大化。</p><p><a href="https://sm.ms/image/4r8JBhTmC2ntFYz" target="_blank"><img src="https://i.loli.net/2019/09/12/4r8JBhTmC2ntFYz.jpg"></a></p><p>SVM中超平面的学习是通过将问题转化为使用一些某种线性代数转换问题来完成的。（上图的例子是一个线性核，它在每个变量之间具有线性可分性）。</p><p>对于高维数据，使用可使用其他核函数，但高维数据不容易进行分类。具体方法将在之后阐述。</p><h3 id="核支持向量机"><a href="#核支持向量机" class="headerlink" title="核支持向量机"></a>核支持向量机</h3><p>核支持向量机将核函数引入到SVM算法中，并将其转换为所需的形式，将数据映射到可分的高维空间。</p><p>核函数的类型包括：</p><p><a href="https://sm.ms/image/9MXo82Y6StNZrOW" target="_blank"><img src="https://i.loli.net/2019/09/12/9MXo82Y6StNZrOW.jpg"></a></p><ul><li><p>前文讨论的就是线性SVM。</p></li><li><p>多项式核中需要指定多项式的次数。它允许在输入空间中使用曲线进行分割。</p></li><li><p>径向基核（radial basis function, RBF）可用于非线性可分变量。使用平方欧几里德距离，参数的典型值会导致过度拟合。sklearn中默认使用RBF。</p></li><li><p>类似于与逻辑回归类似，sigmoid核用于二分类问题。</p></li></ul><p><a href="https://sm.ms/image/4MDKNmzP26lBIUh" target="_blank"><img src="https://i.loli.net/2019/09/12/4MDKNmzP26lBIUh.jpg"></a></p><h3 id="径向基核（RBF：Radial-Basis-Function-）"><a href="#径向基核（RBF：Radial-Basis-Function-）" class="headerlink" title="径向基核（RBF：Radial Basis Function ）"></a>径向基核（RBF：Radial Basis Function ）</h3><p>RBF核支持向量机的决策区域实际上也是一个线性决策区域。RBF核支持向量机的实际作用是构造特征的非线性组合，将样本映射到高维特征空间，再利用线性决策边界分离类。</p><p><a href="https://sm.ms/image/9p1qE7lGF6QScYm" target="_blank"><img src="https://i.loli.net/2019/09/12/9p1qE7lGF6QScYm.jpg"></a></p><p>因此，可以得出经验是：对线性问题使用线性支持向量机，对非线性问题使用非线性核函数，如RBF核函数。</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯分类器建立在贝叶斯定理的基础上，基于特征之间互相独立的假设（假定类中存在一个与任何其他特征无关的特征）。即使这些特征相互依赖，或者依赖于其他特征的存在，朴素贝叶斯算法都认为这些特征都是独立的。这样的假设过于理想，朴素贝叶斯因此而得名。</p><p><a href="https://sm.ms/image/6vg1DwypuzBiLeV" target="_blank"><img src="https://i.loli.net/2019/09/12/6vg1DwypuzBiLeV.jpg"></a></p><p>在朴素贝叶斯的基础上，高斯朴素贝叶斯根据二项（正态）分布对数据进行分类。</p><p><a href="https://sm.ms/image/wuVQl1qF9Bgfyt5" target="_blank"><img src="https://i.loli.net/2019/09/12/wuVQl1qF9Bgfyt5.jpg"></a></p><p>P(class|data) 表示给定特征（属性）后数据属于某类（目标）的后验概率。给定数据，其属于各类的概率大小就是我们要计算的值。</p><p>P(class)表示某类的先验概率。</p><p>P(data|class)表示似然，是指定类别时特征出现的概率。</p><p>P(data)表示特征或边际似然的先验概率。</p><p><a href="https://sm.ms/image/cGoCjiKS6dyfrDz" target="_blank"><img src="https://i.loli.net/2019/09/12/cGoCjiKS6dyfrDz.jpg"></a></p><p><strong>步骤:</strong></p><p><strong>1、计算先验概率</strong></p><p>P(class) = 类中数据点的数量/观测值的总数量</p><p>P(yellow) = 10/17</p><p>P(green) = 7/17</p><p><strong>2、计算边际似然</strong></p><p>P(data) = 与观测值相似的数据点的数量/观测值的总数量</p><p>P(?) = 4/17</p><p>该值用于检查各个概率。</p><p><strong>3、计算似然</strong></p><p>P(data/class) = 类中与观测值相似的数量/类中点的总数量</p><p>P(?/yellow) = 1/7</p><p>P(?/green) = 3/10</p><p><strong>4、计算各类的后验概率</strong></p><p><a href="https://sm.ms/image/VBUrNiq3HLOk5Ix" target="_blank"><img src="https://i.loli.net/2019/09/12/VBUrNiq3HLOk5Ix.jpg"></a></p><p><strong>5、分类</strong></p><p><a href="https://sm.ms/image/ECulc8Zj19aV4sN" target="_blank"><img src="https://i.loli.net/2019/09/12/ECulc8Zj19aV4sN.jpg"></a></p><p>某一点归于后验概率高的类别，因为从上可知其属于绿色类的概率是75%根据其75%的概率这个点属于绿色类。</p><p>多项式、伯努利朴素贝叶斯是计算概率的其他模型。朴素贝叶斯模型易于构建，不需要复杂的参数迭代估计，这使得它对非常大的数据集特别有用。</p><h2 id="决策树分类"><a href="#决策树分类" class="headerlink" title="决策树分类"></a>决策树分类</h2><p><strong>决策树以树状结构构建分类或回归模型</strong>。它通过将数据集不断拆分为更小的子集来使决策树不断生长。最终长成具有决策节点（包括根节点和内部节点）和叶节点的树。最初决策树算法它采用采用Iterative Dichotomiser 3（ID3）算法来确定分裂节点的顺序。</p><p><a href="https://sm.ms/image/hQLl2H65fwUaxA3" target="_blank"><img src="https://i.loli.net/2019/09/12/hQLl2H65fwUaxA3.jpg"></a></p><p>信息熵和信息增益用于被用来构建决策树。</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息熵是衡量元素无序状态程度的一个指标，即衡量信息的不纯度。</p><p><a href="https://sm.ms/image/gRXyfz1eojrQ5BH" target="_blank"><img src="https://i.loli.net/2019/09/12/gRXyfz1eojrQ5BH.jpg"></a></p><p>信息熵是衡量元素的无序状态的程度的一个指标，或者说，衡量信息的不纯度。</p><p><a href="https://sm.ms/image/gRXyfz1eojrQ5BH" target="_blank"><img src="https://i.loli.net/2019/09/12/gRXyfz1eojrQ5BH.jpg"></a></p><p>直观上说地理解，信息熵表示一个事件的确定性程度。信息熵度量样本的同一性，如果样本全部属于同一类，则信息熵为0；如果样本等分成不同的类别，则信息熵为1。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益测量独立属性间信息熵的变化。它试图估计每个属性本身包含的信息，构造决策树就是要找到具有最高信息增益的属性（即纯度最高的分支）。</p><p><a href="https://sm.ms/image/T9KFHY5frNRgAUk" target="_blank"><img src="https://i.loli.net/2019/09/13/T9KFHY5frNRgAUk.jpg"></a></p><p>信息增益测量独立属性间的信息熵的变化。它试图估计每个属性本身包含的信息，构造决策树就是要找到具有最高信息增益的属性（即纯度最高的分支）。</p><p><a href="https://sm.ms/image/T9KFHY5frNRgAUk" target="_blank"><img src="https://i.loli.net/2019/09/13/T9KFHY5frNRgAUk.jpg"></a></p><p>其中Gain（(T,X）)是特征X的信息增益。Entropy(T)是整个集合的信息熵，第二项Entropy(T,X)是特征X的信息熵。</p><p>采用信息熵进行节点选择时，通过对该节点各个属性信息增益进行排序，选择具有最高信息增益的属性作为划分节点，过滤掉其他属性。</p><p>决策树模型存在的一个问题是容易过拟合。因为在其决策树构建过程中试图通过生成长一棵完整的树来拟合训练集，因此却降低了测试集的准确性。</p><p><a href="https://sm.ms/image/zK6R4baDiCWENPj" target="_blank"><img src="https://i.loli.net/2019/09/13/zK6R4baDiCWENPj.jpg"></a></p><p>通过剪枝技术可以减少小决策树的过拟合问题。</p><h2 id="分类的集成算法"><a href="#分类的集成算法" class="headerlink" title="分类的集成算法"></a>分类的集成算法</h2><p>集成算法是一个模型组。从技术上说，集成算法是单独训练几个有监督模型，并将训练好的模型以不同的方式进行融合，从而达到最终的得预测结果。集成后的模型比其中任何一个单独的模型都有更高的预测能力。</p><p><a href="https://sm.ms/image/bwTqQKcEfJyzA9t" target="_blank"><img src="https://i.loli.net/2019/09/13/bwTqQKcEfJyzA9t.jpg"></a></p><h2 id="随机森林分类器"><a href="#随机森林分类器" class="headerlink" title="随机森林分类器"></a>随机森林分类器</h2><p>随机森林分类器是一种基于<strong>装袋（bagging）</strong>的集成算法，即<strong>自举助聚合法(bootstrap aggregation)</strong>。集成算法结合了多个相同或不同类型的算法来对对象进行分类（例如，SVM的集成，基于朴素贝叶斯的集成或基于决策树的集成）。</p><p><a href="https://sm.ms/image/nbhWdHzm5eVSyjf" target="_blank"><img src="https://i.loli.net/2019/09/13/nbhWdHzm5eVSyjf.jpg"></a></p><p>集成的基本思想是算法的组合提升了最终的结果。</p><p><a href="https://sm.ms/image/aOwBtyY5fh9mEMg" target="_blank"><img src="https://i.loli.net/2019/09/13/aOwBtyY5fh9mEMg.jpg"></a></p><p>深度太大的决策树容易受过拟合的影响。但是随机森林通过在随机子集上构建决策树防止过拟合，主要原因是它会对所有树的结果进行投票的结果是所有树的分类结果的投票，从而消除了单棵树的偏差。</p><p>随机森林在决策树生增长的同时为模型增加了额外的随机性。它在分割节点时，不是搜索全部样本最重要的特征，而是在随机特征子集中搜索最佳特征。这种方式使得决策树具有多样性，从而能够得到更好的模型。</p><h2 id="梯度提升分类器"><a href="#梯度提升分类器" class="headerlink" title="梯度提升分类器"></a>梯度提升分类器</h2><p>梯度提升分类器是一种提升集成算法。提升(boosting)算法是为了减少偏差而对弱分类器的而进行的一种集成方法。与装袋（bagging）方法构建预测结果池不同，提升算法是一种分类器的串行方法，它把每个输出作为下一个分类器的输入。通常，在装袋算法中，每棵树在原始数据集的子集上并行训练，并用所有树预测结果的均值作为模型最终的预测结果；梯度提升模型，采用串行方式而非并行模式获得预测结果。每棵决策树预测前一棵决策树的误差，因而使误差获得提升。</p><p><a href="https://sm.ms/image/tEHDn3slOJewTBM" target="_blank"><img src="https://i.loli.net/2019/09/13/tEHDn3slOJewTBM.jpg"></a></p><ul><li><p>使用浅层决策树初始化预测结果。</p></li><li><p>计算残差值（实际预测值）。</p></li><li><p>构建另一棵浅层决策树，将上一棵树的残差作为输入进行预测。</p></li><li><p>用新预测值和学习率的乘积作为最新预测结果，更新原有预测结果。</p></li><li><p>重复步骤2-4，进行一定次数的迭代（迭代的次数即为构建的决策树的个数）。</p></li></ul><p><a href="https://sm.ms/image/qG8XnbMNEH9gLJZ" target="_blank"><img src="https://i.loli.net/2019/09/13/qG8XnbMNEH9gLJZ.jpg"></a></p><p>如果想了解更多关于梯度提升分类器的知识，可参考：<br><a href="https://medium.com/mlreview/gradient-boosting-from-scratch-1e317ae4587d%20/t%20_blank" target="_blank" rel="noopener">https://medium.com/mlreview/gradient-boosting-from-scratch-1e317ae4587d%20/t%20_blank</a></p><h1 id="分类器的性能"><a href="#分类器的性能" class="headerlink" title="分类器的性能"></a>分类器的性能</h1><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>混淆矩阵是一张表，这张表通过对比已知分类结果的测试数据的预测值和真实值表来描述衡量分类器的性能。在二分类的情况下，混淆矩阵是展示预测值和真实值四种不同结果组合的表。</p><p><a href="https://sm.ms/image/ym8d16RupiQEPC7" target="_blank"><img src="https://i.loli.net/2019/09/13/ym8d16RupiQEPC7.jpg"></a></p><p>多分类问题的混淆矩阵可以帮助你确认错误模式。</p><p>对于二元分类器：</p><p><a href="https://sm.ms/image/RdBiusjJKlto6Ef" target="_blank"><img src="https://i.loli.net/2019/09/13/RdBiusjJKlto6Ef.jpg"></a></p><h2 id="假正例-amp-假负例"><a href="#假正例-amp-假负例" class="headerlink" title="假正例&amp;假负例"></a>假正例&amp;假负例</h2><p>假正例和假负例用来衡量模型预测的分类效果。假正例是指模型错误地将负例预测为正例。假负例是指模型错误地将正例预测为负例。主对角线的值越大（主对角线为真正例和真负例），模型就越好；副对角线给出模型的最差预测结果。</p><h3 id="假正例"><a href="#假正例" class="headerlink" title="假正例"></a>假正例</h3><p>下面给出一个假正例的例子。比如：模型将一封邮件分类为垃圾邮件（正例），但这封邮件实际并不是垃圾邮件。这就像一个警示，错误如果能被修正就更好，但是与假负例相比，它并不是一个严重的问题。</p><p>作者注：个人观点，这个例子举的不太好，对垃圾邮件来说，相比于错误地将垃圾邮件分类为正常邮件（假负例），将正常邮件错误地分类为垃圾邮件（假正例）是更严重的问题。</p><p><strong>假正例（I型错误）</strong>——原假设正确而拒绝原假设。</p><p><a href="https://sm.ms/image/qDQwrXGZvluAy8H" target="_blank"><img src="https://i.loli.net/2019/09/13/qDQwrXGZvluAy8H.jpg"></a></p><h3 id="假负例"><a href="#假负例" class="headerlink" title="假负例"></a>假负例</h3><p>假负例的一个例子。例如，该模型预测一封邮件不是垃圾邮件（负例），但实际上这封邮件是垃圾邮件。这就像一个危险的信号，错误应该被及早纠正，因为它比假正例更严重。</p><p><strong>假负例（II型错误）</strong>——原假设错误而接受原假设。</p><p><a href="https://sm.ms/image/kXrLH8BYd4MmjyO" target="_blank"><img src="https://i.loli.net/2019/09/13/kXrLH8BYd4MmjyO.jpg"></a></p><p>上图能够很容易地说明上述指标。左图男士的测试结果是假正例因为男性不能怀孕；右图女士是假负例因为很明显她怀孕了。</p><p>从混淆矩阵，我们能计算出准确率、精度、召回率和F-1值。</p><h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>准确率是模型预测正确的部分。</p><p><a href="https://sm.ms/image/SAI9hiXOxDgdECL" target="_blank"><img src="https://i.loli.net/2019/09/13/SAI9hiXOxDgdECL.jpg"></a></p><p>准确率的公式为：</p><p><a href="https://sm.ms/image/4kvMm2a8619yAhN" target="_blank"><img src="https://i.loli.net/2019/09/13/4kvMm2a8619yAhN.jpg"></a></p><p>当数据集不平衡，也就是正样本和负样本的数量存在显著差异时，单独依靠准确率不能评价模型的性能。精度和召回率是衡量不平衡数据集的更好的指标。</p><h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>精度是指在所有预测为正例的分类中，预测正确的程度为正例的效果。</p><p><a href="https://sm.ms/image/CAPjQGaoKhsgWT5" target="_blank"><img src="https://i.loli.net/2019/09/13/CAPjQGaoKhsgWT5.jpg"></a></p><p>精度越高越好。</p><h2 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h2><p>召回率是指在所有预测为正例（被正确预测为真的和没被正确预测但为真的）的分类样本中，召回率是指预测正确的程度。它，也被称为敏感度或真正率（TPR）。</p><p><a href="https://sm.ms/image/nyrg3OEvlFjeN5p" target="_blank"><img src="https://i.loli.net/2019/09/13/nyrg3OEvlFjeN5p.jpg"></a></p><p>召回率越高越好。</p><h2 id="F-1值"><a href="#F-1值" class="headerlink" title="F-1值"></a>F-1值</h2><p>通常实用的做法是将精度和召回率合成一个指标F-1值更好用，特别是当你需要一种简单的方法来衡量两个分类器性能时。F-1值是精度和召回率的调和平均值。</p><p><a href="https://sm.ms/image/sUOuF9yPM25THRk" target="_blank"><img src="https://i.loli.net/2019/09/13/sUOuF9yPM25THRk.jpg"></a></p><p>普通的通常均值将所有的值平等对待，而调和平均值给予较低的值更高的权重，从而能够更多地惩罚极端值。所以，如果精度和召回率都很高，则分类器将得到很高的F-1值。</p><h2 id="接受者操作曲线（ROC）和曲线下的面积（AUC）"><a href="#接受者操作曲线（ROC）和曲线下的面积（AUC）" class="headerlink" title="接受者操作曲线（ROC）和曲线下的面积（AUC）"></a>接受者操作曲线（ROC）和曲线下的面积（AUC）</h2><p>ROC曲线是衡量分类器性能的一个很重要指标，它代表模型准确预测的程度。ROC曲线通过绘制真正率和假正率的关系来衡量分类器的敏感度。如果分类器性能优越，则真正率将增加，曲线下的面积会接近于1.如果分类器类似于随机猜测，真正率将随假正率线性增加。AUC值越大，模型效果越好。</p><p><a href="https://sm.ms/image/ws8rUCdbfl92ZQv" target="_blank"><img src="https://i.loli.net/2019/09/13/ws8rUCdbfl92ZQv.jpg"></a></p><h2 id="累积精度曲线"><a href="#累积精度曲线" class="headerlink" title="累积精度曲线"></a>累积精度曲线</h2><p>CAP代表一个模型沿y轴为真正率的累积百分比与沿x轴的该分类样本累积百分比。CAP不同于接受者操作曲线（ROC，绘制的是真正率与假正率的关系）。与ROC曲线相比，CAP曲线很少使用。</p><p><a href="https://sm.ms/image/5C7Vdg2txwN6QWA" target="_blank"><img src="https://i.loli.net/2019/09/13/5C7Vdg2txwN6QWA.jpg"></a></p><p>以考虑一个预测客户是否会购买产品的模型为例，如果随机选择客户，他有50%的概率会购买产品。客户购买产品的累积数量会线性地增长到对应客户总量的最大值，这个曲线称为CAP随机曲线，为上图中的蓝色线。而一个完美的预测，准确地确定预测了哪些客户会购买产品，这样，在所有样本中只需选择最少的客户就能达到最大购买量。这在CAP曲线上产生了一条开始陡峭一旦达到最大值就会维持在1的折线，称为CAP的完美曲线，也被称为理想曲线，为上图中灰色的线。</p><p>最后，一个真实的模型应该能尽可能最大化地正确预测，接近于理想模型曲线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起分类算法，相信学过机器学习的同学都能侃上一二。&lt;/p&gt;
&lt;p&gt;可是，你能够如数家珍地说出所有常用的分类算法，以及他们的特征、优缺点吗？比如说，你可以快速地回答下面的问题么:&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
