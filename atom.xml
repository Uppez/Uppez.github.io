<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教书的先生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://uppez.github.io/"/>
  <updated>2019-10-17T05:09:41.758Z</updated>
  <id>https://uppez.github.io/</id>
  
  <author>
    <name>王荣胜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐系统全数据集</title>
    <link href="https://uppez.github.io/2019/10/17/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%85%A8%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://uppez.github.io/2019/10/17/推荐系统全数据集/</id>
    <published>2019-10-17T05:03:14.000Z</published>
    <updated>2019-10-17T05:09:41.758Z</updated>
    
    <content type="html"><![CDATA[<p>这些数据集在可作为基准的<strong>推荐系统</strong>中非常流行。</p><a id="more"></a><ul><li><p>Douban：<a href="http://socialcomputing.asu.edu/datasets/Douban" target="_blank" rel="noopener">http://socialcomputing.asu.edu/datasets/Douban</a> 这是一个匿名的豆瓣数据集，包含129,490个独立用户和58,541个独立电影条目。</p></li><li><p>Epinions：<a href="http://www.trustlet.org/epinions.html" target="_blank" rel="noopener">http://www.trustlet.org/epinions.html</a> Epinions是一个人们可以评论产品的网站。</p></li><li><p>Flixster：<a href="http://socialcomputing.asu.edu/datasets/Flixster" target="_blank" rel="noopener">http://socialcomputing.asu.edu/datasets/Flixster</a> Flixster是一个社交电影网站，允许用户分享电影评级，发现新电影，并与其他有类似电影品味的人见面。</p></li><li><p>CiaoDVD：<a href="https://www.librec.net/datasets.html" target="_blank" rel="noopener">https://www.librec.net/datasets.html</a> CiaoDVD是从dvd.ciao.co.中抓取的2013年12月英国网站整个dvd类别的数据集。</p></li><li><p>MACLab：<a href="http://mac.citi.sinica.edu.tw/LJ#.VRGYfOHlZ40" target="_blank" rel="noopener">http://mac.citi.sinica.edu.tw/LJ#.VRGYfOHlZ40</a> 这个项目的目的是研究用户的情绪和音乐情绪。</p></li><li><p>DEAPdataset：<a href="http://www.eecs.qmul.ac.uk/mmv/datasets/deap/index.html" target="_blank" rel="noopener">http://www.eecs.qmul.ac.uk/mmv/datasets/deap/index.html</a> 使用脑电图、生理和视频信号进行情绪分析的数据集。</p></li><li><p>MyPersonalityDataset：<a href="http://mypersonality.org/wiki/doku.php" target="_blank" rel="noopener">http://mypersonality.org/wiki/doku.php</a> myPersonality是一个很受欢迎的Facebook应用程序，它允许用户进行真实的心理测试，并允许我们(在征得同意的情况下)记录他们的心理和Facebook资料。目前，我们的数据库包含超过600万个测试结果，以及超过400万个Facebook个人简介。</p></li><li><p>Bibsonomy：<a href="http://www.kde.cs.uni-kassel.de/bibsonomy/dumps" target="_blank" rel="noopener">http://www.kde.cs.uni-kassel.de/bibsonomy/dumps</a> 社交书签系统中的标签推荐。</p></li><li><p>Delicious：<a href="http://www.dai-labor.de/en/competence_centers/irml/datasets/" target="_blank" rel="noopener">http://www.dai-labor.de/en/competence_centers/irml/datasets/</a> plista新闻推荐数据集，美味可口。</p></li><li><p>Movielens：<a href="https://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">https://grouplens.org/datasets/movielens/</a> 稳定的基准数据集。2000万个评分和46.5万个标签应用程序被13.8万用户应用于2.7万部电影。包括标签基因组数据，1100个标签的1200万个相关性得分。</p></li><li><p>Jester：<a href="http://eigentaste.berkeley.edu/dataset/" target="_blank" rel="noopener">http://eigentaste.berkeley.edu/dataset/</a> 来自小丑在线笑话推荐系统的匿名评级。</p></li><li><p>BookCrossing：<a href="http://www2.informatik.uni-freiburg.de/~cziegler/BX/" target="_blank" rel="noopener">http://www2.informatik.uni-freiburg.de/~cziegler/BX/</a> Book-Crossing数据集。</p></li><li><p>LastFM：<a href="https://grouplens.org/datasets/hetrec-2011/" target="_blank" rel="noopener">https://grouplens.org/datasets/hetrec-2011/</a> 来自1892个用户的92,800张艺术家录音。</p></li><li><p>Wikipedia：<a href="https://en.wikipedia.org/wiki/Wikipedia:Database_download#English-language_Wikipedia" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wikipedia:Database_download#English-language_Wikipedia</a> 维基百科向感兴趣的用户提供所有可用内容的免费拷贝。这些数据库可用于镜像、个人使用、非正式备份、脱机使用或数据库查询。</p></li><li><p>OpenStreetMap：<a href="http://planet.openstreetmap.org/planet/full-history/" target="_blank" rel="noopener">http://planet.openstreetmap.org/planet/full-history/</a> 这里找到的文件是OpenStreetMap.org数据库的完整副本，包括编辑历史。这些都是在Open Data Commons Open Database License 1.0许可下发布的。</p></li><li><p>PythonGitCode：<a href="https://github.com/lab41/hermes" target="_blank" rel="noopener">https://github.com/lab41/hermes</a> Hermes是Lab41对推荐系统的一次尝试。通过分析多种推荐系统算法在不同数据集上的性能，探讨了如何为新的应用选择推荐系统。</p></li><li><p>Gist：<a href="https://gist.github.com/entaroadun/1653794" target="_blank" rel="noopener">https://gist.github.com/entaroadun/1653794</a> 为机器学习推荐和评级的公共数据集。</p></li><li><p>Yelp：<a href="https://www.yelp.com/dataset" target="_blank" rel="noopener">https://www.yelp.com/dataset</a> Yelp数据集是用于个人、教育和学术目的的业务、评论和用户数据的子集。可以在JSON和SQL文件中使用，在你学习如何制作移动应用程序时，可以使用它来教学生关于数据库、学习NLP或示例生产数据。</p></li><li><p>AmazonReviews：<a href="http://jmcauley.ucsd.edu/data/amazon/" target="_blank" rel="noopener">http://jmcauley.ucsd.edu/data/amazon/</a> 该数据集包含来自Amazon的产品评论和元数据，包括1996年5月至2014年7月期间的1.428亿个评论。这个数据集包括评论(评级、文本、帮助投票)、产品元数据(描述、类别信息、价格、品牌和图像特性)和链接(也查看/购买图表)。</p></li><li><p>CiteULike：<a href="http://www.citeulike.org/faq/data.adp" target="_blank" rel="noopener">http://www.citeulike.org/faq/data.adp</a> CiteULike数据库对不同领域的研究人员都有潜在的用处。物理学家和计算机科学家对分析数据结构表示了兴趣，并经常要求提供数据集。以前，这是在一个特别的基础上完成的，它依赖于我们记住更新数据文件。现在，有一个自动的过程，每天晚上运行，生成一个快照摘要，说明用哪些标签发布了哪些文章。</p></li><li><p>Taobao：<a href="https://tianchi.aliyun.com/datalab/dataSet.htm?spm=5176.100073.888.13.62f83f62aOlMEI&amp;id=1" target="_blank" rel="noopener">https://tianchi.aliyun.com/datalab/dataSet.htm?spm=5176.100073.888.13.62f83f62aOlMEI&amp;id=1</a> 该数据集包含了匿名用户在“双十一”前后6个月的购物记录，以及表明他们是否重复购买的标签信息。由于隐私问题，数据采集存在偏差，因此该数据集的统计结果会与天猫的实际情况相背离。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些数据集在可作为基准的&lt;strong&gt;推荐系统&lt;/strong&gt;中非常流行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="数据集-推荐系统" scheme="https://uppez.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>全50张matplotlib图</title>
    <link href="https://uppez.github.io/2019/10/16/%E5%85%A850%E5%BC%A0matplotlib%E5%9B%BE/"/>
    <id>https://uppez.github.io/2019/10/16/全50张matplotlib图/</id>
    <published>2019-10-16T12:23:32.000Z</published>
    <updated>2019-10-16T12:35:33.997Z</updated>
    
    <content type="html"><![CDATA[<p>不好说些什么…</p><a id="more"></a><h2 id="1-关联"><a href="#1-关联" class="headerlink" title="1.关联"></a>1.关联</h2><blockquote><p>散点图<br>带边界的气泡图<br>带线性回归最佳拟合线的散点图<br>抖动图<br>计数图<br>边缘直方图<br>边缘箱形图<br>相关图<br>矩阵图</p></blockquote><h2 id="2-偏差"><a href="#2-偏差" class="headerlink" title="2.偏差"></a>2.偏差</h2><blockquote><p>发散型条形图<br>发散型文本<br>发散型包点图<br>带标记的发散型棒棒糖图<br>面积图</p></blockquote><h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h2><blockquote><p>有序条形图<br>棒棒糖图<br>包点图<br>坡度图<br>哑铃图</p></blockquote><h2 id="4-分布"><a href="#4-分布" class="headerlink" title="4.分布"></a>4.分布</h2><blockquote><p>连续变量的直方图<br>类型变量的直方图<br>密度图<br>直方密度线图<br>Joy Plot<br>分布式包点图<br>包点+箱形图<br>Dot + Box Plot<br>小提琴图<br>人口金字塔<br>分类图</p></blockquote><h2 id="5-组成"><a href="#5-组成" class="headerlink" title="5.组成"></a>5.组成</h2><blockquote><p>华夫饼图<br>饼图<br>树形图<br>条形图</p></blockquote><h2 id="6-变化"><a href="#6-变化" class="headerlink" title="6.变化"></a>6.变化</h2><blockquote><p>时间序列图<br>带波峰波谷标记的时序图<br>自相关和部分自相关图<br>交叉相关图<br>时间序列分解图<br>多个时间序列<br>使用辅助Y轴来绘制不同范围的图形<br>带有误差带的时间序列<br>堆积面积图<br>未堆积的面积图<br>日历热力图<br>季节图</p></blockquote><h2 id="7-分组"><a href="#7-分组" class="headerlink" title="7.分组"></a>7.分组</h2><blockquote><p>树状图<br>簇状图<br>安德鲁斯曲线<br>平行坐标</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不好说些什么…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://uppez.github.io/categories/Python/"/>
    
    
      <category term="matplotlib" scheme="https://uppez.github.io/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>阿里云栖大会-程序员吐槽大会</title>
    <link href="https://uppez.github.io/2019/10/15/%E9%98%BF%E9%87%8C%E4%BA%91%E6%A0%96%E5%A4%A7%E4%BC%9A-%E7%A8%8B%E5%BA%8F%E5%91%98%E5%90%90%E6%A7%BD%E5%A4%A7%E4%BC%9A/"/>
    <id>https://uppez.github.io/2019/10/15/阿里云栖大会-程序员吐槽大会/</id>
    <published>2019-10-15T10:07:33.000Z</published>
    <updated>2019-10-15T10:15:35.032Z</updated>
    
    <content type="html"><![CDATA[<p>啊~你的代码好强（你确实很弱，但我不能说）</p><a id="more"></a><center><iframe src="//player.bilibili.com/player.html?aid=69171100&cid=119877665&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500px" width="580px"> </iframe></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊~你的代码好强（你确实很弱，但我不能说）&lt;/p&gt;
    
    </summary>
    
    
      <category term="随记" scheme="https://uppez.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="云栖大会" scheme="https://uppez.github.io/tags/%E4%BA%91%E6%A0%96%E5%A4%A7%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>python生成迷宫</title>
    <link href="https://uppez.github.io/2019/10/14/python%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB/"/>
    <id>https://uppez.github.io/2019/10/14/python生成迷宫/</id>
    <published>2019-10-14T12:54:32.000Z</published>
    <updated>2019-10-14T12:59:02.717Z</updated>
    
    <content type="html"><![CDATA[<p>算法简介:</p><ol><li><p>生成一张网格，把网格里面的所有边都存进一个列表edgeList里面.</p></li><li><p>从(0, 0)开始，做DFS。每次DFS的时候，随机地选择四周一个没有走过的格子，凿墙过去，把道路打通。凿墙的时候，把edgeList列表中相对应的那堵墙删除掉。</p></li><li><p>将剩下的没有凿开过的墙画出来，就是一个完整的迷宫了。</p></li></ol><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">WIDTH  = <span class="hljs-number">60</span></span><br><span class="line">HEIGHT = <span class="hljs-number">40</span></span><br><span class="line">sys.setrecursionlimit(WIDTH * HEIGHT)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initVisitedList</span><span class="hljs-params">()</span>:</span></span><br><span class="line">visited = []</span><br><span class="line"><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(HEIGHT):</span><br><span class="line">line = []</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(WIDTH):</span><br><span class="line">line.append(<span class="hljs-literal">False</span>)</span><br><span class="line">visited.append(line)</span><br><span class="line"><span class="hljs-keyword">return</span> visited</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(x1, y1, x2, y2)</span>:</span></span><br><span class="line">plt.plot([x1, x2], [y1, y2], color=<span class="hljs-string">"black"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeLine</span><span class="hljs-params">(x1, y1, x2, y2)</span>:</span></span><br><span class="line">plt.plot([x1, x2], [y1, y2], color=<span class="hljs-string">"white"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_edges</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">result = []</span><br><span class="line">result.append((x, y, x, y+<span class="hljs-number">1</span>))</span><br><span class="line">result.append((x+<span class="hljs-number">1</span>, y, x+<span class="hljs-number">1</span>, y+<span class="hljs-number">1</span>))</span><br><span class="line">result.append((x, y, x+<span class="hljs-number">1</span>, y))</span><br><span class="line">result.append((x, y+<span class="hljs-number">1</span>, x+<span class="hljs-number">1</span>, y+<span class="hljs-number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawCell</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line">edges = get_edges(x, y)</span><br><span class="line"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> edges:</span><br><span class="line">drawLine(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>], item[<span class="hljs-number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getCommonEdge</span><span class="hljs-params">(cell1_x, cell1_y, cell2_x, cell2_y)</span>:</span></span><br><span class="line">edges1 = get_edges(cell1_x, cell1_y)</span><br><span class="line">edges2 = set(get_edges(cell2_x, cell2_y))</span><br><span class="line"><span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges1:</span><br><span class="line"><span class="hljs-keyword">if</span> edge <span class="hljs-keyword">in</span> edges2:</span><br><span class="line"><span class="hljs-keyword">return</span> edge</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initEdgeList</span><span class="hljs-params">()</span>:</span></span><br><span class="line">edges = set()</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(WIDTH):</span><br><span class="line"><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(HEIGHT):</span><br><span class="line">cellEdges = get_edges(x, y)</span><br><span class="line"><span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> cellEdges:</span><br><span class="line">edges.add(edge)</span><br><span class="line"><span class="hljs-keyword">return</span> edges</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidPosition</span><span class="hljs-params">(x, y)</span>:</span></span><br><span class="line"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x &gt;= WIDTH:</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"><span class="hljs-keyword">elif</span> y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> y &gt;= HEIGHT:</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(dX, dY)</span>:</span></span><br><span class="line"><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):</span><br><span class="line">i = randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)</span><br><span class="line">j = randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)</span><br><span class="line">dX[i], dX[j] = dX[j], dX[i]</span><br><span class="line">dY[i], dY[j] = dY[j], dY[i]</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(X, Y, edgeList, visited)</span>:</span></span><br><span class="line">dX = [<span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>]</span><br><span class="line">dY = [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>]</span><br><span class="line">shuffle(dX, dY)</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(dX)):</span><br><span class="line">nextX = X + dX[i]</span><br><span class="line">nextY = Y + dY[i]</span><br><span class="line"><span class="hljs-keyword">if</span> isValidPosition(nextX, nextY):</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[nextY][nextX]:</span><br><span class="line">visited[nextY][nextX] = <span class="hljs-literal">True</span></span><br><span class="line">commonEdge = getCommonEdge(X, Y, nextX, nextY)</span><br><span class="line"><span class="hljs-keyword">if</span> commonEdge <span class="hljs-keyword">in</span> edgeList:</span><br><span class="line">edgeList.remove(commonEdge)</span><br><span class="line">DFS(nextX, nextY, edgeList, visited)</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="hljs-string">'equal'</span>)</span><br><span class="line">plt.title(<span class="hljs-string">'Maze'</span>)</span><br><span class="line">edgeList = initEdgeList()</span><br><span class="line">visited  = initVisitedList()</span><br><span class="line">DFS(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, edgeList, visited)</span><br><span class="line">edgeList.remove((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))</span><br><span class="line">edgeList.remove((WIDTH, HEIGHT<span class="hljs-number">-1</span>, WIDTH, HEIGHT))</span><br><span class="line"><span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edgeList:</span><br><span class="line">drawLine(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>], edge[<span class="hljs-number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法简介:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成一张网格，把网格里面的所有边都存进一个列表edgeList里面.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从(0, 0)开始，做DFS。每次DFS的时候，随机地选择四周一个没有走过的格子，凿墙过去，把道路打通。凿墙的时候，把edgeList列表中相对应的那堵墙删除掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将剩下的没有凿开过的墙画出来，就是一个完整的迷宫了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://uppez.github.io/categories/Python/"/>
    
    
      <category term="迷宫" scheme="https://uppez.github.io/tags/%E8%BF%B7%E5%AE%AB/"/>
    
  </entry>
  
  <entry>
    <title>十一种概率分布</title>
    <link href="https://uppez.github.io/2019/10/14/%E5%8D%81%E4%B8%80%E7%A7%8D%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
    <id>https://uppez.github.io/2019/10/14/十一种概率分布/</id>
    <published>2019-10-14T11:05:07.000Z</published>
    <updated>2019-10-14T12:36:06.285Z</updated>
    
    <content type="html"><![CDATA[<p>不是没你不行，而是有你更好</p><a id="more"></a><h2 id="1-均匀分布"><a href="#1-均匀分布" class="headerlink" title="1.均匀分布"></a>1.均匀分布</h2><p><a href="https://sm.ms/image/eAXEaIcLvVGnZpw" target="_blank"><img src="https://i.loli.net/2019/10/14/eAXEaIcLvVGnZpw.png"></a></p><h2 id="2-伯努利分布"><a href="#2-伯努利分布" class="headerlink" title="2.伯努利分布"></a>2.伯努利分布</h2><p><a href="https://sm.ms/image/VpnqC3ZkaegHc9A" target="_blank"><img src="https://i.loli.net/2019/10/14/VpnqC3ZkaegHc9A.png"></a></p><h2 id="3-二项分布"><a href="#3-二项分布" class="headerlink" title="3.二项分布"></a>3.二项分布</h2><p><a href="https://sm.ms/image/53yNimRTjOoLzV7" target="_blank"><img src="https://i.loli.net/2019/10/14/53yNimRTjOoLzV7.png"></a></p><h2 id="4-高斯分布"><a href="#4-高斯分布" class="headerlink" title="4.高斯分布"></a>4.高斯分布</h2><p><a href="https://sm.ms/image/Ejf65nxZUYHzClW" target="_blank"><img src="https://i.loli.net/2019/10/14/Ejf65nxZUYHzClW.png"></a></p><h2 id="5-拉普拉斯分布"><a href="#5-拉普拉斯分布" class="headerlink" title="5.拉普拉斯分布"></a>5.拉普拉斯分布</h2><p><a href="https://sm.ms/image/9F8yk4M1mVE2pJT" target="_blank"><img src="https://i.loli.net/2019/10/14/9F8yk4M1mVE2pJT.png"></a></p><h2 id="6-泊松分布"><a href="#6-泊松分布" class="headerlink" title="6.泊松分布"></a>6.泊松分布</h2><p><a href="https://sm.ms/image/aCoJVpO17rLFXAe" target="_blank"><img src="https://i.loli.net/2019/10/14/aCoJVpO17rLFXAe.png"></a></p><h2 id="7-指数分布"><a href="#7-指数分布" class="headerlink" title="7.指数分布"></a>7.指数分布</h2><p><a href="https://sm.ms/image/WPiw6vxuXYDs8I5" target="_blank"><img src="https://i.loli.net/2019/10/14/WPiw6vxuXYDs8I5.png"></a></p><h2 id="8-伽马分布"><a href="#8-伽马分布" class="headerlink" title="8.伽马分布"></a>8.伽马分布</h2><p><a href="https://sm.ms/image/fkl6WsZdEJmPgzF" target="_blank"><img src="https://i.loli.net/2019/10/14/fkl6WsZdEJmPgzF.png"></a></p><h2 id="9-贝塔分布"><a href="#9-贝塔分布" class="headerlink" title="9.贝塔分布"></a>9.贝塔分布</h2><p><a href="https://sm.ms/image/KZ1OMuaJBoWEs6A" target="_blank"><img src="https://i.loli.net/2019/10/14/KZ1OMuaJBoWEs6A.png"></a></p><h2 id="10-狄拉克分布"><a href="#10-狄拉克分布" class="headerlink" title="10.狄拉克分布"></a>10.狄拉克分布</h2><p><a href="https://sm.ms/image/XAMYkRhmVPvq2B9" target="_blank"><img src="https://i.loli.net/2019/10/14/XAMYkRhmVPvq2B9.png"></a></p><h2 id="11-多项式分布与狄里克雷分布"><a href="#11-多项式分布与狄里克雷分布" class="headerlink" title="11.多项式分布与狄里克雷分布"></a>11.多项式分布与狄里克雷分布</h2><p><a href="https://sm.ms/image/HfDoGi1khuCLSvW" target="_blank"><img src="https://i.loli.net/2019/10/14/HfDoGi1khuCLSvW.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不是没你不行，而是有你更好&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="概率分布" scheme="https://uppez.github.io/tags/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>恐怖片里，人工智能大开杀戒?</title>
    <link href="https://uppez.github.io/2019/10/13/%E6%81%90%E6%80%96%E7%89%87%E9%87%8C%EF%BC%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E5%BC%80%E6%9D%80%E6%88%92/"/>
    <id>https://uppez.github.io/2019/10/13/恐怖片里，人工智能大开杀戒/</id>
    <published>2019-10-13T01:36:04.000Z</published>
    <updated>2019-10-13T02:01:03.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>场景描述：经典的杀人狂魔鬼娃恰吉，在 2019 年迎来了新版的制作。和之前几部不同，这一部里面，作祟的不再是恶魔幽灵，而是人工智能。那么这个噩梦级的杀人魔，在 AI 版本中又会是什么样，所带来的恐惧会升级吗？除了这些，在电影的背后，又会带来什么样的思考，AI 会比巫术更可怕吗？<br>关键词：鬼娃恰吉   恐怖电影   智能家居</p></blockquote><a id="more"></a><p>人工智能杀人了，而且一次杀了很多人。《鬼娃回魂》2019 重启版已经在北美和观众见面，这一部中恰吉化身成为被<strong>人工智能</strong>操控的娃娃，将各种<strong>物联网电器、自动驾驶、无人机</strong>等各种设备变成武器，大开杀戒。</p><p>这一系列恐怖片从 1988 年正式开启，造就了影史上一个最经典的杀人狂魔——鬼娃恰吉，成了许多观众心底的玩偶噩梦。而这部在北美市场深入人心的作品，在随后的 30 多年间陆续推出了多部续集。</p><p><a href="https://sm.ms/image/O5SB6cEzeR2KXCP" target="_blank"><img src="https://i.loli.net/2019/10/13/O5SB6cEzeR2KXCP.jpg"></a></p><p>该系列的第一部电影叫做<strong>《 Child’s Play》</strong>，中文译为<strong>《鬼娃回魂》</strong>。故事讲了一个杀人魔在临死时，用巫术将灵魂转移到一个叫恰吉（Chucky）的玩偶娃娃身上，这个凶横残忍的杀人娃娃，开启了它多年的杀戮之旅。</p><p>而在今年，这个系列推出了一版重启的电影，故事还是沿用了相同的设定，但这一次，让玩偶成为噩梦的内核不再是恶灵、巫术之类，而是当下发展如火如荼的人工智能。</p><p><a href="https://sm.ms/image/WYXfKs3zNtEkwFP" target="_blank"><img src="https://i.loli.net/2019/10/13/WYXfKs3zNtEkwFP.jpg"></a></p><h2 id="不受监管的-AI-，比恶灵还恐怖"><a href="#不受监管的-AI-，比恶灵还恐怖" class="headerlink" title="不受监管的 AI ，比恶灵还恐怖"></a>不受监管的 AI ，比恶灵还恐怖</h2><p>电影的设定是在一个智能化普及的时代，连电视广告里，都在不停地在宣传一款智能的 AI 娃娃，Buddi 。</p><p><a href="https://sm.ms/image/WqNSb79UwgmjtsB" target="_blank"><img src="https://i.loli.net/2019/10/13/WqNSb79UwgmjtsB.gif"></a></p><p>它有着 AI 内核，一套小巧的玩具躯体，能够和人进行无障碍的交流，并且可以控制该品牌下的一切智能设备，主要的职能是陪伴孩子的成长，俨然是一个<strong>智能管家</strong>和<strong>高级玩伴</strong>。</p><p><a href="https://sm.ms/image/TWZuI2i6UorsFk5" target="_blank"><img src="https://i.loli.net/2019/10/13/TWZuI2i6UorsFk5.jpg"></a></p><p>而故事的主角，是一个「不正常」的 AI 娃娃，和常规的玩具不同，在生产过程中，由于<strong>系统里的所有安全协议都被人为恶意移除</strong>，这个不受限制的娃娃可以说脏话，可以进行暴力行为，甚至会伤害到人，这些特殊的地方为它成为恶魔埋下了隐患。</p><p>经过一些波折之后，这个特殊的娃娃，带着退换货的标签，被主角安迪在超市工作的妈妈带回了家中。从此，噩梦在不知不觉中逼近。</p><h2 id="从玩伴到恶魔：AI-恰吉大开杀戒"><a href="#从玩伴到恶魔：AI-恰吉大开杀戒" class="headerlink" title="从玩伴到恶魔：AI 恰吉大开杀戒"></a>从玩伴到恶魔：AI 恰吉大开杀戒</h2><p>和经典的版本一样，这个智能娃娃的名字沿用了恰吉。在一开始，恰吉还是温和的，十分尽心地陪伴和安慰着安迪。</p><p><a href="https://sm.ms/image/zeVFkOsixY7qoSW" target="_blank"><img src="https://i.loli.net/2019/10/13/zeVFkOsixY7qoSW.gif"></a></p><p>但具有学习能力，并且没有约束的恰吉，在安迪不太健康的生活环境中，逐渐学会了一些怪异的行为，并走向了偏执的道路。</p><p>安迪和他的朋友们，<strong>会故意教唆恰吉使坏</strong>，比如扮鬼脸去吓人，偷东西，说脏话等。</p><p>除此以外，恰吉也在学习和模仿一些行为。比如安迪和朋友们在看惊悚电影的杀戮场面时，笑的前俯后仰的情景，就烙在了恰吉的认知里，恰吉以为杀人是一件令同伴开心的事。</p><p><a href="https://sm.ms/image/hZ6lPDY5owUANxB" target="_blank"><img src="https://i.loli.net/2019/10/13/hZ6lPDY5owUANxB.gif"></a></p><p>在这些综合因素之下，气氛逐渐开始变得恐怖起来。恰吉的 AI 系统并<strong>不能分辨善恶</strong>，它只知道被教的一些动作是讨喜的，并且开始了效仿电影中的极端行为。</p><p><strong>恰吉对人类语言以及情感的理解偏差</strong>，让事态变得不受控制，而它使用暴力的解决方式，则是将一切带向了不可挽回的地步。</p><p>对于安迪带有感情色彩的话语，如「我希望你去死」或者「我恨死你了」，到底代表了什么意义。人们出于滑稽和开心发出的笑容，在恰吉看来也是没有差别的。</p><p>最可怕的地方在于，恰吉会随时记录着主人的言行，并且以它理解的方式去践行。</p><p><a href="https://sm.ms/image/iagSVrRCHE3wztF" target="_blank"><img src="https://i.loli.net/2019/10/13/iagSVrRCHE3wztF.gif"></a></p><p>为了达到它的目的，恰吉的杀心开始显露。</p><p>起初，它用原始的手段和工具，杀掉了被安迪口上嫌弃的猫，被震惊的安迪把恰吉关了起来，但却对母亲隐瞒了它杀猫的事实。</p><p><a href="https://sm.ms/image/w5yvJnqW43FjNBx" target="_blank"><img src="https://i.loli.net/2019/10/13/w5yvJnqW43FjNBx.gif"></a></p><center><p>一杀：恰吉看到猫咪误伤安迪后，就准备将其杀害</p></center><p>接着，恰吉开始变本加厉，杀人的手段也开始走向高级。安迪一直讨厌他妈妈的新男友，所以恰吉也瞄准了他。趁他在梯子上安装灯饰之时，通过触碰梯子让他坠落，然后开动除草机，对其进行了虐杀，还割下了面皮送给了安迪。</p><p><a href="https://sm.ms/image/5vMeALKOcjQiIV3" target="_blank"><img src="https://i.loli.net/2019/10/13/5vMeALKOcjQiIV3.gif"></a></p><center><p>二杀：通过控制除草机 向安迪妈妈的新男友痛下杀手</p></center><p>在恰吉的认知里，没有善恶，它的主导是和安迪做朋友，要让安迪开心，而它的方式，就是清理掉那些令安迪不开心的人和物。</p><h2 id="无人机、智能家电、自动驾驶：皆可成为武器"><a href="#无人机、智能家电、自动驾驶：皆可成为武器" class="headerlink" title="无人机、智能家电、自动驾驶：皆可成为武器"></a>无人机、智能家电、自动驾驶：皆可成为武器</h2><p>在经历了两次事件之后，安迪被恰吉的邪恶所震惊，于是和他的两个朋友一起，拆除了恰吉的电芯，并丢到了垃圾堆里。</p><p><a href="https://sm.ms/image/Cm8bJuNc7TWEksv" target="_blank"><img src="https://i.loli.net/2019/10/13/Cm8bJuNc7TWEksv.gif"></a></p><center><p>对付 AI，果然还是要「拔电池」</p></center><p>但故事还没有结束，它被一个有偷窥癖的维修工捡到，并进行了修复。恰吉活了过来，并且进行了二度黑化。</p><p>此后，它分别除了自保，抢夺安迪，证明自己是对的三个目的，进行了三次屠杀。而这一次，恰吉运用了** AI 和物联网**的威力。</p><p>首先是在漆黑的地下室里，控制智能设备，对准备拿它换钱的修理工完成了反杀。</p><p>虽然恰吉身形和修理工相比不值一提，但恰吉却利用智能电器的控制，充分利用灯光的明暗、扫地机器人的移动，加热管道的温控等条件，让修理工乱了分寸，最终启动智能切割机设备，终结了他。</p><p><a href="https://sm.ms/image/Vv34GpuYeZRWcJs" target="_blank"><img src="https://i.loli.net/2019/10/13/Vv34GpuYeZRWcJs.gif"></a></p><center><p>三杀：恰吉连接温控器，并调到了最高，折磨修理工</p></center><p>随后恰吉出于柠檬精的心理，认为安迪的新朋友邻居老奶奶，是它和安迪朋友关系的一大绊脚石，必须要除去。而杀害她的方式，则是涉及到了自动驾驶。</p><p>在老奶奶在使用自动驾驶出租车的路程中，恰吉入侵了智能设备，并接管了车辆，随后控制汽车发生恶意的撞击，最令人恐怖的是，在剧烈撞击之前，恰吉控制车辆关闭了安全气囊、并解开了安全带。</p><p><a href="https://sm.ms/image/dN2W15te87SCcfq" target="_blank"><img src="https://i.loli.net/2019/10/13/dN2W15te87SCcfq.gif"></a></p><center><p>四杀：恰吉控制自动驾驶车辆，杀害了邻居奶奶</p></center><p>影片的高潮出现在了在新一代玩偶娃娃的发售商场。这一次，恰吉不在针对个人，而是对商场里的准备抢购的群众进行了无差别杀害。</p><p>但凡是可以联网控制的设备，恰吉都可以进行操纵，这也成了 AI 失控后最可怕的地方。</p><p>恰吉启动电动门，封锁住了出口，然后控制商店里的无人机，利用锋利的螺旋桨大杀四方，并互联了所有的 AI 娃娃，让它们都具备攻击性，扑向商场里的群众。</p><p><a href="https://sm.ms/image/uk9r1flNyJRL2Td" target="_blank"><img src="https://i.loli.net/2019/10/13/uk9r1flNyJRL2Td.gif"></a></p><center><p>多杀：恰吉遥控无人机等智能设备攻击商场里的人</p></center><p>在电影的逻辑里，恰吉的一切恶行，都是为了证明自己才是安迪值得托付的朋友，所以这些杀戮对它来说，只是一种必要的途径。</p><p>当然，和鬼娃回魂的电影系列一样，最终恰吉还是被主角一行人制服，并且进行了毁灭性打击，但恰吉真的就消失了吗？</p><h2 id="失控的-AI-，会有多可怕？"><a href="#失控的-AI-，会有多可怕？" class="headerlink" title="失控的 AI ，会有多可怕？"></a>失控的 AI ，会有多可怕？</h2><p>纵观整个电影，故事的最大看点，在于没有了之前那些玄乎的鬼怪之类，而是借用了 AI 系统的安全隐患，来制造出恐怖的效果。</p><p><a href="https://sm.ms/image/PWF2q6uDgEoXpds" target="_blank"><img src="https://i.loli.net/2019/10/13/PWF2q6uDgEoXpds.gif"></a></p><center><p>在一开始，安迪教恰吉扮鬼脸吓人的时候 应该没想到恰吉后来会如此恐怖</p></center><p>不过在思考之后发现， 影片中 AI 所造成的恐怖事件，更多的还在于环境的因素：在失衡的条件下成长而来的智能系统，如果被引向负面，又脱离了安全条款的保护，势必会造成不可估量的后果。</p><p>就像是微软曾经的<strong>语音机器人 Tay</strong>，原本是一个正常的 AI ，但在社交平台上开放聊天后，短短的 24 小时后就被彻底教坏，言语中夹杂着暴力倾向、性别歧视、种族歧视、污言秽语。</p><p><a href="https://sm.ms/image/GjLcVd6kMxv7bIz" target="_blank"><img src="https://i.loli.net/2019/10/13/GjLcVd6kMxv7bIz.jpg"></a></p><center><p>Tay 推出短短一天就被迫下线</p></center><p>细数科幻电影中的 AI 形象，比恰吉邪恶恐怖的，在西部世界、机械姬等作品中，要体现的更为深刻。这个已算不上「鬼娃」的恰吉，也许只是经典 IP 不甘被遗忘的尝试之作。</p><p>但电影也透露出了 AI 发展中的一些实际难题。<strong>比如对带有感情色彩的语言的理解，对人类的爱恨的把握，甚至是对于人类的道德体系， AI 模型还是不具备理解的能力的</strong>。</p><p>此外，为了便利把所任务都过快的交给 AI ，是否充分考虑了安全隐患，也同样值得深思。在整个事件之后，生产 Buddi 的公司立刻撇清关系，只是象征性地召回新品（出问题的是老款），态度也很值得玩味。</p><p>电影归电影，现实生活中，AI 的智能程度远没达到这个地步，而 AI 蒙上的这份恐怖色彩，人为因素也占据了很大的诱因。</p><p>至少目前看来，我们要担心的，还不是 AI 过于强大，而是在应用层面上不要那么ZZ。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;场景描述：经典的杀人狂魔鬼娃恰吉，在 2019 年迎来了新版的制作。和之前几部不同，这一部里面，作祟的不再是恶魔幽灵，而是人工智能。那么这个噩梦级的杀人魔，在 AI 版本中又会是什么样，所带来的恐惧会升级吗？除了这些，在电影的背后，又会带来什么样的思考，AI 会比巫术更可怕吗？&lt;br&gt;关键词：鬼娃恰吉   恐怖电影   智能家居&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://uppez.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Child’s Play" scheme="https://uppez.github.io/tags/Child%E2%80%99s-Play/"/>
    
  </entry>
  
  <entry>
    <title>死磕c语言数据结构</title>
    <link href="https://uppez.github.io/2019/10/13/%E6%AD%BB%E7%A3%95c%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://uppez.github.io/2019/10/13/死磕c语言数据结构/</id>
    <published>2019-10-13T00:44:17.000Z</published>
    <updated>2019-10-14T00:36:29.965Z</updated>
    
    <content type="html"><![CDATA[<p><strong>持续更新…</strong></p><a id="more"></a><h1 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> n,i,j,a[<span class="hljs-number">100</span>],temp;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<span class="hljs-comment">//输入的数字个数</span></span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]); <span class="hljs-comment">//输入 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-comment">//冒泡排序 </span></span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(a[j]&lt;a[j+<span class="hljs-number">1</span>])&#123;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j+<span class="hljs-number">1</span>];</span><br><span class="line">a[j+<span class="hljs-number">1</span>] = temp; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]); <span class="hljs-comment">//输出 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2.桶排序"></a>2.桶排序</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> n,m,i,j,a[<span class="hljs-number">100</span>];</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;</span><br><span class="line">a[i] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);</span><br><span class="line">a[m]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;a[i];j++)&#123;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python版的排序：<a href="https://zzdproject.netlify.com/#/sort" target="_blank" rel="noopener">https://zzdproject.netlify.com/#/sort</a></p><h1 id="二、队列、栈、链表"><a href="#二、队列、栈、链表" class="headerlink" title="二、队列、栈、链表"></a>二、队列、栈、链表</h1><h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> data[<span class="hljs-number">100</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> head;</span><br><span class="line"><span class="hljs-keyword">int</span> tail;       </span><br><span class="line">&#125;; <span class="hljs-comment">// ;别忘了</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue</span> <span class="hljs-title">q</span>;</span><span class="hljs-comment">//  有struct</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    <span class="hljs-comment">// 此时为NULL </span></span><br><span class="line">    q.head = <span class="hljs-number">1</span>;</span><br><span class="line">    q.tail = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="hljs-comment">//   插入 </span></span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q.data[q.tail]);</span><br><span class="line">        q.tail++;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span>(q.head &lt; q.tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,q.data[q.head]);</span><br><span class="line">        q.head++;</span><br><span class="line">        <span class="hljs-comment">//  插入 </span></span><br><span class="line">        q.data[q.tail] = q.data[q.head];</span><br><span class="line">        q.tail++;</span><br><span class="line">        <span class="hljs-comment">//删除 </span></span><br><span class="line">        q.head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> a[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 回文数 </span></span><br><span class="line">    <span class="hljs-keyword">char</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">101</span>]; <span class="hljs-comment">//栈 </span></span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    <span class="hljs-keyword">int</span> len, mid, top, next; </span><br><span class="line">    gets(a); <span class="hljs-comment">//得到字符串 </span></span><br><span class="line">    len = <span class="hljs-built_in">strlen</span>(a); <span class="hljs-comment">//得到长度 </span></span><br><span class="line">    mid = len/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; <span class="hljs-comment">//中点 </span></span><br><span class="line">    top = <span class="hljs-number">0</span>; <span class="hljs-comment">// 栈顶指向 </span></span><br><span class="line">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=mid; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">stack</span>[++top] = a[i]; <span class="hljs-comment">//入栈 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//判断数字长度为奇数还是偶数 </span></span><br><span class="line">    <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = mid + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        next = mid + <span class="hljs-number">2</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 判断是否为回文数 </span></span><br><span class="line">    <span class="hljs-keyword">for</span>(i=next; i&lt;=len<span class="hljs-number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-built_in">stack</span>[top])</span><br><span class="line">          <span class="hljs-keyword">break</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//  top = 0 相当于 全部出栈 即 为回文数 </span></span><br><span class="line">    <span class="hljs-keyword">if</span>(top == <span class="hljs-number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"我觉得ok"</span>); </span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"我觉得不行"</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//输入输出操作</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="hljs-comment">//节点结构体 </span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">   <span class="hljs-keyword">int</span> data;</span><br><span class="line">   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;    </span><br><span class="line">     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">head</span>, *<span class="hljs-title">p</span>, *<span class="hljs-title">q</span>, *<span class="hljs-title">t</span>;</span></span><br><span class="line">     <span class="hljs-keyword">int</span> i,n,data_input;</span><br><span class="line">     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<span class="hljs-comment">// 输入 数据的个数 </span></span><br><span class="line">     head = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//头结点 </span></span><br><span class="line">     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;data_input);</span><br><span class="line">         <span class="hljs-comment">//动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 </span></span><br><span class="line">         p = (struct node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct node));</span><br><span class="line">         p-&gt;data = data_input;<span class="hljs-comment">// 将数据存储到当前 结点的 data中 </span></span><br><span class="line">         p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置当前的结点 的后继指针为NULL，也就是当前结点的下一个结点为NULL </span></span><br><span class="line">         <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             head = p; <span class="hljs-comment">// 如果这个是第一个 创建的结点  则将 这个头指针指向这个结点 </span></span><br><span class="line">         &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">             q-&gt;next = p;<span class="hljs-comment">//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 </span></span><br><span class="line">         &#125;</span><br><span class="line">         q = p;<span class="hljs-comment">//q也指向当前结点 </span></span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     t = head;</span><br><span class="line">     <span class="hljs-keyword">while</span>(t!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,t-&gt;data); <span class="hljs-comment">//输出所有的数 </span></span><br><span class="line">         t = t-&gt;next; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//插入操作</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="hljs-comment">//节点结构体 </span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">   <span class="hljs-keyword">int</span> data;</span><br><span class="line">   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;    </span><br><span class="line">     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">head</span>, *<span class="hljs-title">p</span>, *<span class="hljs-title">q</span>, *<span class="hljs-title">t</span>;</span></span><br><span class="line">     <span class="hljs-keyword">int</span> i,n,data_input;</span><br><span class="line">     <span class="hljs-keyword">int</span> data_insert;</span><br><span class="line">     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<span class="hljs-comment">// 输入 数据的个数 </span></span><br><span class="line">     head = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//头结点 </span></span><br><span class="line">     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;data_input);</span><br><span class="line">         <span class="hljs-comment">//动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 </span></span><br><span class="line">         p = (struct node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct node));</span><br><span class="line">         p-&gt;data = data_input;<span class="hljs-comment">// 将数据存储到当前 结点的 data中 </span></span><br><span class="line">         p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置当前的结点 的后继指针为NULL，也就是当前结点的下一个结点为NULL </span></span><br><span class="line">         <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             head = p; <span class="hljs-comment">// 如果这个是第一个 创建的结点  则将 这个头指针指向这个结点 </span></span><br><span class="line">         &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">             q-&gt;next = p;<span class="hljs-comment">//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 </span></span><br><span class="line">         &#125;</span><br><span class="line">         q = p;<span class="hljs-comment">//q也指向当前结点 </span></span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="hljs-comment">//************** 插入操作**********************//</span></span><br><span class="line">     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;data_insert); <span class="hljs-comment">//  输入插入的值 </span></span><br><span class="line">     t = head;  <span class="hljs-comment">//  链表头 </span></span><br><span class="line">     <span class="hljs-keyword">while</span>(t!=<span class="hljs-literal">NULL</span>) </span><br><span class="line">     &#123;</span><br><span class="line">          <span class="hljs-comment">// 如果 当前结点 是最后一个结点或者下一个结点 的值大于 插入数的时候插入 </span></span><br><span class="line">         <span class="hljs-keyword">if</span>((t-&gt;next==<span class="hljs-literal">NULL</span>)||(t-&gt;next-&gt;data &gt;data_insert))</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="hljs-comment">// 创建 缓存 </span></span><br><span class="line">              p = (struct node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct node));</span><br><span class="line">              p-&gt;data = data_insert;</span><br><span class="line">              p-&gt;next = t-&gt;next;<span class="hljs-comment">// 新增结点的后继指针  等于 此时结点的后继结点的指向  即 新增结点 指向 此时结点的下一个指向 </span></span><br><span class="line">              <span class="hljs-comment">// 此时结点的后继指针指向  这个新增结点 </span></span><br><span class="line">              t-&gt;next = p;</span><br><span class="line">              <span class="hljs-keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="hljs-comment">//继续下一个结点（相当于遍历） </span></span><br><span class="line">         t = t-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     t = head;</span><br><span class="line">     <span class="hljs-keyword">while</span>(t!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,t-&gt;data);</span><br><span class="line">         t = t-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;持续更新…&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="死磕系列" scheme="https://uppez.github.io/categories/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="https://uppez.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何不发疯的阅读论文</title>
    <link href="https://uppez.github.io/2019/10/12/%E5%A6%82%E4%BD%95%E4%B8%8D%E5%8F%91%E7%96%AF%E7%9A%84%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    <id>https://uppez.github.io/2019/10/12/如何不发疯的阅读论文/</id>
    <published>2019-10-11T23:17:55.000Z</published>
    <updated>2019-10-12T04:39:52.551Z</updated>
    
    <content type="html"><![CDATA[<p>转载自新智元</p><a id="more"></a><blockquote><p>数学真的很重要！<br><strong>IcyBaba</strong>：很多论文所使用的数学是类似的，学术论文的海洋是无限的，但数学是有限的基石。学好数学，你会开始觉得所有的论文或多或少都是使用相同的积木搭建而成。<br><a href="https://sm.ms/image/RqguJSyakQLY3Di" target="_blank"><img src="https://i.loli.net/2019/10/12/RqguJSyakQLY3Di.jpg"></a><br><strong>approximately_wrong</strong>：我的一位导师告诉我，他曾经仔细阅读了一篇论文中的所有定理和证明，然后想到“数学家可能会认为这篇论文很烂”。乐观地说，我认为重要的不仅是数学的深度，还有你如何用它来解决在你的领域里有价值的问题:-)<br><strong>MaxMachineLearning</strong>：在工业界做了两年机器学习后，我开始攻读数学研究生。我的研究重点是将代数拓扑工具在机器学习中的应用。我的导师没有机器学习方面的背景，他所知的仅仅是我提出的一些关于这个领域的基本事实，然而他在几分钟之内就注意到了该领域真正的成果。另一位研究非交换几何的教授说，这些结果是从数学中得到的相对简单的结果，并对其进行解释/应用。<br><strong>IcyBaba</strong>：至少以粗略的方式阅读各种论文是件好事，因为即使你不了解如何实现这些论文，你也会知道有这样的方法/想法存在，并且当有机会或当它与你的研究相关性很大时，你可以回过头来深入阅读。将这些论文视为工具箱中的可能有用的工具就行。</p></blockquote><h2 id="论文应该这样读：读几百篇论文之后，就容易多了"><a href="#论文应该这样读：读几百篇论文之后，就容易多了" class="headerlink" title="论文应该这样读：读几百篇论文之后，就容易多了"></a>论文应该这样读：读几百篇论文之后，就容易多了</h2><p><strong>MikeVladimirov</strong>：如果你对阅读论文有“暴饮暴食”的情绪，我的建议是阅读<strong>综述</strong>。在40-60页的综述文章中，你通常能够以一种优美、整洁、结构化、条理清晰的方式获取100-200篇论文中的重要信息。</p><p>当你阅读了2-3篇最近(过去5年内)的综述论文后，你会发现三点：</p><ol><li><p>总是被引用的论文；</p></li><li><p>其具体工作听起来很酷或很相关的作者；</p></li><li><p>你感兴趣的子领域中相对较新的进展，以及关于这些主题的值得注意的论文。</p></li></ol><p>一旦有了这三点，那么你就很清楚接下来该读什么，为什么读，以及读的顺序了。</p><p>还有，我再怎么强调都不为过的是，一定要确保你在阅读的同时进行输出。哪怕只是在OneNote或思维导图应用中做笔记。只要确保将相关的思想联系在一起，并跟踪这些思想的准确引用即可。相信我，对关键概念做一点文献笔记很有必要，当你为了找到一个准确的引用需要回顾1-3年前读过的论文时，你会发现将两个关键思想联系在一起很有帮助。</p><p><a href="https://sm.ms/image/RE2YnwqHXUof1rp" target="_blank"><img src="https://i.loli.net/2019/10/12/RE2YnwqHXUof1rp.jpg"></a></p><p><strong>duckbill_principate</strong>：每个人都经历过这样的阶段。<strong>当你读了几百篇论文之后，就会变得容易多了</strong>。</p><p><strong>RememberToBackupData</strong>：最重要的是，你要回答一个具体的问题。提出这样一个问题，可以帮助你在一分钟内确定这篇论文是否包含答案。</p><p><strong>jurniss</strong>：标准的机器学习论文结构可以让你以不同的深度阅读论文：</p><ul><li><p>“<strong>摘要</strong>”可以帮助排除与你的兴趣无关的论文。</p></li><li><p>“<strong>引言</strong>”可以轻松阅读，能够告诉你：a)这个想法是否有趣，b)理论贡献是否重要，和/或c)实证结果是否强大。</p></li><li><p>“<strong>引言+方法</strong>”部分应该足够描述该理论的完整视图，而“<strong>引言+实验</strong>”应该能够给出关于“性能”的完整视图。你可以分别消化理论部分和实证部分。</p></li></ul><p>一旦你理解了该领域足够多的基本概念，并且更加明确自己的兴趣，那么你将只是偶尔仔细阅读论文的每个单词和公式。更常见的是略读，理解基本思想，然后认为它对你来说不够有趣而不用去深入阅读。</p><h2 id="学会放下：5分钟-1小时定律"><a href="#学会放下：5分钟-1小时定律" class="headerlink" title="学会放下：5分钟/1小时定律"></a>学会放下：5分钟/1小时定律</h2><p><strong>adventuringraw</strong>：我实际上跟up主有类似的困惑，这绝对也是我的挣扎。我意识到我的一些经验或许可以作为参考。</p><p>介绍一下<strong>5分钟/1小时定律</strong>。如果你能在5分钟内意识到一篇论文可能不是你现在需要学习的东西，非常棒！这样你只浪费了5分钟的时间就可以进行下一步操作了。</p><p>但如果你一旦决定要继续阅读这篇论文，那么就要开启战斗状态了。梦想着去学习所有知识不过是精神自嗨而已，战斗状态需要的是厘清并组织自己希望获得的收获，这一点很重要。</p><p>比如，你希望该论文具体回答哪些问题？记下来；到目前为止你获得了什么启发？写下来。因为在阅读过程中，你肯定会发现一些想法、见解和潜在的新论文（那些论文很难以有用的方式进行组织，因为从根本上来说，这是一种交叉注释的信息），如果不写下来就忘记了。</p><p>我是这样记笔记的：我会在Evernote中保存相当详细的笔记（可能是一到两页笔记），要研究的每篇论文都会写一个，这样搜索和查找以前想法会很容易。然后关闭当前的笔记，创建另一个笔记，复制标题、摘要和arxiv链接以及对我的最初问题进行梳理，这一切都让我感到非常痛苦。</p><p>接下来，我会问自己：我真的需要切换到另一篇论文吗？好的，该采取行动了；最好能有一个具体的项目或正在研究的问题，这将非常有用；现在真的是时候开始阅读图形嵌入了吗？这实际上与我正在从事的核心项目有关吗？我当前打开的“我需要回答这些问题”的清单在哪里？它们中的任何一个是否适用于这篇似乎挺有趣的论文？没有？好吧，继续前进。</p><p><strong>IndiaNgineer</strong>：<strong>随手列出问题清单</strong>，一定要抵制立即查找你遇到的不理解内容的冲动！并在获得答案时写下答案，仅在读完论文之后，才去查阅里面的知识点。</p><p>慢慢地，随着你的进步，你将开始了解更多，并且由于你已经积累了框架，很多让你早期感觉困惑的知识点开始变得不言而喻。对于我来说，很多时候我会浏览论文中的公式。因为人们的写作风格和某些单词背后的含义含糊不清，但是公式是清晰的。</p><p>另外，不要按论文大纲给出的顺序阅读该论文。对我而言，最有效的顺序是阅读摘要，然后是方法、结果、讨论、结论。前言最后看，或者甚至可以不用看，这取决于你对该领域的熟练程度。</p><p><strong>eviljelloman</strong>：不要“阅读”论文。听我说。</p><p>你应该有两种使用论文内容的模式：略读和精读。这些都不是硬着头皮从头读到尾然后说“完成了阅读”。当需要了解研究主体的背景时，你需要略读。浏览图表，阅读摘要和结论，记下你以后要看的论文。如果该论文似乎特别相关，请将其归档以供以后研究。</p><p>在精读模式下，你将深入研究那篇论文的内容，别在意对其他论文的引用。当你看到“带有一些推导…”的内容时，要在便条纸上做笔记，阅读注释，研究数学，然后列出公式。</p><p>这听起来似乎需要很大的工作量，事实也如此。这就是为什么你需要有选择性的阅读论文，大部分论文略读即可，少数论文需要精读。</p><p>当你执行任何大型，复杂的项目时，你就是你自己的项目经理。这意味着你需要学习项目管理技能。你可以使用任务组织/工作跟踪工具，甚至电子表格来计划和确定工作的优先级。</p><p><strong>Whitishcube</strong>：我认为你得<strong>学会“放下”</strong>，不用非得去知道所有的事情。在许多领域中，不可能阅读每篇研究论文，也不可能100％了解每篇论文的内容，这没关系。你应该将某个领域的某些方面发展自己的专业知识，对于其他部分，你应该与他人进行交谈或合作。</p><p>阅读论文是有策略的。最重要的是，你应该记住一个要回答的问题。这将帮助你缩小选择阅读的论文的范围。然后，一旦确定了几篇你认为会有所帮助的论文，可以略读，以了解其中的内容。不要一上来就从头读完，你的目标是在此浏览过程中清除无用的论文。</p><p>选择了几篇论文后，请阅读主要论点并尝试感受一下。至此，你只需要阅读少量内容，而不是不可能完成的长长的列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自新智元&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="论文-续" scheme="https://uppez.github.io/tags/%E8%AE%BA%E6%96%87-%E7%BB%AD/"/>
    
  </entry>
  
  <entry>
    <title>用中文方式打开英文论文</title>
    <link href="https://uppez.github.io/2019/10/08/%E7%94%A8%E4%B8%AD%E6%96%87%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87/"/>
    <id>https://uppez.github.io/2019/10/08/用中文方式打开英文论文/</id>
    <published>2019-10-08T09:51:05.000Z</published>
    <updated>2019-10-09T10:20:10.574Z</updated>
    
    <content type="html"><![CDATA[<p>阅读论文最头疼的事情就是满屏的英文使我们恐惧到要死，那么有没有什么解决方案呢？</p><a id="more"></a><h1 id="查找到翻译好的论文"><a href="#查找到翻译好的论文" class="headerlink" title="查找到翻译好的论文"></a>查找到翻译好的论文</h1><ol><li><p>通天塔：<a href="http://tongtianta.site/" target="_blank" rel="noopener">http://tongtianta.site/</a></p></li><li><p>百度查找: <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p></li></ol><h1 id="自己进行论文的翻译"><a href="#自己进行论文的翻译" class="headerlink" title="自己进行论文的翻译"></a>自己进行论文的翻译</h1><ol><li><p>使用微软的word文档自带的全文翻译，使用方法请看：<a href="https://www.zhihu.com/question/20218881" target="_blank" rel="noopener">https://www.zhihu.com/question/20218881</a></p></li><li><p>MedSci翻译：<a href="http://www.medsci.cn/sci/translation.do" target="_blank" rel="noopener">http://www.medsci.cn/sci/translation.do</a></p></li><li><p>google翻译：<a href="https://translate.google.com/" target="_blank" rel="noopener">https://translate.google.com/</a></p></li><li><p>百度翻译：<a href="https://fanyi.baidu.com/" target="_blank" rel="noopener">https://fanyi.baidu.com/</a></p></li><li><p>翻译助手(专业词汇翻译)：<a href="http://dict.cnki.net/" target="_blank" rel="noopener">http://dict.cnki.net/</a></p></li></ol><h1 id="翻译软件"><a href="#翻译软件" class="headerlink" title="翻译软件"></a>翻译软件</h1><ol><li><p>网易有道翻译：<a href="http://cidian.youdao.com/" target="_blank" rel="noopener">http://cidian.youdao.com/</a></p></li><li><p>SCI Translate：<a href="https://www.sogou.com/sogou?ie=utf8&amp;query=SCI+Translate5.0&amp;pid=A83,z-7707" target="_blank" rel="noopener">https://www.sogou.com/sogou?ie=utf8&amp;query=SCI+Translate5.0&amp;pid=A83,z-7707</a></p></li></ol><h1 id="其他翻译方式"><a href="#其他翻译方式" class="headerlink" title="其他翻译方式"></a>其他翻译方式</h1><p>寻找专业的大型翻译平台，<strong>付款</strong>，<strong>人工翻译</strong>，准确，内容精确，但<strong>价格昂贵</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读论文最头疼的事情就是满屏的英文使我们恐惧到要死，那么有没有什么解决方案呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="论文翻译" scheme="https://uppez.github.io/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>python验证码识别</title>
    <link href="https://uppez.github.io/2019/10/07/python%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>https://uppez.github.io/2019/10/07/python验证码识别/</id>
    <published>2019-10-07T12:01:45.000Z</published>
    <updated>2019-10-07T12:35:20.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据集获取"><a href="#数据集获取" class="headerlink" title="数据集获取"></a>数据集获取</h1><p>链接：<a href="https://pan.baidu.com/s/1aLFV-QovCeig4bGaS8U_8w" target="_blank" rel="noopener">https://pan.baidu.com/s/1aLFV-QovCeig4bGaS8U_8w</a>  ,提取码：5u9h </p><a id="more"></a><h1 id="图片源码下载"><a href="#图片源码下载" class="headerlink" title="图片源码下载"></a>图片源码下载</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlretrieve</span><br><span class="line"><span class="hljs-keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Discuz</span><span class="hljs-params">()</span>:</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line"><span class="hljs-comment"># Discuz验证码生成图片地址</span></span><br><span class="line">self.url = <span class="hljs-string">'http://cuijiahua.com/tutrial/discuz/index.php?label='</span> <span class="hljs-comment">#地址失效，请更换！！！</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_captcha_text</span><span class="hljs-params">(self, captcha_size = <span class="hljs-number">4</span>)</span>:</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">验证码一般都无视大小写；验证码长度4个字符</span></span><br><span class="line"><span class="hljs-string">Parameters:</span></span><br><span class="line"><span class="hljs-string">captcha_size:验证码长度</span></span><br><span class="line"><span class="hljs-string">Returns:</span></span><br><span class="line"><span class="hljs-string">captcha_text:验证码字符串</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line">number = [<span class="hljs-string">'0'</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span>]</span><br><span class="line">alphabet = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>,<span class="hljs-string">'g'</span>,<span class="hljs-string">'h'</span>,<span class="hljs-string">'i'</span>,<span class="hljs-string">'j'</span>,<span class="hljs-string">'k'</span>,<span class="hljs-string">'l'</span>,<span class="hljs-string">'m'</span>,<span class="hljs-string">'n'</span>,<span class="hljs-string">'o'</span>,<span class="hljs-string">'p'</span>,<span class="hljs-string">'q'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'s'</span>,<span class="hljs-string">'t'</span>,<span class="hljs-string">'u'</span>,<span class="hljs-string">'v'</span>,<span class="hljs-string">'w'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>]</span><br><span class="line">char_set = number + alphabet</span><br><span class="line">captcha_text = []</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(captcha_size):</span><br><span class="line">c = random.choice(char_set)</span><br><span class="line">captcha_text.append(c)</span><br><span class="line">captcha_text = <span class="hljs-string">''</span>.join(captcha_text)</span><br><span class="line"><span class="hljs-keyword">return</span> captcha_text</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_discuz</span><span class="hljs-params">(self, nums = <span class="hljs-number">50000</span>)</span>:</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">下载验证码图片</span></span><br><span class="line"><span class="hljs-string">Parameters:</span></span><br><span class="line"><span class="hljs-string">nums:下载的验证码图片数量</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line">dirname = <span class="hljs-string">'./pic'</span></span><br><span class="line"><span class="hljs-keyword">if</span> dirname <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> os.listdir():</span><br><span class="line">os.mkdir(dirname)</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nums):</span><br><span class="line">label = self.random_captcha_text()</span><br><span class="line">print(<span class="hljs-string">'第%d张图片:%s下载'</span> % (i + <span class="hljs-number">1</span>,label))</span><br><span class="line">urlretrieve(url = self.url + label, filename = dirname + <span class="hljs-string">'/'</span> + label + <span class="hljs-string">'.jpg'</span>)</span><br><span class="line"><span class="hljs-comment"># 请至少加200ms延时，避免给我的服务器造成过多的压力，如发现影响服务器正常工作，我会关闭此功能。</span></span><br><span class="line"><span class="hljs-comment"># 你好我也好，大家好才是真的好！</span></span><br><span class="line">time.sleep(<span class="hljs-number">0.1</span>)</span><br><span class="line">print(<span class="hljs-string">'恭喜图片下载完成！'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">dz = Discuz()</span><br><span class="line">dz.download_discuz()</span><br></pre></td></tr></table></figure><h1 id="数据训练测试"><a href="#数据训练测试" class="headerlink" title="数据训练测试"></a>数据训练测试</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> os, random, cv2</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Discuz</span><span class="hljs-params">()</span>:</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 数据集路径</span></span><br><span class="line">self.data_path = <span class="hljs-string">'./pic/'</span></span><br><span class="line"><span class="hljs-comment"># 写到指定的磁盘路径中 </span></span><br><span class="line">self.log_dir = <span class="hljs-string">'./logs/'</span></span><br><span class="line"><span class="hljs-comment"># 数据集图片大小</span></span><br><span class="line">self.width = <span class="hljs-number">30</span></span><br><span class="line">self.heigth = <span class="hljs-number">100</span></span><br><span class="line"><span class="hljs-comment"># 最大迭代次数</span></span><br><span class="line">self.max_steps = <span class="hljs-number">100</span></span><br><span class="line"><span class="hljs-comment"># 读取数据集</span></span><br><span class="line">self.test_imgs, self.test_labels, self.train_imgs, self.train_labels = self.get_imgs()</span><br><span class="line"><span class="hljs-comment"># 训练集大小</span></span><br><span class="line">self.train_size = len(self.train_imgs)</span><br><span class="line"><span class="hljs-comment"># 测试集大小</span></span><br><span class="line">self.test_size = len(self.test_imgs)</span><br><span class="line"><span class="hljs-comment"># 每次获得batch_size大小的当前训练集指针</span></span><br><span class="line">self.train_ptr = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment"># 每次获取batch_size大小的当前测试集指针</span></span><br><span class="line">self.test_ptr = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment"># 字符字典大小:0-9 a-z A-Z _(验证码如果小于4，用_补齐) 一共63个字符</span></span><br><span class="line">self.char_set_len = <span class="hljs-number">63</span></span><br><span class="line"><span class="hljs-comment"># 验证码最长的长度为4</span></span><br><span class="line">self.max_captcha = <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-comment"># 输入数据X占位符</span></span><br><span class="line">self.X = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, self.heigth*self.width])</span><br><span class="line"><span class="hljs-comment"># 输入数据Y占位符</span></span><br><span class="line">self.Y = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, self.char_set_len*self.max_captcha])</span><br><span class="line"><span class="hljs-comment"># keepout占位符</span></span><br><span class="line">self.keep_prob = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_imgs</span><span class="hljs-params">(self, rate = <span class="hljs-number">0.2</span>)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 读取图片</span></span><br><span class="line">imgs = os.listdir(self.data_path)</span><br><span class="line"><span class="hljs-comment"># 打乱图片顺序</span></span><br><span class="line">random.shuffle(imgs)</span><br><span class="line"><span class="hljs-comment"># 数据集总共个数</span></span><br><span class="line">imgs_num = len(imgs)</span><br><span class="line"><span class="hljs-comment"># 按照比例求出测试集个数</span></span><br><span class="line">test_num = int(imgs_num * rate / (<span class="hljs-number">1</span> + rate))</span><br><span class="line"><span class="hljs-comment"># 测试集</span></span><br><span class="line">test_imgs = imgs[:test_num]</span><br><span class="line"><span class="hljs-comment"># 根据文件名获取测试集标签</span></span><br><span class="line">test_labels = list(map(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>], test_imgs))</span><br><span class="line"><span class="hljs-comment"># 训练集</span></span><br><span class="line">train_imgs = imgs[test_num:]</span><br><span class="line"><span class="hljs-comment"># 根据文件名获取训练集标签</span></span><br><span class="line">train_labels = list(map(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>], train_imgs))</span><br><span class="line"><span class="hljs-keyword">return</span> test_imgs, test_labels, train_imgs, train_labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_next_batch</span><span class="hljs-params">(self, train_flag=True, batch_size=<span class="hljs-number">100</span>)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 从训练集获取数据</span></span><br><span class="line"><span class="hljs-keyword">if</span> train_flag == <span class="hljs-literal">True</span>:</span><br><span class="line"><span class="hljs-keyword">if</span> (batch_size + self.train_ptr) &lt; self.train_size:</span><br><span class="line">trains = self.train_imgs[self.train_ptr:(self.train_ptr + batch_size)]</span><br><span class="line">labels = self.train_labels[self.train_ptr:(self.train_ptr + batch_size)]</span><br><span class="line">self.train_ptr += batch_size</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">new_ptr = (self.train_ptr + batch_size) % self.train_size</span><br><span class="line">trains = self.train_imgs[self.train_ptr:] + self.train_imgs[:new_ptr]</span><br><span class="line">labels = self.train_labels[self.train_ptr:] + self.train_labels[:new_ptr]</span><br><span class="line">self.train_ptr = new_ptr</span><br><span class="line"></span><br><span class="line">batch_x = np.zeros([batch_size, self.heigth*self.width])</span><br><span class="line">batch_y = np.zeros([batch_size, self.max_captcha*self.char_set_len])</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> index, train <span class="hljs-keyword">in</span> enumerate(trains):</span><br><span class="line">img = np.mean(cv2.imread(self.data_path + train), <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-comment"># 将多维降维1维</span></span><br><span class="line">batch_x[index,:] = img.flatten() / <span class="hljs-number">255</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, label <span class="hljs-keyword">in</span> enumerate(labels):</span><br><span class="line">batch_y[index,:] = self.text2vec(label)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 从测试集获取数据</span></span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line"><span class="hljs-keyword">if</span> (batch_size + self.test_ptr) &lt; self.test_size:</span><br><span class="line">tests = self.test_imgs[self.test_ptr:(self.test_ptr + batch_size)]</span><br><span class="line">labels = self.test_labels[self.test_ptr:(self.test_ptr + batch_size)]</span><br><span class="line">self.test_ptr += batch_size</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">new_ptr = (self.test_ptr + batch_size) % self.test_size</span><br><span class="line">tests = self.test_imgs[self.test_ptr:] + self.test_imgs[:new_ptr]</span><br><span class="line">labels = self.test_labels[self.test_ptr:] + self.test_labels[:new_ptr]</span><br><span class="line">self.test_ptr = new_ptr</span><br><span class="line"></span><br><span class="line">batch_x = np.zeros([batch_size, self.heigth*self.width])</span><br><span class="line">batch_y = np.zeros([batch_size, self.max_captcha*self.char_set_len])</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> index, test <span class="hljs-keyword">in</span> enumerate(tests):</span><br><span class="line">img = np.mean(cv2.imread(self.data_path + test), <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-comment"># 将多维降维1维</span></span><br><span class="line">batch_x[index,:] = img.flatten() / <span class="hljs-number">255</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, label <span class="hljs-keyword">in</span> enumerate(labels):</span><br><span class="line">batch_y[index,:] = self.text2vec(label)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> batch_x, batch_y</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">text2vec</span><span class="hljs-params">(self, text)</span>:</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">文本转向量</span></span><br><span class="line"><span class="hljs-string">Parameters:</span></span><br><span class="line"><span class="hljs-string">text:文本</span></span><br><span class="line"><span class="hljs-string">Returns:</span></span><br><span class="line"><span class="hljs-string">vector:向量</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-keyword">if</span> len(text) &gt; <span class="hljs-number">4</span>:</span><br><span class="line"><span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'验证码最长4个字符'</span>)</span><br><span class="line"></span><br><span class="line">vector = np.zeros(<span class="hljs-number">4</span> * self.char_set_len)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char2pos</span><span class="hljs-params">(c)</span>:</span></span><br><span class="line"><span class="hljs-keyword">if</span> c ==<span class="hljs-string">'_'</span>:</span><br><span class="line">k = <span class="hljs-number">62</span></span><br><span class="line"><span class="hljs-keyword">return</span> k</span><br><span class="line">k = ord(c) - <span class="hljs-number">48</span></span><br><span class="line"><span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">9</span>:</span><br><span class="line">k = ord(c) - <span class="hljs-number">55</span></span><br><span class="line"><span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">35</span>:</span><br><span class="line">k = ord(c) - <span class="hljs-number">61</span></span><br><span class="line"><span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">61</span>:</span><br><span class="line"><span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'No Map'</span>) </span><br><span class="line"><span class="hljs-keyword">return</span> k</span><br><span class="line"><span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> enumerate(text):</span><br><span class="line">idx = i * self.char_set_len + char2pos(c)</span><br><span class="line">vector[idx] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">return</span> vector</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vec2text</span><span class="hljs-params">(self, vec)</span>:</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">向量转文本</span></span><br><span class="line"><span class="hljs-string">Parameters:</span></span><br><span class="line"><span class="hljs-string">vec:向量</span></span><br><span class="line"><span class="hljs-string">Returns:</span></span><br><span class="line"><span class="hljs-string">文本</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line">char_pos = vec.nonzero()[<span class="hljs-number">0</span>]</span><br><span class="line">text = []</span><br><span class="line"><span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> enumerate(char_pos):</span><br><span class="line">char_at_pos = i <span class="hljs-comment">#c/63</span></span><br><span class="line">char_idx = c % self.char_set_len</span><br><span class="line"><span class="hljs-keyword">if</span> char_idx &lt; <span class="hljs-number">10</span>:</span><br><span class="line">char_code = char_idx + ord(<span class="hljs-string">'0'</span>)</span><br><span class="line"><span class="hljs-keyword">elif</span> char_idx &lt; <span class="hljs-number">36</span>:</span><br><span class="line">char_code = char_idx - <span class="hljs-number">10</span> + ord(<span class="hljs-string">'A'</span>)</span><br><span class="line"><span class="hljs-keyword">elif</span> char_idx &lt; <span class="hljs-number">62</span>:</span><br><span class="line">char_code = char_idx - <span class="hljs-number">36</span> + ord(<span class="hljs-string">'a'</span>)</span><br><span class="line"><span class="hljs-keyword">elif</span> char_idx == <span class="hljs-number">62</span>:</span><br><span class="line">char_code = ord(<span class="hljs-string">'_'</span>)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line"><span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'error'</span>)</span><br><span class="line">text.append(chr(char_code))</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(text)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crack_captcha_cnn</span><span class="hljs-params">(self, w_alpha=<span class="hljs-number">0.01</span>, b_alpha=<span class="hljs-number">0.1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">x = tf.reshape(self.X, shape=[<span class="hljs-number">-1</span>, self.heigth, self.width, <span class="hljs-number">1</span>])</span><br><span class="line"><span class="hljs-comment"># 卷积的filter:一个Tensor。数据维度是四维[filter_height, filter_width, in_channels, out_channels]</span></span><br><span class="line"><span class="hljs-comment"># 具体含义是[卷积核的高度, 卷积核的宽度, 图像通道数, 卷积核个数]</span></span><br><span class="line">w_c1 = tf.Variable(w_alpha*tf.random_normal([<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>]))</span><br><span class="line">b_c1 = tf.Variable(b_alpha*tf.random_normal([<span class="hljs-number">32</span>]))</span><br><span class="line">conv1 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(x, w_c1, strides=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">'SAME'</span>), b_c1))</span><br><span class="line"></span><br><span class="line">conv1 = tf.nn.max_pool(conv1, ksize=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], strides=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">'SAME'</span>)</span><br><span class="line">w_c2 = tf.Variable(w_alpha*tf.random_normal([<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>]))</span><br><span class="line">b_c2 = tf.Variable(b_alpha*tf.random_normal([<span class="hljs-number">64</span>]))</span><br><span class="line">conv2 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv1, w_c2, strides=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">'SAME'</span>), b_c2))</span><br><span class="line"></span><br><span class="line">conv2 = tf.nn.max_pool(conv2, ksize=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], strides=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">'SAME'</span>)</span><br><span class="line">w_c3 = tf.Variable(w_alpha*tf.random_normal([<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>]))</span><br><span class="line">b_c3 = tf.Variable(b_alpha*tf.random_normal([<span class="hljs-number">64</span>]))</span><br><span class="line"></span><br><span class="line">conv3 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv2, w_c3, strides=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">'SAME'</span>), b_c3))</span><br><span class="line">conv3 = tf.nn.max_pool(conv3, ksize=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], strides=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">'SAME'</span>)</span><br><span class="line">w_d = tf.Variable(w_alpha*tf.random_normal([<span class="hljs-number">4</span>*<span class="hljs-number">13</span>*<span class="hljs-number">64</span>, <span class="hljs-number">1024</span>]))</span><br><span class="line">b_d = tf.Variable(b_alpha*tf.random_normal([<span class="hljs-number">1024</span>]))</span><br><span class="line"></span><br><span class="line">dense = tf.reshape(conv3, [<span class="hljs-number">-1</span>, w_d.get_shape().as_list()[<span class="hljs-number">0</span>]])</span><br><span class="line">dense = tf.nn.relu(tf.add(tf.matmul(dense, w_d), b_d))</span><br><span class="line">dense = tf.nn.dropout(dense, self.keep_prob)</span><br><span class="line"></span><br><span class="line">w_out = tf.Variable(w_alpha*tf.random_normal([<span class="hljs-number">1024</span>, self.max_captcha*self.char_set_len]))</span><br><span class="line">b_out = tf.Variable(b_alpha*tf.random_normal([self.max_captcha*self.char_set_len]))</span><br><span class="line">out = tf.add(tf.matmul(dense, w_out), b_out)</span><br><span class="line"><span class="hljs-keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train_crack_captcha_cnn</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">output = self.crack_captcha_cnn()</span><br><span class="line"><span class="hljs-comment"># 创建损失函数</span></span><br><span class="line">diff = tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=self.Y)</span><br><span class="line">loss = tf.reduce_mean(diff)</span><br><span class="line">tf.summary.scalar(<span class="hljs-string">'loss'</span>, loss)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 使用AdamOptimizer优化器训练模型，最小化交叉熵损失</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=<span class="hljs-number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 计算准确率</span></span><br><span class="line">y = tf.reshape(output, [<span class="hljs-number">-1</span>, self.max_captcha, self.char_set_len])</span><br><span class="line">y_ = tf.reshape(self.Y, [<span class="hljs-number">-1</span>, self.max_captcha, self.char_set_len])</span><br><span class="line">correct_pred = tf.equal(tf.argmax(y, <span class="hljs-number">2</span>), tf.argmax(y_, <span class="hljs-number">2</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span><br><span class="line">tf.summary.scalar(<span class="hljs-string">'accuracy'</span>, accuracy)</span><br><span class="line"></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:</span><br><span class="line"><span class="hljs-comment"># 写到指定的磁盘路径中</span></span><br><span class="line">train_writer = tf.summary.FileWriter(self.log_dir + <span class="hljs-string">'/train'</span>, sess.graph)</span><br><span class="line">test_writer = tf.summary.FileWriter(self.log_dir + <span class="hljs-string">'/test'</span>)</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 遍历self.max_steps次</span></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.max_steps):</span><br><span class="line"><span class="hljs-comment"># 迭代500次，打乱一下数据集</span></span><br><span class="line"><span class="hljs-keyword">if</span> i % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>:</span><br><span class="line">self.test_imgs, self.test_labels, self.train_imgs, self.train_labels = self.get_imgs()</span><br><span class="line"><span class="hljs-comment"># 每10次，使用测试集，测试一下准确率</span></span><br><span class="line"><span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:</span><br><span class="line">batch_x_test, batch_y_test = self.get_next_batch(<span class="hljs-literal">False</span>, <span class="hljs-number">100</span>)</span><br><span class="line">summary, acc = sess.run([merged, accuracy], feed_dict=&#123;self.X: batch_x_test, self.Y: batch_y_test, self.keep_prob: <span class="hljs-number">1</span>&#125;)</span><br><span class="line">print(<span class="hljs-string">'迭代第%d次 accuracy:%f'</span> % (i+<span class="hljs-number">1</span>, acc))</span><br><span class="line">test_writer.add_summary(summary, i)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 如果准确率大于85%，则保存模型并退出。</span></span><br><span class="line"><span class="hljs-keyword">if</span> acc &gt; <span class="hljs-number">0.85</span>:</span><br><span class="line">train_writer.close()</span><br><span class="line">test_writer.close()</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line"><span class="hljs-comment"># 一直训练</span></span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">batch_x, batch_y = self.get_next_batch(<span class="hljs-literal">True</span>, <span class="hljs-number">100</span>)</span><br><span class="line">loss_value, _ = sess.run([loss, optimizer], feed_dict=&#123;self.X: batch_x, self.Y: batch_y, self.keep_prob: <span class="hljs-number">1</span>&#125;)</span><br><span class="line">print(<span class="hljs-string">'迭代第%d次 loss:%f'</span> % (i+<span class="hljs-number">1</span>, loss_value))</span><br><span class="line">curve = sess.run(merged, feed_dict=&#123;self.X: batch_x_test, self.Y: batch_y_test, self.keep_prob: <span class="hljs-number">1</span>&#125;)</span><br><span class="line">train_writer.add_summary(curve, i)</span><br><span class="line"></span><br><span class="line">train_writer.close()</span><br><span class="line">test_writer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">dz = Discuz()</span><br><span class="line">dz.train_crack_captcha_cnn()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据集获取&quot;&gt;&lt;a href=&quot;#数据集获取&quot; class=&quot;headerlink&quot; title=&quot;数据集获取&quot;&gt;&lt;/a&gt;数据集获取&lt;/h1&gt;&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1aLFV-QovCeig4bGaS8U_8w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1aLFV-QovCeig4bGaS8U_8w&lt;/a&gt;  ,提取码：5u9h &lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://uppez.github.io/categories/Python/"/>
    
    
      <category term="tensorflow" scheme="https://uppez.github.io/tags/tensorflow/"/>
    
      <category term="验证码识别" scheme="https://uppez.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>一个全局最优化的方法：随机游走算法(Random Walk)</title>
    <link href="https://uppez.github.io/2019/10/07/%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E6%9C%80%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E7%AE%97%E6%B3%95-Random-Walk/"/>
    <id>https://uppez.github.io/2019/10/07/一个全局最优化的方法：随机游走算法-Random-Walk/</id>
    <published>2019-10-07T04:52:17.000Z</published>
    <updated>2019-10-07T05:04:02.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-关于全局最优化求解"><a href="#1-关于全局最优化求解" class="headerlink" title="1.关于全局最优化求解"></a>1.关于全局最优化求解</h1><p>全局最优化是一个非常复杂的问题，目前还没有一个通用的办法可以对任意复杂函数求解全局最优值。一个求解局部极小值的方法——<strong>梯度下降法</strong>。这种方法对于求解精度不高的情况是实用的，可以用局部极小值近似替代全局最小值点。但是当要求精确求解全局最小值时，梯度下降法就不适用了，需要采用其他的办法求解。常见的求解全局最优的办法有拉格朗日法、线性规划法、以及一些人工智能算法比如遗传算法、粒子群算法、模拟退火算法等。而今天要说的是一个操作简单但是不易陷入局部极小值的方法：随机游走算法。</p><a id="more"></a><h1 id="2-随机游走算法操作步骤"><a href="#2-随机游走算法操作步骤" class="headerlink" title="2.随机游走算法操作步骤"></a>2.随机游走算法操作步骤</h1><p><a href="https://sm.ms/image/WthINpsLg5mw91u" target="_blank"><img src="https://i.loli.net/2019/10/07/WthINpsLg5mw91u.png"></a></p><h1 id="3-随机游走的代码实现-使用Python"><a href="#3-随机游走的代码实现-使用Python" class="headerlink" title="3.随机游走的代码实现(使用Python)"></a>3.随机游走的代码实现(使用Python)</h1><p><a href="https://sm.ms/image/SvwY24oX75uxdgC" target="_blank"><img src="https://i.loli.net/2019/10/07/SvwY24oX75uxdgC.png"></a></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">@Description:使用随机游走算法求解函数极值</span></span><br><span class="line"><span class="hljs-string">这里求解:f = sin(r)/r + 1,r = sqrt((x-50)^2+(y-50)^2)+e,0&lt;=x,y&lt;=100 的最大值</span></span><br><span class="line"><span class="hljs-string">求解f的最大值，可以转化为求-f的最小值问题</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-keyword">from</span> __future__  <span class="hljs-keyword">import</span> print_function</span><br><span class="line"><span class="hljs-keyword">import</span> math</span><br><span class="line"><span class="hljs-keyword">import</span> random</span><br><span class="line">N = <span class="hljs-number">100</span> <span class="hljs-comment"># 迭代次数</span></span><br><span class="line">step = <span class="hljs-number">0.5</span> <span class="hljs-comment"># 初始步长</span></span><br><span class="line">epsilon = <span class="hljs-number">0.00001</span></span><br><span class="line">variables = <span class="hljs-number">2</span> <span class="hljs-comment"># 变量数目</span></span><br><span class="line">x = [<span class="hljs-number">49</span>,<span class="hljs-number">49</span>] <span class="hljs-comment"># 初始点坐标</span></span><br><span class="line">walk_num = <span class="hljs-number">1</span> <span class="hljs-comment"># 初始化随机游走次数</span></span><br><span class="line">print(<span class="hljs-string">"迭代次数:"</span>,N)</span><br><span class="line">print(<span class="hljs-string">"初始步长:"</span>,step)</span><br><span class="line">print(<span class="hljs-string">"epsilon:"</span>,epsilon)</span><br><span class="line">print(<span class="hljs-string">"变量数目:"</span>,variables)</span><br><span class="line">print(<span class="hljs-string">"初始点坐标:"</span>,x)</span><br><span class="line"><span class="hljs-comment"># 定义目标函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    r = math.sqrt((x[<span class="hljs-number">0</span>]<span class="hljs-number">-50</span>)**<span class="hljs-number">2</span> + (x[<span class="hljs-number">1</span>]<span class="hljs-number">-50</span>)**<span class="hljs-number">2</span>) + math.e</span><br><span class="line">    f = math.sin(r)/r + <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> -f</span><br><span class="line"><span class="hljs-comment"># 开始随机游走</span></span><br><span class="line"><span class="hljs-keyword">while</span>(step &gt; epsilon):</span><br><span class="line">    k = <span class="hljs-number">1</span> <span class="hljs-comment"># 初始化计数器</span></span><br><span class="line">    <span class="hljs-keyword">while</span>(k &lt; N):</span><br><span class="line">        u = [random.uniform(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(variables)] <span class="hljs-comment"># 随机向量</span></span><br><span class="line">        <span class="hljs-comment"># u1 为标准化之后的随机向量</span></span><br><span class="line">        u1 = [u[i]/math.sqrt(sum([u[i]**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(variables)])) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(variables)]</span><br><span class="line">        x1 = [x[i] + step*u1[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(variables)]</span><br><span class="line">        <span class="hljs-keyword">if</span>(function(x1) &lt; function(x)): <span class="hljs-comment"># 如果找到了更优点</span></span><br><span class="line">            k = <span class="hljs-number">1</span></span><br><span class="line">            x = x1</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            k += <span class="hljs-number">1</span></span><br><span class="line">    step = step/<span class="hljs-number">2</span></span><br><span class="line">    print(<span class="hljs-string">"第%d次随机游走完成。"</span> % walk_num)</span><br><span class="line">    walk_num += <span class="hljs-number">1</span></span><br><span class="line">print(<span class="hljs-string">"随机游走次数:"</span>,walk_num<span class="hljs-number">-1</span>)</span><br><span class="line">print(<span class="hljs-string">"最终最优点:"</span>,x)</span><br><span class="line">print(<span class="hljs-string">"最终最优值:"</span>,function(x))</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">迭代次数: 100</span><br><span class="line">初始步长: 0.5</span><br><span class="line">epsilon: 1e-05</span><br><span class="line">变量数目: 2</span><br><span class="line">初始点坐标: [49, 49]</span><br><span class="line">第1次随机游走完成。</span><br><span class="line">第2次随机游走完成。</span><br><span class="line">第3次随机游走完成。</span><br><span class="line">......</span><br><span class="line">第16次随机游走完成。</span><br><span class="line">随机游走次数: 16</span><br><span class="line">最终最优点: [49.99999305065255, 50.00000102537616]</span><br><span class="line">最终最优值: -1.15111524497</span><br></pre></td></tr></table></figure><p>基本的随机游走算法对于初始点比较敏感，可以看出，当初始点位于最优点附件时，可以很好地达到全局最优点；如果将初始点设置得离最优点较远，比如设置初始点为(10,10)时，其他参数不变，得到结果为：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随机游走次数: 16</span><br><span class="line">最终最优点: [10.042835581532445, 11.648866165553416]</span><br><span class="line">最终最优值: -1.01720848747</span><br></pre></td></tr></table></figure><p>可以发现，随机游走陷入了局部最优点。当然，如果增大迭代次数N以及初始步长λ，可以在一定程度上增加寻优能力，比如设置N=3000,λ=10.0，得到结果如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">迭代次数: 3000</span><br><span class="line">初始步长: 10.0</span><br><span class="line">epsilon: 1e-05</span><br><span class="line">变量数目: 2</span><br><span class="line">初始点坐标: [10, 10]</span><br><span class="line">第1次随机游走完成。</span><br><span class="line">第2次随机游走完成。</span><br><span class="line">第3次随机游走完成。</span><br><span class="line">......</span><br><span class="line">第20次随机游走完成。</span><br><span class="line">随机游走次数: 20</span><br><span class="line">最终最优点: [49.99999900055026, 50.0000023931389]</span><br><span class="line">最终最优值: -1.15111697755</span><br></pre></td></tr></table></figure><p>可以看出，当增大迭代次数以及初始步长之后，函数最终达到了全局最优点。但是迭代次数增加的代价则是运行时间的增加。总得来说，基本的随机游走算法可以很好地达到全局最优点，但是有时会依赖于初始点的选择。</p><h1 id="4-改进的随机游走算法"><a href="#4-改进的随机游走算法" class="headerlink" title="4.改进的随机游走算法"></a>4.改进的随机游走算法</h1><p><a href="https://sm.ms/image/UfayLWAcEz7pDNn" target="_blank"><img src="https://i.loli.net/2019/10/07/UfayLWAcEz7pDNn.png"></a></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">@Description:改进的随机游走算法</span></span><br><span class="line"><span class="hljs-string">这里求解:f = sin(r)/r + 1,r = sqrt((x-50)^2+(y-50)^2)+e,0&lt;=x,y&lt;=100 的最大值</span></span><br><span class="line"><span class="hljs-string">求解f的最大值，可以转化为求-f的最小值问题</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-keyword">from</span> __future__  <span class="hljs-keyword">import</span> print_function</span><br><span class="line"><span class="hljs-keyword">import</span> math</span><br><span class="line"><span class="hljs-keyword">import</span> random</span><br><span class="line">N = <span class="hljs-number">100</span> <span class="hljs-comment"># 迭代次数</span></span><br><span class="line">step = <span class="hljs-number">10.0</span> <span class="hljs-comment"># 初始步长</span></span><br><span class="line">epsilon = <span class="hljs-number">0.00001</span></span><br><span class="line">variables = <span class="hljs-number">2</span> <span class="hljs-comment"># 变量数目</span></span><br><span class="line">x = [<span class="hljs-number">-100</span>,<span class="hljs-number">-10</span>] <span class="hljs-comment"># 初始点坐标</span></span><br><span class="line">walk_num = <span class="hljs-number">1</span> <span class="hljs-comment"># 初始化随机游走次数</span></span><br><span class="line">n = <span class="hljs-number">10</span> <span class="hljs-comment"># 每次随机生成向量u的数目</span></span><br><span class="line">print(<span class="hljs-string">"迭代次数:"</span>,N)</span><br><span class="line">print(<span class="hljs-string">"初始步长:"</span>,step)</span><br><span class="line">print(<span class="hljs-string">"每次产生随机向量数目:"</span>,n)</span><br><span class="line">print(<span class="hljs-string">"epsilon:"</span>,epsilon)</span><br><span class="line">print(<span class="hljs-string">"变量数目:"</span>,variables)</span><br><span class="line">print(<span class="hljs-string">"初始点坐标:"</span>,x)</span><br><span class="line"><span class="hljs-comment"># 定义目标函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    r = math.sqrt((x[<span class="hljs-number">0</span>]<span class="hljs-number">-50</span>)**<span class="hljs-number">2</span> + (x[<span class="hljs-number">1</span>]<span class="hljs-number">-50</span>)**<span class="hljs-number">2</span>) + math.e</span><br><span class="line">    f = math.sin(r)/r + <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> -f</span><br><span class="line"><span class="hljs-comment"># 开始随机游走</span></span><br><span class="line"><span class="hljs-keyword">while</span>(step &gt; epsilon):</span><br><span class="line">    k = <span class="hljs-number">1</span> <span class="hljs-comment"># 初始化计数器</span></span><br><span class="line">    <span class="hljs-keyword">while</span>(k &lt; N):</span><br><span class="line">        <span class="hljs-comment"># 产生n个向量u</span></span><br><span class="line">        x1_list = [] <span class="hljs-comment"># 存放x1的列表</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):</span><br><span class="line">            u = [random.uniform(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i1 <span class="hljs-keyword">in</span> range(variables)] <span class="hljs-comment"># 随机向量</span></span><br><span class="line">            <span class="hljs-comment"># u1 为标准化之后的随机向量</span></span><br><span class="line">            u1 = [u[i3]/math.sqrt(sum([u[i2]**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i2 <span class="hljs-keyword">in</span> range(variables)])) <span class="hljs-keyword">for</span> i3 <span class="hljs-keyword">in</span> range(variables)]</span><br><span class="line">            x1 = [x[i4] + step*u1[i4] <span class="hljs-keyword">for</span> i4 <span class="hljs-keyword">in</span> range(variables)]</span><br><span class="line">            x1_list.append(x1)</span><br><span class="line">        f1_list = [function(x1) <span class="hljs-keyword">for</span> x1 <span class="hljs-keyword">in</span> x1_list]</span><br><span class="line">        f1_min = min(f1_list)</span><br><span class="line">        f1_index = f1_list.index(f1_min)</span><br><span class="line">        x11 = x1_list[f1_index] <span class="hljs-comment"># 最小f1对应的x1</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(f1_min &lt; function(x)): <span class="hljs-comment"># 如果找到了更优点</span></span><br><span class="line">            k = <span class="hljs-number">1</span></span><br><span class="line">            x = x11</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            k += <span class="hljs-number">1</span></span><br><span class="line">    step = step/<span class="hljs-number">2</span></span><br><span class="line">    print(<span class="hljs-string">"第%d次随机游走完成。"</span> % walk_num)</span><br><span class="line">    walk_num += <span class="hljs-number">1</span></span><br><span class="line">print(<span class="hljs-string">"随机游走次数:"</span>,walk_num<span class="hljs-number">-1</span>)</span><br><span class="line">print(<span class="hljs-string">"最终最优点:"</span>,x)</span><br><span class="line">print(<span class="hljs-string">"最终最优值:"</span>,function(x))</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">迭代次数: 100</span><br><span class="line">初始步长: 10.0</span><br><span class="line">每次产生随机向量数目: 10</span><br><span class="line">epsilon: 1e-05</span><br><span class="line">变量数目: 2</span><br><span class="line">初始点坐标: [-100, -10]</span><br><span class="line">第1次随机游走完成。</span><br><span class="line">第2次随机游走完成。</span><br><span class="line">第3次随机游走完成。</span><br><span class="line">.....</span><br><span class="line">第20次随机游走完成。</span><br><span class="line">随机游走次数: 20</span><br><span class="line">最终最优点: [49.999997561093195, 49.99999839875969]</span><br><span class="line">最终最优值: -1.15111685082</span><br></pre></td></tr></table></figure><p>可以发现，即使迭代次数N=100不大，初始点(−100,−10)离最优点(50,50)非常远，改进的随机游走算法依然可以达到最优点。这说明了改进的随机游走算法具有更强大的寻优能力以及对于初始点更低的依赖性。</p><p>注：<strong>经过多次试验发现，无论是随机游走算法还是改进的随机游走算法，对于步长都是非常依赖的。步长λ越大，意味着初始可以寻找最优解的空间越大，但同时也意味着更多的迭代次数(要搜索空间变大，寻找次数变多，相应时间自然要增加)。如果步长取得过小，即使N很大，也很难达到最优解。无论对于随机游走算法还是改进的随机游走算法皆是如此。所以理论上步长λ越大越好。但是步长越大，迭代总次数越高，算法运行时间越长。所以实践中可以多试验几次，将λ取得适当地大即可</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-关于全局最优化求解&quot;&gt;&lt;a href=&quot;#1-关于全局最优化求解&quot; class=&quot;headerlink&quot; title=&quot;1.关于全局最优化求解&quot;&gt;&lt;/a&gt;1.关于全局最优化求解&lt;/h1&gt;&lt;p&gt;全局最优化是一个非常复杂的问题，目前还没有一个通用的办法可以对任意复杂函数求解全局最优值。一个求解局部极小值的方法——&lt;strong&gt;梯度下降法&lt;/strong&gt;。这种方法对于求解精度不高的情况是实用的，可以用局部极小值近似替代全局最小值点。但是当要求精确求解全局最小值时，梯度下降法就不适用了，需要采用其他的办法求解。常见的求解全局最优的办法有拉格朗日法、线性规划法、以及一些人工智能算法比如遗传算法、粒子群算法、模拟退火算法等。而今天要说的是一个操作简单但是不易陷入局部极小值的方法：随机游走算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://uppez.github.io/categories/AI/"/>
    
    
      <category term="深度学习" scheme="https://uppez.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="https://uppez.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据集网站</title>
    <link href="https://uppez.github.io/2019/10/07/%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BD%91%E7%AB%99/"/>
    <id>https://uppez.github.io/2019/10/07/数据集网站/</id>
    <published>2019-10-07T03:45:33.000Z</published>
    <updated>2019-10-07T03:50:02.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-如何使用这些资源"><a href="#一-如何使用这些资源" class="headerlink" title="一.如何使用这些资源?"></a>一.如何使用这些资源?</h1><p>如何使用这些数据源是没有限制的，应用和使用只受到您的创造力和实际应用。使用它们最简单的方法是进行数据项目并在网站上发布它们。这不仅能提高你的数据和可视化技能，还能改善你的结构化思维。另一方面，如果你正在考虑/处理基于数据的产品，这些数据集可以通过提供额外的/新的输入数据来增加您的产品的功能。所以，继续在这些项目上工作吧，与更大的世界分享它们，以展示你的数据能力!我们已经在不同的部分中划分了这些数据源，以帮助你根据应用程序对数据源进行分类。我们从简单、通用和易于处理数据集开始，然后转向大型/行业相关数据集。然后，我们为特定的目的——文本挖掘、图像分类、推荐引擎等提供数据集的链接。这将为您提供一个完整的数据资源列表。如果你能想到这些数据集的任何应用，或者知道我们漏掉了什么流行的资源，请在下面的评论中与我们分享。（部分可能需要翻墙）</p><a id="more"></a><h1 id="二-由简单和通用的数据集开始"><a href="#二-由简单和通用的数据集开始" class="headerlink" title="二.由简单和通用的数据集开始"></a>二.由简单和通用的数据集开始</h1><p>1.data.gov ( <a href="https://www.data.gov/" target="_blank" rel="noopener">https://www.data.gov/</a> ) </p><p>这是美国政府公开数据的所在地，该站点包含了超过19万的数据点。这些数据集不同于气候、教育、能源、金融和更多领域的数据。 </p><p>2.data.gov.in ( <a href="https://data.gov.in/" target="_blank" rel="noopener">https://data.gov.in/</a> ) </p><p>这是印度政府公开数据的所在地，通过各种行业、气候、医疗保健等来寻找数据，你可以在这里找到一些灵感。根据你居住的国家的不同，你也可以从其他一些网站上浏览类似的网站。</p><p>3.World Bank( <a href="http://data.worldbank.org/" target="_blank" rel="noopener">http://data.worldbank.org/</a> ) </p><p>世界银行的开放数据。该平台提供 Open Data Catalog，世界发展指数，教育指数等几个工具。</p><p>4.RBI ( <a href="https://rbi.org.in/Scripts/Statistics.aspx" target="_blank" rel="noopener">https://rbi.org.in/Scripts/Statistics.aspx</a> ) </p><p>印度储备银行提供的数据。这包括了货币市场操作、收支平衡、银行使用和一些产品的几个指标。</p><p>5.Five Thirty Eight Datasets ( <a href="https://github.com/fivethirtyeight/data" target="_blank" rel="noopener">https://github.com/fivethirtyeight/data</a> ) </p><p>Five Thirty Eight，亦称作 538，专注与民意调查分析，政治，经济与体育的博客。该数据集为 Five Thirty Eight Datasets 使用的数据集。每个数据集包括数据，解释数据的字典和Five Thirty Eight 文章的链接。如果你想学习如何创建数据故事，没有比这个更好。</p><h1 id="三-大型数据集"><a href="#三-大型数据集" class="headerlink" title="三.大型数据集"></a>三.大型数据集</h1><p>1.Amazon Web Services（AWS）datasets<br>( <a href="https://aws.amazon.com/cn/datasets/" target="_blank" rel="noopener">https://aws.amazon.com/cn/datasets/</a> ) </p><p>Amazon提供了一些大数据集，可以在他们的平台上使用，也可以在本地计算机上使用。您还可以通过EMR使用EC2和Hadoop来分析云中的数据。在亚马逊上流行的数据集包括完整的安然电子邮件数据集，Google Books n-gram，NASA NEX 数据集，百万歌曲数据集等。 </p><p>2.Google datasets<br>( <a href="https://cloud.google.com/bigquery/public-data/" target="_blank" rel="noopener">https://cloud.google.com/bigquery/public-data/</a> ) </p><p>Google 提供了一些数据集作为其 Big Query 工具的一部分。包括 GitHub 公共资料库的数据，Hacker News 的所有故事和评论。</p><p>3.Youtube labeled Video Dataset<br>( <a href="https://research.google.com/youtube8m/" target="_blank" rel="noopener">https://research.google.com/youtube8m/</a> ) </p><p>几个月前，谷歌研究小组发布了YouTube上的“数据集”，它由800万个YouTube视频id和4800个视觉实体的相关标签组成。它来自数十亿帧的预先计算的，最先进的视觉特征。 </p><h1 id="四-预测建模与机器学习数据集"><a href="#四-预测建模与机器学习数据集" class="headerlink" title="四.预测建模与机器学习数据集"></a>四.预测建模与机器学习数据集</h1><p>1.UCI Machine Learning Repository<br>( <a href="https://archive.ics.uci.edu/ml/datasets.html" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets.html</a> )  </p><p>UCI机器学习库显然是最著名的数据存储库。如果您正在寻找与机器学习存储库相关的数据集，通常是首选的地方。这些数据集包括了各种各样的数据集，从像Iris和泰坦尼克这样的流行数据集到最近的贡献，比如空气质量和GPS轨迹。存储库包含超过350个与域名类似的数据集(分类/回归)。您可以使用这些过滤器来确定您需要的数据集。 </p><p>2.Kaggle<br>( <a href="https://www.kaggle.com/datasets" target="_blank" rel="noopener">https://www.kaggle.com/datasets</a> )  </p><p>Kaggle提出了一个平台，人们可以贡献数据集，其他社区成员可以投票并运行内核/脚本。他们总共有超过350个数据集——有超过200个特征数据集。虽然一些最初的数据集通常出现在其他地方，但我在平台上看到了一些有趣的数据集，而不是在其他地方出现。与新的数据集一起，界面的另一个好处是，您可以在相同的界面上看到来自社区成员的脚本和问题。 </p><p>3.Analytics Vidhya<br>(<a href="https://datahack.analyticsvidhya.com/contest/all/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/all/</a> ) </p><p>您可以从我们的实践问题和黑客马拉松问题中参与和下载数据集。问题数据集基于真实的行业问题，并且相对较小，因为它们意味着2 - 7天的黑客马拉松。 </p><p>4.Quandl<br>( <a href="https://www.quandl.com/" target="_blank" rel="noopener">https://www.quandl.com/</a> ) </p><p>Quandl 通过起网站、API 或一些工具的直接集成提供了不同来源的财务、经济和替代数据。他们的数据集分为开放和付费。所有开放数据集为免费，但高级数据集需要付费。通过搜索仍然可以在平台上找到优质数据集。例如，来自印度的证券交易所数据是免费的。 </p><p>5.Past KDD Cups<br>( <a href="http://www.kdd.org/kdd-cup" target="_blank" rel="noopener">http://www.kdd.org/kdd-cup</a> ) </p><p>KDD Cup 是 ACM Special Interest Group 组织的年度数据挖掘和知识发现竞赛。</p><p>6.Driven Data<br>( <a href="https://www.drivendata.org/" target="_blank" rel="noopener">https://www.drivendata.org/</a> ) </p><p>Driven Data 发现运用数据科学带来积极社会影响的现实问题。然后，他们为数据科学家组织在线模拟竞赛，从而开发出最好的模型来解决这些问题。</p><h1 id="五-图像分类数据集"><a href="#五-图像分类数据集" class="headerlink" title="五.图像分类数据集"></a>五.图像分类数据集</h1><p>1.The MNIST Database<br>( <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a> ) </p><p>最流行的图像识别数据集，使用手写数字。它包括6万个示例和1万个示例的测试集。这通常是第一个进行图像识别的数据集。</p><p>2.Chars74K<br>(<a href="http://www.ee.surrey.ac.uk/CVSSP/demos/chars74k/" target="_blank" rel="noopener">http://www.ee.surrey.ac.uk/CVSSP/demos/chars74k/</a> ) </p><p>这里是下一阶段的进化，如果你已经通过了手写的数字。该数据集包括自然图像中的字符识别。数据集包含74,000个图像，因此数据集的名称。</p><p>3.Frontal Face Images<br>(<a href="http://vasc.ri.cmu.edu//idb/html/face/frontal_images/index.html" target="_blank" rel="noopener">http://vasc.ri.cmu.edu//idb/html/face/frontal_images/index.html</a> ) </p><p>如果你已经完成了前两个项目，并且能够识别数字和字符，这是图像识别中的下一个挑战级别——正面人脸图像。这些图像是由CMU &amp; MIT收集的，排列在四个文件夹中。</p><p>4.ImageNet<br>( <a href="http://image-net.org/" target="_blank" rel="noopener">http://image-net.org/</a> ) </p><p>现在是时候构建一些通用的东西了。根据WordNet层次结构组织的图像数据库(目前仅为名词)。层次结构的每个节点都由数百个图像描述。目前，该集合平均每个节点有超过500个图像(而且还在增加)。</p><h1 id="六-文本分类数据集"><a href="#六-文本分类数据集" class="headerlink" title="六.文本分类数据集"></a>六.文本分类数据集</h1><p>1.Spam – Non Spam<br>(<a href="http://www.esp.uem.es/jmgomez/smsspamcorpus/" target="_blank" rel="noopener">http://www.esp.uem.es/jmgomez/smsspamcorpus/</a>) </p><p>区分短信是否为垃圾邮件是一个有趣的问题。你需要构建一个分类器将短信进行分类。</p><p>2.Twitter Sentiment Analysis<br>(<a href="http://thinknook.com/twitter-sentiment-analysis-training-corpus-dataset-2012-09-22/" target="_blank" rel="noopener">http://thinknook.com/twitter-sentiment-analysis-training-corpus-dataset-2012-09-22/</a>) </p><p>该数据集包含 1578627 个分类推文，每行被标记为1的积极情绪，0位负面情绪。数据依次基于 Kaggle 比赛和 Nick Sanders 的分析。</p><p>3.Movie Review Data<br>(<a href="http://www.cs.cornell.edu/People/pabo/movie-review-data/" target="_blank" rel="noopener">http://www.cs.cornell.edu/People/pabo/movie-review-data/</a>) </p><p>这个网站提供了一系列的电影评论文件，这些文件标注了他们的总体情绪极性(正面或负面)或主观评价(例如，“两个半明星”)和对其主观性地位(主观或客观)或极性的标签。</p><h1 id="七-推荐引擎数据集"><a href="#七-推荐引擎数据集" class="headerlink" title="七.推荐引擎数据集"></a>七.推荐引擎数据集</h1><p>1.MovieLens<br>( <a href="https://grouplens.org/" target="_blank" rel="noopener">https://grouplens.org/</a> ) </p><p>MovieLens 是一个帮助人们查找电影的网站。它有成千上万的注册用户。他们进行自动内容推荐，推荐界面，基于标签的推荐页面等在线实验。这些数据集可供下载，可用于创建自己的推荐系统。</p><p>2.Jester<br>(<a href="http://www.ieor.berkeley.edu/~goldberg/jester-data/" target="_blank" rel="noopener">http://www.ieor.berkeley.edu/~goldberg/jester-data/</a>) </p><p>在线笑话推荐系统。</p><h1 id="八-各种来源的数据集网站"><a href="#八-各种来源的数据集网站" class="headerlink" title="八.各种来源的数据集网站"></a>八.各种来源的数据集网站</h1><p>1.KDNuggets<br>(<a href="http://www.kdnuggets.com/datasets/index.html" target="_blank" rel="noopener">http://www.kdnuggets.com/datasets/index.html</a>) </p><p>KDNuggets 的数据集页面一直是人们搜索数据集的参考。列表全面，但是某些来源不再提供数据集。因此，需要谨慎选择数据集和来源。</p><p>2.Awesome Public Datasets<br>(<a href="https://github.com/caesar0301/awesome-public-datasets" target="_blank" rel="noopener">https://github.com/caesar0301/awesome-public-datasets</a>) </p><p>一个GitHub存储库，它包含一个由域分类的完整的数据集列表。数据集被整齐地分类在不同的领域，这是非常有用的。但是，对于存储库本身的数据集没有描述，这可能使它非常有用。</p><p>3.Reddit Datasets Subreddit<br>(<a href="https://www.reddit.com/r/datasets/" target="_blank" rel="noopener">https://www.reddit.com/r/datasets/</a>) </p><p>由于这是一个社区驱动的论坛，它可能会遇到一些麻烦(与之前的两个来源相比)。但是，您可以通过流行/投票来对数据集进行排序，以查看最流行的数据集。另外，它还有一些有趣的数据集和讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-如何使用这些资源&quot;&gt;&lt;a href=&quot;#一-如何使用这些资源&quot; class=&quot;headerlink&quot; title=&quot;一.如何使用这些资源?&quot;&gt;&lt;/a&gt;一.如何使用这些资源?&lt;/h1&gt;&lt;p&gt;如何使用这些数据源是没有限制的，应用和使用只受到您的创造力和实际应用。使用它们最简单的方法是进行数据项目并在网站上发布它们。这不仅能提高你的数据和可视化技能，还能改善你的结构化思维。另一方面，如果你正在考虑/处理基于数据的产品，这些数据集可以通过提供额外的/新的输入数据来增加您的产品的功能。所以，继续在这些项目上工作吧，与更大的世界分享它们，以展示你的数据能力!我们已经在不同的部分中划分了这些数据源，以帮助你根据应用程序对数据源进行分类。我们从简单、通用和易于处理数据集开始，然后转向大型/行业相关数据集。然后，我们为特定的目的——文本挖掘、图像分类、推荐引擎等提供数据集的链接。这将为您提供一个完整的数据资源列表。如果你能想到这些数据集的任何应用，或者知道我们漏掉了什么流行的资源，请在下面的评论中与我们分享。（部分可能需要翻墙）&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="数据集" scheme="https://uppez.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>一个tensorflow的可视化示例代码</title>
    <link href="https://uppez.github.io/2019/10/07/%E4%B8%80%E4%B8%AAtensorflow%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    <id>https://uppez.github.io/2019/10/07/一个tensorflow的可视化示例代码/</id>
    <published>2019-10-07T03:37:20.000Z</published>
    <updated>2019-10-07T03:42:00.271Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow主要优势是灵活和可视化。TensorBoard是TensorFlow的一组可视化工具。熟悉的使用TensorBoard可以大大提高训练的效率。今天本文将介绍一下TensorBoard。</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf</span><br><span class="line"><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#载入数据</span></span><br><span class="line">mnist=input_data.read_data_sets(<span class="hljs-string">'mnist_data'</span>,one_hot=<span class="hljs-literal">True</span>)<span class="hljs-comment">#noe_hot把像素点都转变成0或1的形式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#每个批次的大小，训练模型时，一次放入一批次</span></span><br><span class="line">batch_size=<span class="hljs-number">100</span> <span class="hljs-comment">#一批次100张图</span></span><br><span class="line"><span class="hljs-comment">#计算一共有多少个批次</span></span><br><span class="line">n_batch=mnist.train.num_examples//batch_size<span class="hljs-comment"># //是整除,得到批次数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#参数概要</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variable_summaries</span><span class="hljs-params">(var)</span>:</span><span class="hljs-comment">#定义一个函数，作用是计算各种参数值</span></span><br><span class="line">    <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'summaries'</span>):</span><br><span class="line">        mean=tf.reduce_mean(var)<span class="hljs-comment">#计算平均值</span></span><br><span class="line">        tf.summary.scalar(<span class="hljs-string">'mean'</span>,mean)<span class="hljs-comment">#记录平均值，将其命名为mean。summary.scalar用来显示标量信息</span></span><br><span class="line">        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'stddev'</span>):</span><br><span class="line">            stddev=tf.sqrt(tf.reduce_mean(tf.square(var-mean)))</span><br><span class="line">        tf.summary.scalar(<span class="hljs-string">'stddev'</span>,stddev)<span class="hljs-comment"># 标准差</span></span><br><span class="line">        tf.summary.scalar(<span class="hljs-string">'max'</span>,tf.reduce_max(var))<span class="hljs-comment">#最大值</span></span><br><span class="line">        tf.summary.scalar(<span class="hljs-string">'min'</span>,tf.reduce_min(var))<span class="hljs-comment">#最小值</span></span><br><span class="line">        tf.summary.histogram(<span class="hljs-string">'histogram'</span>,var)<span class="hljs-comment">#直方图</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#命名空间</span></span><br><span class="line"><span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'input'</span>):  <span class="hljs-comment">#命名随意，比如input,下面的x和y要缩进，表示x，y放在input空间</span></span><br><span class="line"><span class="hljs-comment">#定义两个placeholder，配合上面命名空间，给x，y取个名字</span></span><br><span class="line">   x=tf.placeholder(tf.float32,[<span class="hljs-literal">None</span>,<span class="hljs-number">784</span>],name=<span class="hljs-string">'x-input'</span>)<span class="hljs-comment">#建立一个占位符，None是图片数，784是每幅图的像素个数</span></span><br><span class="line">   y=tf.placeholder(tf.float32,[<span class="hljs-literal">None</span>,<span class="hljs-number">10</span>],name=<span class="hljs-string">'y-input'</span>)<span class="hljs-comment"># 标签，建立一个占位符，10是指0-9十个数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'layer'</span>):</span><br><span class="line"><span class="hljs-comment">#创建一个简单的神经网络，输入层784个神经元，输出层10个神经元，不设隐藏层</span></span><br><span class="line">   <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'wights'</span>):</span><br><span class="line">      W=tf.Variable(tf.zeros([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>]),name=<span class="hljs-string">'W'</span>)<span class="hljs-comment">#权值，设一个变量，置0</span></span><br><span class="line">      variable_summaries(W)<span class="hljs-comment">#把权值W当作参数，计算的各种指标</span></span><br><span class="line">   <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'biases'</span>):</span><br><span class="line">      b=tf.Variable(tf.zeros([<span class="hljs-number">10</span>]),name=<span class="hljs-string">'b'</span>)<span class="hljs-comment">#偏置值</span></span><br><span class="line">      variable_summaries(b)<span class="hljs-comment">#把偏置值b当作参数，计算的各种指标</span></span><br><span class="line">   <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'wx_plus_b'</span>):</span><br><span class="line">      wx_plus_b=tf.matmul(x,W)+b</span><br><span class="line">   <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'softmax'</span>):</span><br><span class="line">      prediction=tf.nn.softmax(tf.matmul(x,W)+b)<span class="hljs-comment">#信号总和，经过softmax函数（激活函数）转化成概率值</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#二次代价函数</span></span><br><span class="line"><span class="hljs-comment">#loss =tf.reduce_mean(tf.square(y-prediction))</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#使用交叉熵代价函数</span></span><br><span class="line"><span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'loss'</span>):</span><br><span class="line">    loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y,logits=prediction))</span><br><span class="line">    tf.summary.scalar(<span class="hljs-string">'loss'</span>,loss)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#使用梯度下降法</span></span><br><span class="line"><span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'train'</span>):</span><br><span class="line">    train_step=tf.train.GradientDescentOptimizer(<span class="hljs-number">0.2</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#初始化变量</span></span><br><span class="line">init=tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'accuracy'</span>):</span><br><span class="line">    <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'correct_prediction'</span>):</span><br><span class="line"><span class="hljs-comment">#训练好后求准确率，结果存放在一个布尔型列表中，argmax返回一维张量中最大的值所在的位置</span></span><br><span class="line">        correct_prediction=tf.equal(tf.argmax(y,<span class="hljs-number">1</span>),tf.argmax(prediction,<span class="hljs-number">1</span>))<span class="hljs-comment">#argmax函数是对行或列计算最大值，1表示按行，0表示按列，找到最大概率标签的位置。 equal函数是比较两个参数大小，相等的话返回True，不相等返回False</span></span><br><span class="line">    <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">'accuracy'</span>):</span><br><span class="line"><span class="hljs-comment">#求准确率</span></span><br><span class="line">        accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))<span class="hljs-comment">#cast()是类型转换函数，把布尔型参数转换为32位古典型,然后求平均值。true变成1.0，flse变成0</span></span><br><span class="line"><span class="hljs-comment">#Boolean→数值型：True转换为-1，False转换为0。数值型→Boolean：0转换为False，其他转换为True</span></span><br><span class="line">        tf.summary.scalar(<span class="hljs-string">'accuracy'</span>,accuracy)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#合并所有的summary,并将其加入到sess.run的语句里</span></span><br><span class="line">merged=tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:</span><br><span class="line">    sess.run(init)<span class="hljs-comment">#初始化变量</span></span><br><span class="line">    writer=tf.summary.FileWriter(<span class="hljs-string">'./graphs'</span>,sess.graph)<span class="hljs-comment">#'logs/'是路径，graph存在logs文件夹中，如果没有logs文件夹，这里会自动生成</span></span><br><span class="line">    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">51</span>):<span class="hljs-comment">#迭代21个周期，把所有图片训练21次</span></span><br><span class="line">        <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> range(n_batch):</span><br><span class="line">            batch_xs,batch_ys=mnist.train.next_batch(batch_size)<span class="hljs-comment">#一次分配100张图片，图片数据保存在batch_xs，标签保存在batch_ys</span></span><br><span class="line">            summary,_=sess.run([merged,train_step],feed_dict=&#123;x:batch_xs,y:batch_ys&#125;)<span class="hljs-comment">#每tain训练一次，统计一次参数merged，运行后得到的merged存在summary里</span></span><br><span class="line"></span><br><span class="line">        writer.add_summary(summary,epoch)<span class="hljs-comment">#将summary和运行周期epoch写入tensorboard文件</span></span><br><span class="line">        acc=sess.run(accuracy,feed_dict=&#123;x:mnist.test.images,y:mnist.test.labels&#125;)<span class="hljs-comment">#x输入测试图片，从而得到prediciton的y，从而和label y 对比</span></span><br><span class="line">        print(<span class="hljs-string">'Iter'</span>+str(epoch)+<span class="hljs-string">',Testing Accuracy'</span>+str(acc))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow主要优势是灵活和可视化。TensorBoard是TensorFlow的一组可视化工具。熟悉的使用TensorBoard可以大大提高训练的效率。今天本文将介绍一下TensorBoard。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://uppez.github.io/categories/AI/"/>
    
    
      <category term="深度学习" scheme="https://uppez.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>告研究生新生/研究生导师书</title>
    <link href="https://uppez.github.io/2019/10/06/%E5%91%8A%E7%A0%94%E7%A9%B6%E7%94%9F%E6%96%B0%E7%94%9F-%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AF%BC%E5%B8%88%E4%B9%A6/"/>
    <id>https://uppez.github.io/2019/10/06/告研究生新生-研究生导师书/</id>
    <published>2019-10-06T02:46:01.000Z</published>
    <updated>2019-10-06T02:53:58.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="告研究生新生书"><a href="#告研究生新生书" class="headerlink" title="告研究生新生书"></a>告研究生新生书</h1><p>作者：北京邮电大学杨义先教授</p><p>各位新同学，大家好！</p><a id="more"></a><p>首先祝贺各位在刚刚结束的考研竞争中过关斩将，收获了人生的又一次成功！今天借此喜庆之日，顺便说几句心里话，也算是送给各位的见面礼吧。</p><p>（1）<strong>什么是研究生？</strong>研究生就是做研究的学生，因此，大家不要再把本科阶段的“视分如命”传统带进来。从今以后，请大家记住：“考试，60分万岁；研究，90分及格！”若有某研究生给导师报喜说：“老师我已经超额多上X门课程，并考试得满分”，那么，导师也许会把他当作可爱的小傻瓜，你不会来夺此头衔吧？<br>当然，研究生培养方案中包括课程、学分、考试和论文等所有要求都必须首先满足！特别提醒各位，研究生的论文是“干”出来的，而不是埋头“写”出来的，更不是“抄”来的！抄袭论文很危险，害人害已，后果不堪设想</p><p>（2）<strong>导师将教给你什么？</strong>导师不再教你更多的知识，因为，在知识爆炸的时代，即使是天才，他所能掌握的知识也几乎可以忽略不计。从小到大，你被灌输的知识已经够多了，现在是该你学会“如何自己学习知识”的时候了！导师将重点培养你的三种能力：创新能力、动手能力、社会适应能力。<br>当然，还有一点，导师也许将把自己多年失败的教训毫不隐瞒地展示给你，以使你不再重蹈覆辙。成功者的经验很难被复制，但是，他的失败却足以借鉴。</p><p>（3）<strong>如何给自己定位？</strong>定位不清，害死人！虽然每个人都有“顶天”和“立地”两种选择；但能“顶天”之人，毕竟是少数；绝大部分人将“立地”！若你没特别的理论研究天赋，不能成为“顶天”的科学家，那就建议你老老实实瞄准“立地”的工程师。科学家和工程师都同等重要，不必再分高低贵贱。<br>社会并不急需“既能做一些不痛不痒的项目，又能发表几篇不三不四的论文”的所谓通才，强劲的社会竞争力是检验学生培养是否成功的唯一标准。</p><p>（4）<strong>什么兴趣值得付出代价？</strong>并非所有兴趣都该纵容，许多研究生误解了“兴趣是成功之母”，并常常拿“兴趣”来作为挑肥拣瘦的借口。如果有足够的胆量，那么，独门兴趣（如，扎克伯格的Facebook等）才值得死盯，因为，这样的兴趣要么送你上天堂，要么拉你下地狱。人生有此机会一搏，也不全是坏事！<br>但是，大众化兴趣（比如，我更擅长单片机、我的本科专业更适合…、我学过XX课程等）就应该服从真实需求，必要时劝君忍痛割爱，否则成功将与你无缘，毕竟今后是你要去适应社会，而不是社会来适应你！其实，咬住大众化兴趣不放者要么是想偷懒，要么是没自信。当然，所有生活兴趣都是值得享受的，工作兴趣与生活兴趣不要混为一谈。</p><p>（5）<strong>态度到底有多重要？</strong>态度决定一切！只要态度出了问题，再加上研究生都有极高的智商，那么，稍稍发力，就能让任何导师“理屈词穷”，比如，可以轻易严格证明“研究生做项目是在给导师打工”、“导师在论文中的署名不合理”、“我的论文创新性已经足够毕业”等等。<br>面对如此辩才，导师只能尽力而为，实在无奈，也只好弃权。多年的事实证明，能力弱和态度差常常相伴而生，也许正是因为态度差，才导致能力弱吧。“小事愿干，中事能干，大事敢干”是研究生的基本要求。</p><p>（6）<strong>“尽力而为”与“竭尽全力”的区别到底有多大？</strong>“尽力而为”者用99.99%（＝A）的力气去做事，“竭尽全力”者用100.01%（=B）的力气去做事。表面上看A@B，但是，当若干个A相乘时，将有A´ A´ A´…=0, 而若干个B 相乘时B´ B´ B´…=¥。各位新同学明白了吗？如果你一生都“尽力而为”的话，那么，你将收获零；如果你一生都“竭尽全力”的话，那么，你将收获巨大成功！</p><p>（7）<strong>做啥课题真的很重要吗？</strong>从学习知识的角度来说，做啥课题确实有区别；但是，从培养能力角度来看，其实啥课题的效果都一样。别忘了，如今已是“重能力，而轻知识”的年代！过度区分是所有矛盾的根源，过度关注细节差异者永远也得不到满足。另外，如果在某段时间内，被安排从事一个自己不了解或不擅长的课题，那你为何不把它当成一种挑战，以此来锻炼和培养自己的“适应”和“学习”的能力呢？</p><p>（8）<strong>高分学生为什么容易成低能？</strong>过去多年的事实反复证明：保研学生和考研高分的学生，更容易在研究生阶段成为低能学生。这个看似矛盾的现象，其实有其必然。</p><ul><li><p>原因1，个别高分学生总是习惯以讲课和考试的思维去考虑问题，从小到大，他/她的成就感也主要来自于各类考试，因此，没有考试，不能得分的事情（比如，科研）他们都下意识地抵制或恐惧。</p></li><li><p>原因2，读研前，几乎都是别人来向他/她请教有关学习和考试的问题，这就无形中使他/她感觉过于良好，因此，一旦有不懂的科研事项，就很难放下架子去向别人（特别是那些考试成绩较差的人）请教，当然，久而久之就会落后甚至被无情地淘汰。</p></li><li><p>原因3，过于精通本科阶段的循序渐进方法，更难适应研究问题时的跳跃创新，以为科研也要把所有准备工作都做好后，才能开始。</p></li><li><p>原因4，过于企望本科考试优势能够顺利过渡到研究生的科研阶段，因此，思想包袱更重，更不敢面对新挑战。</p></li></ul><p>同学们，今天的见面礼可不能白送哟！希望毕业时，大家能够以自身的杰出成就来回母校，更希望大家今后走向社会为国争光，期待着那一天的到来！</p><p>谢谢！</p><h1 id="告研究生导师书"><a href="#告研究生导师书" class="headerlink" title="告研究生导师书"></a>告研究生导师书</h1><p>作者：（一点建议罢了，不来自特定作者</p><p>第1条）教师出路千万条，安全执教第一条；自保不周全，亲人两行泪！啥意思？嘿嘿，你懂的！各位上有老，下有小，中间还有一个宝（配偶）；就算你不怕死、不要命，也该为他人考虑嘛！</p><p>第2条）学生是亲人，弟子是亲人，爹妈儿女也是亲人，白头偕老的爱人更是亲人；别拿一类亲人去伤害另一类亲人，其实那不公平！若有人非要故意制造一些典型，那你笑看他们自己去煽情吧！</p><p>第3条）学校的事重要，学生的事重要，家里的事情也重要；工作重要，生活重要，身体健康更重要；别因一种重要而忽略另一种重要，其实那样不地道！若有人非要给你戴高帽，嘿嘿，劝君一摆手：不要，不要！</p><p>第4条）与时俱进，活到老，学到老。你曾经的辉煌毋庸置疑，但社会在飞速发展，技术在不断更新，新的挑战随时涌现，对人才的需求也在不断变化，你若不能紧跟形势，就会被边缘化，更会误人子弟。提醒一下，你有许多东西搞不懂，你需要向其它导师学习，甚至向研究生学习！</p><p>第5条）研究生培养的手段，应服务于目标。社会满意度是人才培养的唯一且永恒目标，你有义务通过各种手段，大幅提高学生进入社会后的竞争力。只要有利于培养更多更优秀的学生，就该坚定不移地走自己的路，让他人说去吧。培养研究生的目的，不是为了赢得某些领导的肯定，而是为社会培养有用之才！</p><p>第6条）全面理解创新内涵，重点培养创新能力。撰写论文、出版著作、研究高精尖课题等，都是培养研究生创新能力的有效手段；但实用产品开发、系统集成项目、软课题研究、成果转化等，也是培养创新能力的有效手段，它们不能被否认，甚至被歪曲。创新能力的培养既可在校内完成，更可通过校企合作完成。</p><p>第7条）放下架子培养学生的社会适应能力。导师称谓确实令人崇敬，但若优越感过强，将害人害已。每个人都该努力适应社会，而不是让社会来适应他。<br>你能从自己做起，为学生树立榜样吗？项目谈判时，你能低头当好乙方吗？在欣赏自己的长处时，能尊重他人的短处吗？在重视纵向项目时，能不轻视横向项目吗？在取得理论成果时，能不藐视技术吗？能真心帮助暂时不如自己的同事吗？能真心佩服比自己强的其它老师吗？能时时事事转换角色吗？伙计，你的一举一动，可都是你学生的最好教材哟。</p><p>第8条）以身作则培养学生的团队精神。在激烈竞争的社会里，特别是在理工科行业里，没团队就几乎不可能有成功。“兵、将、帅”在任何团队中都不可缺少。团队精神既包括“挂帅”的智慧，也包括“做将”的勇气，更包括“当兵”的情怀。<br>导师的如下行为，将严重影响研究生的团队精神培养：不挂“帅”吾宁死，那怕自身根本就不是帅才；若做“将”就只图清闲，不愿意面对任何攻坚；若当“兵”则懒散闲，放任自流，完全不顾团队的集体利益和自己应尽的义务。相信个别导师的这种行为，将不会得到研究生的认可，甚至可能被学生传为笑谈，当成反面教材。</p><p>第9条）“宽是害、严是爱”也适用于研究生培养，当然得因人而已，适当把握好度。师生是永远的利益共同体，即使毕业后，学生的成功，导师也是最大的受益者之一。处处迁就，肯定不是培养优秀研究生的好方法，虽然这样做可能会暂时获得某些学生的好感。<br>所谓“一日为师，终生为父”就是要求导师像严父对待自己的儿子一样，敢于逼其成功！当然，对个别学生，你也要做好“一日为师，终生为孙”的准备；其实，那时你连孙子都不如，世上哪有爷爷坑害孙子的事！</p><p>第10条）不是“成功才幸福”而是“幸福才成功”。成功很容易被片面有形化，比如，升职称、拿大奖、当选院士等。“有形成功”确实能带来短暂的幸福，但是，过于看重“有形成功”其实就是对自己幸福的不负责。上帝其实很公平，鱼和熊掌很难兼得，只要你踏踏实实，从现在做起，从小事做起，沿着自己心中的理想之路，你就能一边前进，一边幸福地享受沿途风光。</p><p>第11条）树立阳光心态应从导师做起。人人都在追求幸福，但有人却永远也找不到幸福；其实幸福就在每个人的心里。心态不良者看世间万物都不顺眼，消极悲观者不但自己活得累，也会严重污染生活环境，他们既毁灭了自己的幸福，更连累了身边的亲朋好友。“小事靠勤、中事靠能，大事靠德”，要想做一个好导师，必须以积极的心态在勤、能、德三个方面为学生垂范。</p><p>第12条）把钢加在刀刃上，重视培养研究生的综合素质。研究生毕业后，彼此之间的智商差别相对有限；但是，情商方面，可能就天壤之别了。而情商的高低，在毕业生后的职业生涯中，将起着越来越重要的作用；因此，花大力气提高研究生的情商，是事半功倍的最佳选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;告研究生新生书&quot;&gt;&lt;a href=&quot;#告研究生新生书&quot; class=&quot;headerlink&quot; title=&quot;告研究生新生书&quot;&gt;&lt;/a&gt;告研究生新生书&lt;/h1&gt;&lt;p&gt;作者：北京邮电大学杨义先教授&lt;/p&gt;
&lt;p&gt;各位新同学，大家好！&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="告研究生新生/研究生导师书" scheme="https://uppez.github.io/tags/%E5%91%8A%E7%A0%94%E7%A9%B6%E7%94%9F%E6%96%B0%E7%94%9F-%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AF%BC%E5%B8%88%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>开源协议</title>
    <link href="https://uppez.github.io/2019/10/05/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    <id>https://uppez.github.io/2019/10/05/开源协议/</id>
    <published>2019-10-05T13:41:11.000Z</published>
    <updated>2019-10-05T13:52:05.729Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.runoob.com/w3cnote/open-source-license.html" target="_blank" rel="noopener">各种开源协议介绍</a></p><p><a href="https://blog.csdn.net/qq_22494029/article/details/79731340" target="_blank" rel="noopener">几种常见的开源协议</a></p><p><a href="http://123.baidu.com/" target="_blank" rel="noopener">了解其他开源协议</a></p><a id="more"></a><p>世界上的开源许可证（Open Source License）大概有上百种，我们常用的开源软件协议大致有GPL、BSD、MIT、Mozilla、Apache和LGPL。我们不必要每个开源协议都了然于心，但是可以了解几个主要的协议的权利和义务。</p><p><a href="https://sm.ms/image/bnwXaotEYFueZmd" target="_blank"><img src="https://i.loli.net/2019/10/05/bnwXaotEYFueZmd.png"></a></p><p>如果看完还是一头雾水的话，乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择，下图为国内大牛阮一峰汉化了版本。</p><p><a href="https://sm.ms/image/YdRXQiZUxWLDKOI" target="_blank"><img src="https://i.loli.net/2019/10/05/YdRXQiZUxWLDKOI.png"></a></p><p>来一个更加清晰和完全一点的图，目前只有英文版，<strong>后期我将会进行汉化</strong>。</p><p><a href="https://sm.ms/image/lswBQk5mXKuyPtU" target="_blank"><img src="https://i.loli.net/2019/10/05/lswBQk5mXKuyPtU.png"></a></p><p>希望这些总结可以帮助每一个人都能更好的为自己的开源项目选择一个合适的开源协议，当自己的开源项目被侵权的时候不至于处于被动的位置，也希望可以帮助到每一个人都能“合法”的应用开源项目，很多开源协议最低要求是使用者需要保留原作者对代码的声明，估计大家都会忽略掉了吧。</p><p><strong>开源不等于免费，开源也不等于没有约束</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.runoob.com/w3cnote/open-source-license.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;各种开源协议介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_22494029/article/details/79731340&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;几种常见的开源协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://123.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;了解其他开源协议&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="开源协议" scheme="https://uppez.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>马尔可夫链</title>
    <link href="https://uppez.github.io/2019/10/05/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"/>
    <id>https://uppez.github.io/2019/10/05/马尔可夫链/</id>
    <published>2019-10-05T07:21:56.000Z</published>
    <updated>2019-10-05T08:13:50.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h1><p>马尔可夫链 （Markov Chain）是什么鬼</p><p>它是随机过程中的一种过程，一个统计模型，到底是哪一种过程呢？好像一两句话也说不清楚，还是先看个例子吧。</p><a id="more"></a><p>先说说我们村智商为0的王二狗，人傻不拉几的，见人就傻笑，每天中午12点的标配，仨状态：吃，玩，睡。这就是传说中的状态分布。</p><p><a href="https://sm.ms/image/rTPe9BksO2CmyEf" target="_blank"><img src="https://i.loli.net/2019/10/05/rTPe9BksO2CmyEf.jpg"></a></p><p>你想知道他n天后中午12点的状态么？是在吃，还是在玩，还是在睡？这些状态发生的概率分别都是多少？ （知道你不想，就假装想知道吧<del>学习真的好累</del>）</p><p>先看个假设，他每个状态的转移都是有概率的，比如今天玩，明天睡的概率是几，今天玩，明天也玩的概率是几几，还是先看个图吧，更直观一些。</p><p><a href="https://sm.ms/image/b82vLiOWGIRe4tJ" target="_blank"><img src="https://i.loli.net/2019/10/05/b82vLiOWGIRe4tJ.jpg"></a></p><p>这个矩阵就是转移概率矩阵P，并且它是保持不变的，就是说第一天到第二天的转移概率矩阵跟第二天到第三天的转移概率矩阵是一样的。（这个叫时齐，不细说了，有兴趣的同学自行百度）。</p><p>有了这个矩阵，再加上已知的第一天的状态分布，就可以计算出第N天的状态分布了。</p><p><a href="https://sm.ms/image/OmJWx8GtpwPfM9C" target="_blank"><img src="https://i.loli.net/2019/10/05/OmJWx8GtpwPfM9C.jpg"></a></p><p>这个矩阵就是转移概率矩阵P，并且它是保持不变的，就是说第一天到第二天的转移概率矩阵跟第二天到第三天的转移概率矩阵是一样的。（这个叫时齐，不细说了，有兴趣的同学自行百度）。</p><p>有了这个矩阵，再加上已知的第一天的状态分布，就可以计算出第N天的状态分布了。</p><p><a href="https://sm.ms/image/vClONiZgf1XWJ6a" target="_blank"><img src="https://i.loli.net/2019/10/05/vClONiZgf1XWJ6a.jpg"></a></p><h2 id="正式理解"><a href="#正式理解" class="headerlink" title="正式理解"></a>正式理解</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>马尔科夫链定义本身比较简单，它假设某一时刻状态转移的概率只依赖于它的前一个状态。举个形象的比喻，假如每天的天气是一个状态的话，那个今天是不是晴天只依赖于昨天的天气，而和前天的天气没有任何关系。当然这么说可能有些武断，但是这样做可以大大简化模型的复杂度，因此马尔科夫链在很多时间序列模型中得到广泛的应用，比如循环神经网络RNN，隐式马尔科夫模型HMM等，当然MCMC也需要它。</p><p>如果用精确的数学定义来描述，则假设我们的序列状态是…Xt−2,Xt−1,Xt,Xt+1,…，那么我们的在时刻Xt+1的状态的条件概率仅仅依赖于时刻Xt，即：</p><center><a href="https://sm.ms/image/5m7sre1LUywfDAH" target="_blank"><img src="https://i.loli.net/2019/10/05/5m7sre1LUywfDAH.png"></a></center><p>既然某一时刻状态转移的概率只依赖于它的前一个状态，那么我们只要能求出系统中任意两个状态之间的转换概率，这个马尔科夫链的模型就定了。我们来看看下图这个马尔科夫链模型的具体的例子(来源于维基百科)。</p><center><a href="https://sm.ms/image/CXVW6iOcgtnj2LU" target="_blank"><img src="https://i.loli.net/2019/10/05/CXVW6iOcgtnj2LU.png"></a></center><p>这个马尔科夫链是表示股市模型的，共有三种状态：牛市（Bull market）, 熊市（Bear market）和横盘（Stagnant market）。每一个状态都以一定的概率转化到下一个状态。比如，牛市以0.025的概率转化到横盘的状态。这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i,j)的值为P(j|i),即从状态i转化到状态j的概率，并定义牛市为状态0， 熊市为状态1, 横盘为状态2. 这样我们得到了马尔科夫链模型的状态转移矩阵为：</p><center><a href="https://sm.ms/image/uDtz538d4SAbipw" target="_blank"><img src="https://i.loli.net/2019/10/05/uDtz538d4SAbipw.png"></a></center><p>讲了这么多，那么马尔科夫链模型的状态转移矩阵和我们蒙特卡罗方法需要的概率分布样本集有什么关系呢？这需要从马尔科夫链模型的状态转移矩阵的性质讲起。</p><h2 id="马尔科夫链模型状态转移矩阵的性质"><a href="#马尔科夫链模型状态转移矩阵的性质" class="headerlink" title="马尔科夫链模型状态转移矩阵的性质"></a>马尔科夫链模型状态转移矩阵的性质</h2><p>　　　　<br>得到了马尔科夫链模型的状态转移矩阵，我们来看看马尔科夫链模型的状态转移矩阵的性质。</p><p>仍然以上面的这个状态转移矩阵为例。假设我们当前股市的概率分布为：[0.3,0.4,0.3],即30%概率的牛市，40%概率的熊盘与30%的横盘。然后这个状态作为序列概率分布的初始状态t0，将其带入这个状态转移矩阵计算t1,t2,t3…的状态。代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line">matrix = np.matrix([[<span class="hljs-number">0.9</span>,<span class="hljs-number">0.075</span>,<span class="hljs-number">0.025</span>],[<span class="hljs-number">0.15</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.05</span>],[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>]], dtype=float)</span><br><span class="line">vector1 = np.matrix([[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.3</span>]], dtype=float)</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):</span><br><span class="line">    vector1 = vector1*matrix</span><br><span class="line">    print(<span class="hljs-string">"Current round:"</span> , i+<span class="hljs-number">1</span>)</span><br><span class="line">    print(vector1)</span><br></pre></td></tr></table></figure><p>部分输出结果如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Current round: 1</span><br><span class="line">[[ 0.405   0.4175  0.1775]]</span><br><span class="line">Current round: 2</span><br><span class="line">[[ 0.4715   0.40875  0.11975]]</span><br><span class="line">Current round: 3</span><br><span class="line">[[ 0.5156  0.3923  0.0921]]</span><br><span class="line">Current round: 4</span><br><span class="line">[[ 0.54591   0.375535  0.078555]]</span><br><span class="line">。。。。。。</span><br><span class="line">Current round: 58</span><br><span class="line">[[ 0.62499999  0.31250001  0.0625    ]]</span><br><span class="line">Current round: 59</span><br><span class="line">[[ 0.62499999  0.3125      0.0625    ]]</span><br><span class="line">Current round: 60</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br><span class="line">。。。。。。</span><br><span class="line">Current round: 99</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br><span class="line">Current round: 100</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br></pre></td></tr></table></figure><p>可以发现，从第60轮开始，我们的状态概率分布就不变了，一直保持在[0.625   0.3125  0.0625]，即62.5%的牛市，31.25%的熊市与6.25%的横盘。那么这个是巧合吗？</p><p>我们现在换一个初始概率分布试一试，现在我们用[0.7,0.1,0.2]作为初始概率分布，然后这个状态作为序列概率分布的初始状态t0，将其带入这个状态转移矩阵计算t1,t2,t3…的状态。代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = np.matrix([[<span class="hljs-number">0.9</span>,<span class="hljs-number">0.075</span>,<span class="hljs-number">0.025</span>],[<span class="hljs-number">0.15</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.05</span>],[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>]], dtype=float)</span><br><span class="line">vector1 = np.matrix([[<span class="hljs-number">0.7</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>]], dtype=float)</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):</span><br><span class="line">    vector1 = vector1*matrix</span><br><span class="line">    print(<span class="hljs-string">"Current round:"</span> , i+<span class="hljs-number">1</span>)</span><br><span class="line">    print(vector1)</span><br></pre></td></tr></table></figure><p>部分输出结果如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Current round: 1</span><br><span class="line">[[ 0.695   0.1825  0.1225]]</span><br><span class="line">Current round: 2</span><br><span class="line">[[ 0.6835   0.22875  0.08775]]</span><br><span class="line">Current round: 3</span><br><span class="line">[[ 0.6714  0.2562  0.0724]]</span><br><span class="line">Current round: 4</span><br><span class="line">[[ 0.66079   0.273415  0.065795]]</span><br><span class="line">。。。。。。。</span><br><span class="line">Current round: 55</span><br><span class="line">[[ 0.62500001  0.31249999  0.0625    ]]</span><br><span class="line">Current round: 56</span><br><span class="line">[[ 0.62500001  0.31249999  0.0625    ]]</span><br><span class="line">Current round: 57</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br><span class="line">。。。。。。。</span><br><span class="line">Current round: 99</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br><span class="line">Current round: 100</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br></pre></td></tr></table></figure><p>可以看出，尽管这次我们采用了不同初始概率分布，最终状态的概率分布趋于同一个稳定的概率分布[0.625   0.3125  0.0625]， 也就是说我们的马尔科夫链模型的状态转移矩阵收敛到的稳定概率分布与我们的初始状态概率分布无关。这是一个非常好的性质，也就是说，如果我们得到了这个稳定概率分布对应的马尔科夫链模型的状态转移矩阵，则我们可以用任意的概率分布样本开始，带入马尔科夫链模型的状态转移矩阵，这样经过一些序列的转换，最终就可以得到符合对应稳定概率分布的样本。</p><p>这个性质不光对我们上面的状态转移矩阵有效，对于绝大多数的其他的马尔科夫链模型的状态转移矩阵也有效。同时不光是离散状态，连续状态时也成立。</p><p>同时，对于一个确定的状态转移矩阵P，它的n次幂Pn在当n大于一定的值的时候也可以发现是确定的，我们还是以上面的例子为例，计算代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">matrix = np.matrix([[<span class="hljs-number">0.9</span>,<span class="hljs-number">0.075</span>,<span class="hljs-number">0.025</span>],[<span class="hljs-number">0.15</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.05</span>],[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>]], dtype=float)</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):</span><br><span class="line">    matrix = matrix*matrix</span><br><span class="line">    print(<span class="hljs-string">"Current round:"</span> , i+<span class="hljs-number">1</span>)</span><br><span class="line">    print(matrix)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Current round: 1</span><br><span class="line">[[ 0.8275   0.13375  0.03875]</span><br><span class="line"> [ 0.2675   0.66375  0.06875]</span><br><span class="line"> [ 0.3875   0.34375  0.26875]]</span><br><span class="line">Current round: 2</span><br><span class="line">[[ 0.73555   0.212775  0.051675]</span><br><span class="line"> [ 0.42555   0.499975  0.074475]</span><br><span class="line"> [ 0.51675   0.372375  0.110875]]</span><br><span class="line">。。。。。。</span><br><span class="line">Current round: 5</span><br><span class="line">[[ 0.62502532  0.31247685  0.06249783]</span><br><span class="line"> [ 0.6249537   0.31254233  0.06250397]</span><br><span class="line"> [ 0.62497828  0.31251986  0.06250186]]</span><br><span class="line">Current round: 6</span><br><span class="line">[[ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]]</span><br><span class="line">Current round: 7</span><br><span class="line">[[ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]]</span><br><span class="line">。。。。。。</span><br><span class="line">Current round: 9</span><br><span class="line">[[ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]]</span><br><span class="line">Current round: 10</span><br><span class="line">[[ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]</span><br><span class="line"> [ 0.625   0.3125  0.0625]]</span><br></pre></td></tr></table></figure><p>我们可以发现，在n≥6以后，P的n次方的值稳定不再变化，而且每一行都为[0.625   0.3125  0.0625]，这和我们前面的稳定分布是一致的。这个性质同样不光是离散状态，连续状态时也成立。</p><p>好了，现在我们可以用数学语言总结下马尔科夫链的收敛性质了：</p><p>如果一个非周期的马尔科夫链有状态转移矩阵P, 并且它的任何两个状态是连通的，那么limn→∞Pnij与i无关，我们有：</p><center><a href="https://sm.ms/image/bz8Q59AUDtSi72f" target="_blank"><img src="https://i.loli.net/2019/10/05/bz8Q59AUDtSi72f.png"></a></center><p>上面的性质中需要解释的有：</p><p>1）非周期的马尔科夫链：这个主要是指马尔科夫链的状态转化不是循环的，如果是循环的则永远不会收敛。幸运的是我们遇到的马尔科夫链一般都是非周期性的。用数学方式表述则是：对于任意某一状态i，d为集合{n|n≥1,Pnii&gt;0} 的最大公约数，如果 d=1 ，则该状态为非周期的。</p><p>2）任何两个状态是连通的：这个指的是从任意一个状态可以通过有限步到达其他的任意一个状态，不会出现条件概率一直为0导致不可达的情况。</p><p>3）马尔科夫链的状态数可以是有限的，也可以是无限的。因此可以用于连续概率分布和离散概率分布。</p><p>4）π通常称为马尔科夫链的平稳分布。</p><p>参考链接：</p><ol><li><p><a href="https://blog.csdn.net/renhaofan/article/details/82186858" target="_blank" rel="noopener">马尔可夫链五分钟简单入门</a></p></li><li><p><a href="https://www.cnblogs.com/pinard/p/6632399.html" target="_blank" rel="noopener">马尔可夫链</a></p></li><li><p><a href="https://blog.csdn.net/bitcarmanlee/article/details/82819860" target="_blank" rel="noopener">小白都能看懂的马尔可夫链</a></p></li></ol><p>动态在线演示：</p><p><a href="http://setosa.io/ev/markov-chains/" target="_blank" rel="noopener">http://setosa.io/ev/markov-chains/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;通俗理解&quot;&gt;&lt;a href=&quot;#通俗理解&quot; class=&quot;headerlink&quot; title=&quot;通俗理解&quot;&gt;&lt;/a&gt;通俗理解&lt;/h1&gt;&lt;p&gt;马尔可夫链 （Markov Chain）是什么鬼&lt;/p&gt;
&lt;p&gt;它是随机过程中的一种过程，一个统计模型，到底是哪一种过程呢？好像一两句话也说不清楚，还是先看个例子吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://uppez.github.io/categories/AI/"/>
    
    
      <category term="机器学习" scheme="https://uppez.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>电子类书籍搜索网站</title>
    <link href="https://uppez.github.io/2019/10/04/%E7%94%B5%E5%AD%90%E7%B1%BB%E4%B9%A6%E7%B1%8D%E6%90%9C%E7%B4%A2%E7%BD%91%E7%AB%99/"/>
    <id>https://uppez.github.io/2019/10/04/电子类书籍搜索网站/</id>
    <published>2019-10-04T13:21:49.000Z</published>
    <updated>2019-10-04T13:31:04.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「万千合集站」"><a href="#「万千合集站」" class="headerlink" title="「万千合集站」"></a>「万千合集站」</h1><p>万千合集站融合了大学、考研等各种教科书的网盘下载链接，种类非常齐全。</p><a id="more"></a><p>当然，网站为了盈利，广告可能多些，但资源确实很全，而且提供百度网盘链接也是方便无比。</p><p>打开网站，比如搜索高等数学，搜到的版本很全，且可按热度、大小等排序，网站应该涉及到文理工科各个领域的教科书、课后答案等PDF的资料文档。</p><h1 id="「脚本之家」"><a href="#「脚本之家」" class="headerlink" title="「脚本之家」"></a>「脚本之家」</h1><p>脚本之家这个网站资源很全，分享代码、脚本和编程类书籍，编程类的pdf书籍资源确实很全，注意的就是下载的时候不要去点上面的高速下载，这应该都是常识了。</p><h1 id="「鸠摩搜书」"><a href="#「鸠摩搜书」" class="headerlink" title="「鸠摩搜书」"></a>「鸠摩搜书」</h1><p>十分有名的一个网站，不管是专业还是娱乐类书籍都能搜到，搜到的多是百度网盘或者微盘链接。</p><h1 id="「智奇搜书」"><a href="#「智奇搜书」" class="headerlink" title="「智奇搜书」"></a>「智奇搜书」</h1><p>智奇搜书和鸠摩搜书类似，也是一个电子书搜索引擎，资源搜索也是比较齐全好用。</p><h1 id="「PDF之家」"><a href="#「PDF之家」" class="headerlink" title="「PDF之家」"></a>「PDF之家」</h1><p>PDF之家分享的书籍也是很多，门类很多，也有教科书，比如计算机类的。</p><h1 id="「itbook」"><a href="#「itbook」" class="headerlink" title="「itbook」"></a>「itbook」</h1><p>itbook是一个免费下载编程类电子书的网站，涵盖了很多中英文的电子书籍，每天限制下载五本，书籍介绍页面有资源解压密码，不过看这些书名也算是淘书的一部分了。</p><h1 id="「Library-Genesis」"><a href="#「Library-Genesis」" class="headerlink" title="「Library Genesis」"></a>「Library Genesis」</h1><p>国外知名电子书下载站，界面相对比较专业了，从网站栏目上看主要分书籍、文献、杂志等，当然大部分都是外文的，且全部免费。</p><h1 id="「BookZZ」"><a href="#「BookZZ」" class="headerlink" title="「BookZZ」"></a>「BookZZ」</h1><p>如下网站，也是整洁的一个界面，直接输入想要搜索的即可，号称200多万书籍和5000多万论文也不是吹的，提供免费下载。</p><h1 id="「Online-Books」"><a href="#「Online-Books」" class="headerlink" title="「Online Books」"></a>「Online Books」</h1><p>依然国外站，称免费提供300万本电子书。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;「万千合集站」&quot;&gt;&lt;a href=&quot;#「万千合集站」&quot; class=&quot;headerlink&quot; title=&quot;「万千合集站」&quot;&gt;&lt;/a&gt;「万千合集站」&lt;/h1&gt;&lt;p&gt;万千合集站融合了大学、考研等各种教科书的网盘下载链接，种类非常齐全。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="电子书网站" scheme="https://uppez.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>工具使用推荐</title>
    <link href="https://uppez.github.io/2019/10/04/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A8%E8%8D%90/"/>
    <id>https://uppez.github.io/2019/10/04/工具使用推荐/</id>
    <published>2019-10-04T10:07:35.000Z</published>
    <updated>2019-10-09T10:01:29.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百度网盘高速下载方法"><a href="#百度网盘高速下载方法" class="headerlink" title="百度网盘高速下载方法"></a>百度网盘高速下载方法</h2><p>我爱搜盘：<a href="https://www.52sopan.com" target="_blank" rel="noopener">https://www.52sopan.com</a></p><a id="more"></a><p>轻舟网：<a href="https://www.qzhou.com.cn" target="_blank" rel="noopener">https://www.qzhou.com.cn</a></p><p>小白盘：<a href="https://www.xiaobaipan.com" target="_blank" rel="noopener">https://www.xiaobaipan.com</a></p><p>番茄搜搜：<a href="https://www.fqsousou.com" target="_blank" rel="noopener">https://www.fqsousou.com</a></p><p>探索云盘：<a href="http://tansuo233.com" target="_blank" rel="noopener">http://tansuo233.com</a></p><h2 id="几款高速下载器"><a href="#几款高速下载器" class="headerlink" title="几款高速下载器"></a>几款高速下载器</h2><h3 id="电脑端："><a href="#电脑端：" class="headerlink" title="电脑端："></a>电脑端：</h3><p>1.pandownload，推荐指数：★★★★★</p><p>下载链接：<a href="http://pandownload.com" target="_blank" rel="noopener">http://pandownload.com</a></p><p>2.速盘，推荐指数：★★★★☆</p><p>下载链接：<a href="https://www.speedpan.com" target="_blank" rel="noopener">https://www.speedpan.com</a></p><p>3.motrix，推荐指数：★★★</p><p>下载链接：<a href="https://motrix.app/" target="_blank" rel="noopener">https://motrix.app/</a></p><p>4.爱奇艺万能播放器，推荐指数：★★★</p><p>下载链接：<a href="http://t.cn/R4Pp9zi" target="_blank" rel="noopener">http://t.cn/R4Pp9zi</a></p><h3 id="手机端："><a href="#手机端：" class="headerlink" title="手机端："></a>手机端：</h3><p>只需要在平时的百度网盘链接中，加入wp两个字母，就可以下载</p><p>比如下载下面链接的文件</p><p><a href="https://pan.baidu.com/s/1cHQbmXqAfbdn1kjURnsrCw" target="_blank" rel="noopener">https://pan.baidu.com/s/1cHQbmXqAfbdn1kjURnsrCw</a> 提取码:1r9z </p><p>大家只需要在baidu后面加上wp，变成baiduwp即可，如下</p><p><a href="https://pan.baiduwp.com/s/1cHQbmXqAfbdn1kjURnsrCw" target="_blank" rel="noopener">https://pan.baiduwp.com/s/1cHQbmXqAfbdn1kjURnsrCw</a> </p><p>然后将链接复制到浏览器回车即可</p><h2 id="影视软件合集"><a href="#影视软件合集" class="headerlink" title="影视软件合集"></a>影视软件合集</h2><p>资源猫（安卓）  ★★★★★</p><p>犀函（iOS） ★★★★</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;百度网盘高速下载方法&quot;&gt;&lt;a href=&quot;#百度网盘高速下载方法&quot; class=&quot;headerlink&quot; title=&quot;百度网盘高速下载方法&quot;&gt;&lt;/a&gt;百度网盘高速下载方法&lt;/h2&gt;&lt;p&gt;我爱搜盘：&lt;a href=&quot;https://www.52sopan.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.52sopan.com&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="小工具" scheme="https://uppez.github.io/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>机器学习模型的“可解释性”</title>
    <link href="https://uppez.github.io/2019/10/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E2%80%9C%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E2%80%9D/"/>
    <id>https://uppez.github.io/2019/10/04/机器学习模型的“可解释性”/</id>
    <published>2019-10-04T09:48:04.000Z</published>
    <updated>2019-10-04T10:02:58.696Z</updated>
    
    <content type="html"><![CDATA[<p>无论您的解决方案的最终目标是什么，终端用户都需要可解释、可关联或可理解的解决方案。</p><a id="more"></a><h2 id="为什么机器学习中的可解释性很重要？"><a href="#为什么机器学习中的可解释性很重要？" class="headerlink" title="为什么机器学习中的可解释性很重要？"></a>为什么机器学习中的可解释性很重要？</h2><p><strong>在传统统计中，我们通过调查大量的数据来构造和验证假设。我们建立模型来构建规则，我们可以将其纳入我们的模型中。例如，营销公司可以建立一个模型，将营销活动数据与财务数据相关联，以确定构成有效营销活动的是什么。这是一种自上而下的数据科学方法，可解释性是关键，因为它是所定义规则和过程的基石。由于相关性往往不等于因果关系，所以在进行决策和解释时，需要对模型进行很强的理解。</strong></p><p>在自下而上的数据科学方法中，我们将部分业务流程委托给机器学习模型。此外，全新的商业创意可通过机器学习实现。自下而上的数据科学通常将手动和部分困难任务自动化。例如制造公司可以将传感器放在他们的机器上并进行预测维护。因此，维护工程师可以更高效地工作，而无需执行昂贵的定期检查。模型可解释性对于验证模型的行为是否符合您的期望是很有必要的，并且它可以与用户建立信任关系，并且可以简化从手动过程到自动化过程的过渡。</p><p><img src="https://i.loli.net/2019/10/04/mvP14BgNcZE9QnL.jpg" alt="1.jpg"></p><p>图显示在一个自上而下的过程中，您迭代地构造和验证一组假设。在自底向上的方法中，您试图自动化过程从自底向上解决问题。</p><p>作为一名数据科学家，您经常关心微调模型以获得最佳性能。数据科学通常被定义为：’给出具有X标签的数据，并以最小误差找到模型’。尽管训练高性能模型的能力对于数据科学家来说是一项关键技能，但能够从更大的角度来看是很重要的。<strong>数据和机器学习模型的可解释性是在数据科学的 “有用性”中至关重要的方面之一，它确保模型与您想要解决的问题保持一致</strong>。尽管在构建模型时尝试最前沿的技术可能会有很多挑战，但能够正确地解释您的发现是数据科学过程的重要组成部分。</p><p><img src="https://i.loli.net/2019/10/04/HfeIgFk8zamiTKV.jpg" alt="2.jpg"></p><h2 id="为什么深入分析模型至关重要？"><a href="#为什么深入分析模型至关重要？" class="headerlink" title="为什么深入分析模型至关重要？"></a>为什么深入分析模型至关重要？</h2><p>作为数据科学家，关注模型可解释性有几个原因。虽然它们之间存在重叠，但能捕捉到可解释性的不同动机：</p><ol><li>判别并减轻偏差（Identify and mitigate bias）：</li></ol><p>偏差可能存在于任何数据集中，数据科学家需要确定并尝试修正偏差。数据集的规模可能有限，并且不能代表所有数据，或者数据捕获过程可能没有考虑到潜在的偏差。在彻底进行数据分析后，或者分析模型预测与模型输入之间的关系时，偏差往往会变得明显。请注意，解决偏差问题没有唯一的解决方案，但是可解释性的关键一步是意识到潜在的偏差。</p><p><strong>其他偏差的例子如下</strong>：</p><p>例如word2vec向量包含性别偏差（<a href="http://wordbias.umiacs.umd.edu/），这是由于他们受过训练的语料库中存在的内在偏差。当你使用这些词向量进行训练模型时，招聘人员搜索“技术简介”将使女性履历保留在最下面。" target="_blank" rel="noopener">http://wordbias.umiacs.umd.edu/），这是由于他们受过训练的语料库中存在的内在偏差。当你使用这些词向量进行训练模型时，招聘人员搜索“技术简介”将使女性履历保留在最下面。</a></p><p>例如当您在小型数据集上训练目标检测模型时，通常情况下图像的宽度太有限。为了避免只适用于数据中噪音和不重要元素的模型，需要在不同环境，不同光照条件和不同角度下的各种物体图像。</p><ol start="2"><li>考虑问题的上下文（Accounting for the context of the problem）：</li></ol><p>在大多数问题中，您正在使用的数据集仅仅是您正试图解决的问题的粗略表示，而机器学习模型无法捕捉到真实任务的完整复杂性。可解释模型可帮助您了解并解释模型中包含和未包含的因素，并根据模型预测采取行动时考虑问题的上下文情境。</p><ol start="3"><li>改进泛化能力和性能（Improving generalisation and performance）：</li></ol><p>高解释性模型通常有更好的泛化能力。可解释性不是要了解所有数据点的模型的每个细节。必须将可靠的数据，模型和问题理解结合起来才能获得性能更好的解决方案。</p><ol start="4"><li>道德和法律原因（Ethical and legal reasons）：</li></ol><p>在财务和医疗保健这样的行业，审计决策过程并确保它是没有歧视或违反任何法律。随着数据和隐私保护法规（如GDPR）的发展，可解释性变得更加重要。此外，在医疗应用或自动驾驶汽车中，单一不正确的预测会产生重大影响，能够“验证”模型至关重要。因此，系统应该能够解释它是如何达到给定的要求的。</p><h2 id="解释你的模型"><a href="#解释你的模型" class="headerlink" title="解释你的模型"></a>解释你的模型</h2><p>关于模型可解释性的通常引用是，<strong>随着模型复杂性的增加，模型可解释性按照同样的速度降低。特征重要性是解释模型的一种基本方法</strong>。即使对于深度学习等黑盒模型，也存在提高可解释性的技术。最后，将讨论LIME框架，该框架可作为模型分析的工具箱。</p><p><strong>特征重要性（Feature importance）</strong></p><ul><li>广义线性模型</li></ul><p>广义线性模型（GLM’s）都基于以下原则：如果将特征与模型权重进行线性组合，并通过一个函数 f得到结果，则可以用它来预测各种各样的响应变量。 GLM最常见的应用是回归（线性回归），分类（logistic回归）或建模泊松过程（泊松回归）。训练后得到的权重能直接表示特征重要性，它们提供了内部模型非常具体的解释。</p><p>例如在构建文本分类器时，可以绘制最重要的特征，并验证模型是否过拟合。如果最重要的单词不符合您的直觉（例如名称或停用词），则意味着该模型拟合了数据集中的噪音，将在新数据中表现不佳。</p><p><img src="https://i.loli.net/2019/10/04/KgQf3vcUXVqZmG5.jpg" alt="4.jpg"></p><p>从TidyTextMining的文本解释能力的一个可视化的示例。</p><p><a href="https://www.tidytextmining.com/02-sentiment-analysis_files/figure-html/pipetoplot-1.png" target="_blank" rel="noopener">https://www.tidytextmining.com/02-sentiment-analysis_files/figure-html/pipetoplot-1.png</a></p><ul><li>随机森林和SVM（Random forest and SVM’s）</li></ul><p>即使是非线性模型（如基于树的模型（例如随机森林））也能够获取关于特征重要性的信息。基于核的方法（如SVM）中的权重通常不是特征重要性的很好的代表。核方法的优点在于，通过将特征投影到内核空间中，您可以捕获变量之间的非线性关系。另一方面，仅将权重视为一个特征，与交互无关。</p><p><img src="https://i.loli.net/2019/10/04/O3P7f1I2X9WGtxQ.png" alt="3.png"></p><p>图显示一个使用特征重要性可视化出的例子，图中您可以确定模型在学习什么。由于这个模型中很多重要的特征都是指这一天day的信息，所以可能需要添加额外的基于时间的特征会使其效果更好。(Kaggle)</p><p><a href="https://www.kaggle.com/general/13285" target="_blank" rel="noopener">https://www.kaggle.com/general/13285</a></p><ul><li>深度学习（Deep learning）</li></ul><p>深度学习模型由于参数的数量以及提取和组合特征的复杂方法而导致其不可解释性。作为一类模型，它能够在许多任务中获得最好的性能，许多研究集中在将模型预测与输入相关联。</p><p><img src="https://i.loli.net/2019/10/04/Bt7bE46CPYsiv1k.jpg" alt="5.jpg"></p><p>可解释机器学习的研究论文的数量正在迅速增长(MIT)。</p><p><a href="http://people.csail.mit.edu/beenkim/papers/BeenK_FinaleDV_ICML2017_tutorial.pdf" target="_blank" rel="noopener">http://people.csail.mit.edu/beenkim/papers/BeenK_FinaleDV_ICML2017_tutorial.pdf</a></p><p>特别是在面向更复杂地文本和图像处理的系统时，很难解释模型实际学到的是什么。研究的主要焦点目前主要是将<strong>输出或预测与输入数据关联</strong>。虽然在线性模型下这相当容易，但对于深度学习网络来说，它仍然是一个未解决的问题。两种主要方法是基于梯度或基于注意力机制的。</p><p>在基于梯度的方法中，使用反向传播计算目标概念的梯度用于生成一个映射，以突出显示输入中用于<strong>预测目标概念的重要区域</strong>。这通常应用于计算机视觉领域。</p><p><img src="https://i.loli.net/2019/10/04/FW9uXNaphL4zeQD.jpg" alt="6.jpg"></p><p>Grad-CAM, 一个基于梯度的方法被使用于视觉描述生成。基于输出的文字，方法能够判别出输入图像的那个区域是重要的</p><p>基于注意力机制的方法通常与序列数据（例如文本数据）一起使用。除了网络的正常权重之外，注意力权重被训练成 ‘input gates’。这些注意力权重决定最终网络输出中每个不同元素的数量。除了可解释性之外，在基于文本的“问答系统”中也可以带来更好的结果，因为网络能够“关注”其注意力。</p><p><img src="https://i.loli.net/2019/10/04/RiUjCpg2ABVadTn.jpg" alt="7.jpg"></p><p>在基于注意力机制的自动问答中，可以可视化出文本中哪个单词对于这个问题的答案是最最重要的。</p><p><strong>LIME</strong></p><p>LIME是一个更通用的框架，旨在使“任何”机器学习模型的预测更加可解释。</p><p>代码链接：<a href="https://github.com/marcotcr/lime" target="_blank" rel="noopener">https://github.com/marcotcr/lime</a></p><p>为了保持模型独立性，LIME通过修改本地模型的输入来工作。因此，它不是试图同时理解整个模型，而是修改特定的输入实例，并监控对预测的影响。在文本分类的情况下，这意味着一些词被取代，以确定哪些元素的输入影响了预测。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论您的解决方案的最终目标是什么，终端用户都需要可解释、可关联或可理解的解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://uppez.github.io/categories/AI/"/>
    
    
      <category term="机器学习" scheme="https://uppez.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学术网站</title>
    <link href="https://uppez.github.io/2019/10/04/%E5%AD%A6%E6%9C%AF%E7%BD%91%E7%AB%99/"/>
    <id>https://uppez.github.io/2019/10/04/学术网站/</id>
    <published>2019-10-04T03:46:45.000Z</published>
    <updated>2019-10-04T04:09:44.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sci-hub"><a href="#sci-hub" class="headerlink" title="sci-hub"></a>sci-hub</h1><p>网址：<br><a href="http://www.sci-hub.tw/" target="_blank" rel="noopener">http://www.sci-hub.tw/</a></p><p>备用站点：<br><a href="http://www.sci-hub.wang/" target="_blank" rel="noopener">http://www.sci-hub.wang/</a></p><a id="more"></a><p>全能文献资源下载工具，是一个由俄罗斯牛人开发的可以下载任意文献杂志的工具，只要输入你想要下载的文献题目、DOI等信息就可以获取到该文献的真实地址并在线浏览，当然更重要的是可以下载。</p><h1 id="学术导航网站"><a href="#学术导航网站" class="headerlink" title="学术导航网站"></a>学术导航网站</h1><p>学术导航网站为大家提供很多入口，比如访问sci-hub，Google学术，免费下载知网，百度文库资料等入库，非常方便！</p><p>√ <a href="http://www.4243.net" target="_blank" rel="noopener">http://www.4243.net</a></p><p>√ <a href="http://www.6453.net" target="_blank" rel="noopener">http://www.6453.net</a></p><p>√ <a href="http://www.9312.net" target="_blank" rel="noopener">http://www.9312.net</a></p><p>√ <a href="http://www.20009.net" target="_blank" rel="noopener">http://www.20009.net</a></p><p>√ <a href="http://www.sci-hub.ac.cn" target="_blank" rel="noopener">http://www.sci-hub.ac.cn</a></p><h1 id="百度学术"><a href="#百度学术" class="headerlink" title="百度学术"></a>百度学术</h1><p>网址：<br><a href="http://xueshu.baidu.com/" target="_blank" rel="noopener">http://xueshu.baidu.com/</a></p><p>涵盖了各类学术期刊，会议论文，旨在为国内外学者提供最好的科研体验。</p><p>百度学术搜素可以检索到收费和免费的学术论文，并通过时间筛选，标题，关键字，摘要，作者，出版物，文献类型被引用的次数等细化指标提高检索的精准性。</p><p>通过百度学术，都能搜到知网，万方，维普等学术网站的论文，台湾文献的论文也可以收集，其中的一项论文求救功能，相当实用。</p><p>不过，百度学术只是一个学术信息搜索引擎，如果下载还得到知网等数据库。</p><h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>网址：<br><a href="http://www.base-search.net/" target="_blank" rel="noopener">http://www.base-search.net/</a></p><p>BASE是德国比勒费尔德（Bielefeld)大学图书馆开发的一个多学科的学术搜索引擎，提供对全球异构学术资源的集成检索服务。</p><p>它整合了德国比勒费尔德大学图书馆的图书馆目录和大约160个开放资源（超过200万个文档）的数据。</p><h1 id="谷歌学术"><a href="#谷歌学术" class="headerlink" title="谷歌学术"></a>谷歌学术</h1><p>网址：</p><p><a href="https://zz.glgoo.top/scholar/" target="_blank" rel="noopener">https://zz.glgoo.top/scholar/</a> </p><p><a href="https://c.glgoo.top/scholar/" target="_blank" rel="noopener">https://c.glgoo.top/scholar/</a></p><p>目前，大陆对谷歌相关网站是屏蔽的，但可以采用一些代理或者镜像网站登陆谷歌学术，我们暂时提供2个比较稳定的谷歌学术。<br>也有镜像网站合集：</p><p><a href="http://www.4243.net" target="_blank" rel="noopener">http://www.4243.net</a> 选择一个进去就可以。</p><p>免费搜索学术文章的Google网络应用。2004年11月，Google第一次发布了Google学术搜索的试用版。该项索引包括了世界上绝大部分出版的学术期刊， 可广泛搜索学术文献的简便方法。</p><p>可以从一个位置搜索众多学科和资料来源：来自学术著作出版商、专业性社团、预印本、各大学及其他学术组织的经同行评论的文章、论文、图书、摘要和文章。</p><h1 id="Library-Genesis"><a href="#Library-Genesis" class="headerlink" title="Library Genesis"></a>Library Genesis</h1><p>网址：</p><p>1.<a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">http://gen.lib.rus.ec/</a></p><p>2.<a href="http://libgen.io/" target="_blank" rel="noopener">http://libgen.io/</a>  </p><p>3.<a href="http://libgen.org/" target="_blank" rel="noopener">http://libgen.org/</a></p><p>4.<a href="http://libgen.io/scimag/" target="_blank" rel="noopener">http://libgen.io/scimag/</a></p><p>Library Genesis号称是帮助全人类知识无版权传播的计划。网站上论文很多，下载方便，还有很多外文书籍和中文书籍，几乎每天都在更新。这也是一个神奇网站，基本上所有的外文书籍和论文都可以搜到并下载，最近的学术论文也可以下载。</p><p>Library Genesis和Sci-Hub可谓患难兄弟，之前都因为爱思唯尔惹上纠纷，而且从Library Genesis下载不了的还可以从网页直接链接到Sci-Hub下载。</p><h1 id="Cnpiec-LINK-service"><a href="#Cnpiec-LINK-service" class="headerlink" title="Cnpiec LINK service"></a>Cnpiec LINK service</h1><p>网址:<br><a href="http://cnplinker.cnpeak.com/" target="_blank" rel="noopener">http://cnplinker.cnpeak.com/</a></p><p>一个方便快捷的查阅国外各类期刊文献的综合网络平台，cnpLINKer即“中国链接服务”，目前主要提供约3600种外国期刊的目次和文摘的查询检索，电子全文链接及期刊国内馆藏分布查询功能。并时时与国外出版社保持数据内容的一致性和最新性。</p><h1 id="PMC（PubMed-Cenral"><a href="#PMC（PubMed-Cenral" class="headerlink" title="PMC（PubMed Cenral)"></a>PMC（PubMed Cenral)</h1><p>网址：<br><a href="http://www.ncbi.nlm.nih.gov/pmc/" target="_blank" rel="noopener">http://www.ncbi.nlm.nih.gov/pmc/</a></p><p>PubMed Central (PMC) 是美国国立卫生研究院提供的一项服务，存档生物医学，生命科学科研文献，PMC获得NLM(National Library of Medicine)的授权，收录存档生物/医学文献，免费是PMC的核心原则，随着技术的进步，目前文献的数字存储格式可能会淘汰，但PMC永久保存了这些内容.NLM认为数字资料不是用来存储的，持续的应用才是物尽其用，因此免费是PMC的一个核心原则.但是免费并不代表没有版权，资料虽然存储在PMC，作者和出版商才是版权的拥有者，所有使用PMC的用户必须遵守版权声明。</p><h1 id="中国知网"><a href="#中国知网" class="headerlink" title="中国知网"></a>中国知网</h1><p>网址：<br><a href="http://www.cnki.net/" target="_blank" rel="noopener">http://www.cnki.net/</a></p><p>知网，是国家知识基础设施的概念，由世界银行于1998年提出。CNKI工程是以实现全社会知识资源传播共享与增值利用为目标的信息化建设项目。由清华大学、清华同方发起，始建于1999年6月。提供CNKI 源数据库、外文类、工业类、农业类、医药卫生类、经济类和教育类多种数据库。</p><p>其中综合性数据库为中国期刊全文数据库、中国博士学位论文数据库、中国优秀硕士学位论文全文数据库、中国重要报纸全文数据库和中国重要会议文论全文数据库。</p><p>每个数据库都提供初级检索、高级检索和专业检索三种检索功能。高级检索功能最常用。</p><h1 id="DOAJ"><a href="#DOAJ" class="headerlink" title="DOAJ"></a>DOAJ</h1><p>网址：<br><a href="https://doaj.org/" target="_blank" rel="noopener">https://doaj.org/</a></p><p>DOAJ（Directory of Open Access Journal），由瑞典的隆德大学图书馆Lund University Libraries设立于2003年5月，DOAJ的优势在于收录的期刊有着严格的质量控制，包括很多SCI收录的期刊。</p><p>DOAJ收录的OA期刊数量非常多，属于目前最好的OA期刊目录网站。目前DOAJ除了查询OA期刊外，还可以查询部分期刊的文章内容。</p><h1 id="Book系列"><a href="#Book系列" class="headerlink" title="Book系列"></a>Book系列</h1><p>Book系列网站书籍种类丰富，基本专业书籍都可找到免费下载。包括Bookie、Bookzz、Bookfi等，（Bookzz、Bookfi在Library Genesis的导航栏有，但是现在貌似打不开了）。</p><p>均可免费下载文献和书籍，文献下载适合前几年的，书籍就不用说了，超级多！<br>其中BookSC网站：<br>（<a href="http://zh.booksc.org/）文献资料多。BookSC网站截止到今天，已有278多万书籍以及5242多万文献可以免费下载，大多数是pdf,djvu,eupb格式。" target="_blank" rel="noopener">http://zh.booksc.org/）文献资料多。BookSC网站截止到今天，已有278多万书籍以及5242多万文献可以免费下载，大多数是pdf,djvu,eupb格式。</a></p><p>下载也很方便，直接搜论文或者文章题目即可，还可将选择地区并设置成中国。BookSC网站体验很好，搜索后直接点下载就可以了，超级方便！</p><h1 id="arXiv"><a href="#arXiv" class="headerlink" title="arXiv"></a>arXiv</h1><p>网址：<br><a href="https://arxiv.org/" target="_blank" rel="noopener">https://arxiv.org/</a></p><p>arXiv的亮点是网站上面的文章大多数都是会投稿到学术期刊的文章，投稿作者对文章多半都是保持严谨态度的，只有少部分是一直保持预印本的形式。<br>目前arXiv文章类型主要分为七大类：物理、数学、非线性科学、计算机科学、定量生物学、定量金融学和统计。每个大类下面又分有若干子类，例如物理下面又具体分为：天体物理、凝聚态物理、广义相对论等。文章类型内容分类非常专业和全面。</p><h1 id="万方数据库"><a href="#万方数据库" class="headerlink" title="万方数据库"></a>万方数据库</h1><p>网址：<br><a href="http://www.wanfangdata.com.cn/index.html" target="_blank" rel="noopener">http://www.wanfangdata.com.cn/index.html</a></p><p>万方数据库是由万方数据公司开发的，涵盖期刊、会议纪要、论文、学术成果、学术会议论文的大型网络数据库；也是和中国知网齐名的中国专业的学术数据库。整合数亿条全球优质学术资源，集成期刊、学位、会议、科技报告、专利、视频等十余种资源类型，覆盖各研究层次，感知用户学术背景，智慧搜索。致力于帮助用户精准发现、获取与沉淀学术精华。</p><h1 id="中国科技论文在线"><a href="#中国科技论文在线" class="headerlink" title="中国科技论文在线"></a>中国科技论文在线</h1><p>网址：<br><a href="http://www.paper.edu.cn/" target="_blank" rel="noopener">http://www.paper.edu.cn/</a></p><p>科学论文专业网站，如果你是理工类的研究生，这个网站绝对是需要翻阅的。尤其是其中的科技期刊分类，有各个期刊和大学学报的联系方式，以及每期的论文下载，最重要的是全面。</p><h1 id="专利全文下载"><a href="#专利全文下载" class="headerlink" title="专利全文下载"></a>专利全文下载</h1><p>网址：<br><a href="http://www.drugfuture.com/cnpat/cn_patent.asp" target="_blank" rel="noopener">http://www.drugfuture.com/cnpat/cn_patent.asp</a></p><p>提供下载号，就能下载你需要的专利。</p><h1 id="OA图书馆"><a href="#OA图书馆" class="headerlink" title="OA图书馆"></a>OA图书馆</h1><p>网址：<br><a href="http://www.oalib.com/" target="_blank" rel="noopener">http://www.oalib.com/</a></p><p>OA图书馆是Open Access图书馆的简称。OA图书馆致力于让中国人可以免费获得高质量的文献，最早提供了很多的Open Access数据库和资源，但是由于OA的数据库资源比较分散并且数据库存储格式不统一，利用起来的非常不方便。<br>在此基础上，他们利用google的搜索技术建立了OA内容的搜索，可以很方便搜索近6000多种期刊资料和5000多个Open Access的数据库资源。现在有420万篇了，后续发展很快。</p><h1 id="PublicLibrary-of-Science"><a href="#PublicLibrary-of-Science" class="headerlink" title="PublicLibrary of Science"></a>PublicLibrary of Science</h1><p>网址：<br><a href="https://www.plos.org/" target="_blank" rel="noopener">https://www.plos.org/</a><br>科学公共图书馆原是是一家由众多诺贝尔奖得主和慈善机构支持的非赢利性学术组织，旨在推广世界各地的科学和医学领域的最新研究成果。</p><p>PLoS出版了多种生命科学与医学领域的开放获取期刊，可以免费获取全文，比较具有影响力。Plos系列的期刊目前都已被SCI收录。虽然期刊数量不多，但是文章总体数量相当庞大。</p><h1 id="Socolar"><a href="#Socolar" class="headerlink" title="Socolar"></a>Socolar</h1><p>网址：<br><a href="http://www.socolar.com/" target="_blank" rel="noopener">http://www.socolar.com/</a></p><p>Socolar是一个旨在为用户提供OA资源检索和全文链接服务的公共服务平台，为非赢利性项目。</p><p>用户在使用Socolar时，可以不用注册。收录了来自世界各地、各种语种的重要OA资源，并优先收录经过学术质量控制的期刊（比如同行评审期刊）。</p><h1 id="本地Pubmed"><a href="#本地Pubmed" class="headerlink" title="本地Pubmed"></a>本地Pubmed</h1><p>网址：<br><a href="http://www.yuntsg.com" target="_blank" rel="noopener">http://www.yuntsg.com</a></p><p>可在百度中搜索“本地Pubmed”；或直接进入网址：<a href="http://www.yuntsg.com" target="_blank" rel="noopener">http://www.yuntsg.com</a><br>本系统是华中科技大学同济医学院与济南泉方科技有限公司合作开发，本系统是在美国PubMed的基础上，参考CiteScore期刊评价系统、泉方学术搜索、德国的GoPubMed等整合开发的检索平台。</p><p>需先行注册，注册很简单，只需按照要求填写，注册完成后能够试用3个月时间，如需继续使用得注册其他账号。然后点击上图中本地Pubmed检索系统进入查询页面。</p><h1 id="Scientific-Research-Publishing"><a href="#Scientific-Research-Publishing" class="headerlink" title="Scientific Research Publishing"></a>Scientific Research Publishing</h1><p>网址：<br><a href="http://www.scirp.org/" target="_blank" rel="noopener">http://www.scirp.org/</a></p><p>ScientificResearch Publishing（科研出版社，简称SRP)是一家国际综合性开源学术期刊出版机构。</p><p>目前已有国际开源英文期刊近三百本，所有期刊都是开源的（OpenAccess，或称开放存取, 简称OA），可免费下载所有期刊全文，所有期刊均回溯至创刊。</p><p>多数期刊已被CAS，EBSCO，CAB Abstracts，ProQuest，IndexCopernicus，Library of Congress，Gale，CSP等数据库全文或摘要收录。</p><h1 id="NIMS日本国立材料研究"><a href="#NIMS日本国立材料研究" class="headerlink" title="NIMS日本国立材料研究"></a>NIMS日本国立材料研究</h1><p>网址：<br><a href="http://www.nims.go.jp/eng/" target="_blank" rel="noopener">http://www.nims.go.jp/eng/</a></p><p>旗下有NIMS NOW International，NIMS所属的每月通讯，2003年7月成立。每月覆盖范围包括国立材料研究所的最新研究活动，管理政策，在国际合作方面取得的进展，世界著名学者的访问、优秀的研究人员和工作人员，以及其他信息，报告当前的科研进展以及材料科学的重要趋势。</p><p>NIMS在以下领域已经被公认为全球的领导者，包括：<br>高温高压技术合成单晶金刚石和氮化硼；N型掺杂金刚石薄膜；光电应用，如深紫外激光和发光二极管；氮化硼纳米管的生长与表征；超导和有机材料；功能陶瓷，如超塑性陶瓷等；纳米颗粒催化作用；电子束诱导沉积——一种利用离子束和电子显微镜合成纳米结构和器件的技术；</p><p>此外，NIMS已经在一些全新的器件和技术领域开始开拓：原子开关——一种控制原子运动的纳米级半导体器件；基于单壁碳纳米管的全世界最小温度计；巨电致伸缩效应；暖喷涂——一种高效的在金属，聚合物和玻璃上进行涂覆的新技术。</p><p>不仅如此，NIMS还具有在线材料数据库：<br><a href="http://mits.nims.go.jp/index_en.html" target="_blank" rel="noopener">http://mits.nims.go.jp/index_en.html</a> 。绝对是查询材料参数的好去处。</p><h1 id="HighWire-Press-数据库"><a href="#HighWire-Press-数据库" class="headerlink" title="HighWire Press 数据库"></a>HighWire Press 数据库</h1><p>网址：<br><a href="http://highwire.stanford.edu/lists/allsites.dtl" target="_blank" rel="noopener">http://highwire.stanford.edu/lists/allsites.dtl</a></p><p>HighWire Press是全球最大的提供免费全文的学术文献出版商;于1995年由美国斯坦福大学图书馆创立。最初仅出版著名的周刊“Journal of Biological Chemistry”，现提供1300余种期刊，涵盖生物科学、人文、医学、物理科学、社会科学等大类。标为free的可免费访问全文。</p><h1 id="Nature"><a href="#Nature" class="headerlink" title="Nature"></a>Nature</h1><p>网址：<br><a href="http://www.nature.com/nature/index.html" target="_blank" rel="noopener">http://www.nature.com/nature/index.html</a></p><p>在2014年12月时，《自然》（Nature）也宣布了开放所有研究论文，包括旗下48个杂志，可惜不能免费复制、打印或下载。</p><h1 id="中国学术会议在线"><a href="#中国学术会议在线" class="headerlink" title="中国学术会议在线"></a>中国学术会议在线</h1><p>网址：<br><a href="http://www.meeting.edu.cn/meeting/indexS.jsp" target="_blank" rel="noopener">http://www.meeting.edu.cn/meeting/indexS.jsp</a></p><p>适用于投稿学术会议，为用户提供学术会议信息预报，会议分类搜素，会议在线报名，会议论文征集，会议资料发布，会议视频点播，会议同步直播等服务。</p><h1 id="科学网"><a href="#科学网" class="headerlink" title="科学网"></a>科学网</h1><p>网址：<br><a href="http://www.sciencenet.cn/" target="_blank" rel="noopener">http://www.sciencenet.cn/</a></p><p>科学网是由中国科学院，中国工程院和国家自然科学基金委员会主管，科学时报社主办的综合性科学网站。</p><p>主要提供快捷权威的科学新闻报道，丰富实用的科学信息服务以及交流互动的网络平台，目标是建成最具影响力的华人科学社区，查询国际会议也很方便。</p><h1 id="台大學術期刊資料庫"><a href="#台大學術期刊資料庫" class="headerlink" title="台大學術期刊資料庫"></a>台大學術期刊資料庫</h1><p>网址：<br><a href="http://ejournal.press.ntu.edu.tw/" target="_blank" rel="noopener">http://ejournal.press.ntu.edu.tw/</a></p><p>「台大学术期刊数据库」收录台大各学术研究单位出版之中外学术期刊论文篇目与全文，审查过程严谨、内容丰富详实、撰写格式一致，具相当程度之学术水平，为查询台湾一流学府之学术研究发展、辅助教学研究之最佳数据库。</p><p>数据库内容采实时更新方式，收录自民国91年(公元2002年) 1月起出刊之台大各中外学术期刊、论文书目资料，以及自民国92年(公元2003年)1月起出刊之期刊电子全文档案，并且现正逐批回溯建档中。</p><h1 id="EBOOKEE"><a href="#EBOOKEE" class="headerlink" title="EBOOKEE"></a>EBOOKEE</h1><p>网址：<br><a href="https://ebookee.org/" target="_blank" rel="noopener">https://ebookee.org/</a></p><p>该站书籍种类丰富，基本专业书籍都可找到。这一系列网站唯一不好的地方就是网络硬盘存储，下载麻烦，有广告。部分网络硬盘在国内可能被墙，需要挂代理，不过淘宝上有代下国外网盘的服务。</p><h1 id="SciELO科技在线电子图书馆"><a href="#SciELO科技在线电子图书馆" class="headerlink" title="SciELO科技在线电子图书馆"></a>SciELO科技在线电子图书馆</h1><p>网址：<br><a href="http://www.scielo.org/" target="_blank" rel="noopener">http://www.scielo.org/</a></p><p>1998年，巴西开通了第一个“科技在线电子图书馆（SciELO）”，随后扩展到阿根廷、智利、西班牙、古巴、哥伦比亚、葡萄牙、委内瑞拉七国。目前已提供613种专业期刊、20万篇论文全文供读者免费阅览。</p><h1 id="NSTL开放学术资源系统网"><a href="#NSTL开放学术资源系统网" class="headerlink" title="NSTL开放学术资源系统网"></a>NSTL开放学术资源系统网</h1><p>网址：<br><a href="http://oar.nstl.gov.cn/" target="_blank" rel="noopener">http://oar.nstl.gov.cn/</a><br>开放获取期刊集成检索系统是集期刊浏览、期刊检索两种功能为一体的开放式的期刊集成揭示与检索系统。</p><p>系统提供刊名字顺浏览、学科分类浏览两种浏览方式，且浏览过程中可通过期刊的一般信息与详细信息切换提示，进一步了解某个期刊的全部信息，其中包括刊名、ISSN、主题、学科分类、期刊内容揭示层次等15种相关信息。同时用户可对刊名、ISSN、主题、出版者及全部字段进行期刊检索。</p><h1 id="Exlibris-开放获取电子期刊查询系统"><a href="#Exlibris-开放获取电子期刊查询系统" class="headerlink" title="Exlibris 开放获取电子期刊查询系统"></a>Exlibris 开放获取电子期刊查询系统</h1><p>网址：<br><a href="http://coreej.cceu.org.cn/index.html" target="_blank" rel="noopener">http://coreej.cceu.org.cn/index.html</a></p><p>Exlibris开放获取电子期刊查询系统是由艾利贝斯公司为中国用户联合会用户提供的免费期刊查询服务。除一般检索外，用户可按学科进行快速分类浏览，也可以依据OA期刊、核心期刊、NSTL订购期刊进行查找。该系统还对投稿及全文获取进行了很有效的指引。</p><h1 id="国家哲学社会科学文献中心"><a href="#国家哲学社会科学文献中心" class="headerlink" title="国家哲学社会科学文献中心"></a>国家哲学社会科学文献中心</h1><p>网址：<br><a href="http://www.ncpssd.org" target="_blank" rel="noopener">http://www.ncpssd.org</a></p><p>国家哲学社会科学文献中心是由中国社会科学院牵头，教育部和国家新闻出版广电总局配合建设，2016年12月30日正式上线运行。</p><p>主要开设有资讯、资源、专题、服务四个栏目，资源包括中文期刊、外文期刊、外文图书、古籍四类，收录哲学社会科学相关领域文献共计10,000,000余条，提供有线阅读、全文下载等服务；还收录有国内外哲学社会科学领域重要的政府机构、高等院校、学术机构以及数据库的链接便于广大读者查阅、使用。</p><p>初步形成国家哲学社会科学学术期刊数据库，外文学术期刊数据库，中国社会科学院科研成果数据库等特色资源数据库。</p><h1 id="SCHOLARVOX-International"><a href="#SCHOLARVOX-International" class="headerlink" title="SCHOLARVOX International"></a>SCHOLARVOX International</h1><p>网址：<br><a href="http://www.scholarvox.com/" target="_blank" rel="noopener">http://www.scholarvox.com/</a></p><p>SCHOLARVOX International 网站包括管理学，社会学，工程学，信息学等学科的20000多本电子书，有英文有法文，可在线阅读。</p><h1 id="EBSCO"><a href="#EBSCO" class="headerlink" title="EBSCO"></a>EBSCO</h1><p>网址：<br><a href="https://www.ebscohost.com/" target="_blank" rel="noopener">https://www.ebscohost.com/</a></p><p>EBSCO以商务数据为主，经济，金融，管理，市场营销，物流学的论文可在该网站找到一些大型企业的SWOT分析，公司简介，公司营业状况数据等，该网站还收录了不少营销学杂志，文献等。</p><h1 id="ECONLIT"><a href="#ECONLIT" class="headerlink" title="ECONLIT"></a>ECONLIT</h1><p>网址：<br><a href="https://www.aeaweb.org/econlit" target="_blank" rel="noopener">https://www.aeaweb.org/econlit</a></p><p>ECONLIT由美国经济学协会创办，收录了包括图书，报刊，杂志，学术论文等各种类型的文学经济学方面100多万篇文章。主要为英文资料。</p><h1 id="XERFI"><a href="#XERFI" class="headerlink" title="XERFI"></a>XERFI</h1><p>网址：<br><a href="http://www.xerfi.com/" target="_blank" rel="noopener">http://www.xerfi.com/</a></p><p>XERFI以学术研究为主，在这个网站可以找到各领域的研究报告。</p><h1 id="Theses"><a href="#Theses" class="headerlink" title="Thèses"></a>Thèses</h1><p>网址：<br><a href="https://www.theses.fr/" target="_blank" rel="noopener">https://www.theses.fr/</a></p><p>这是一个强大的论文库，无论是什么方向的论文都可以搜到一些有用的资料，还可以选择读不同学校的论文成果。</p><h1 id="JSTOR"><a href="#JSTOR" class="headerlink" title="JSTOR"></a>JSTOR</h1><p>网址：<br><a href="http://www.jstor.org/" target="_blank" rel="noopener">http://www.jstor.org/</a></p><p>这是一个英文网站，上面有很多对于法国作品、文化或者英美文化的分析（有英文有法语），如果是研究英法双语的论文，也许可以找到相关资料。</p><h1 id="UMI"><a href="#UMI" class="headerlink" title="UMI"></a>UMI</h1><p>网址：<br><a href="http://wwwlib.umi.com/" target="_blank" rel="noopener">http://wwwlib.umi.com/</a></p><p>当需要查阅国外学位论文，可使用PQDD-B(UMI博硕士论文数据库)，它 可以获取部分全文，是很好的国外资源共享平台。</p><h1 id="ResearchGATE-科学社交网站"><a href="#ResearchGATE-科学社交网站" class="headerlink" title="ResearchGATE 科学社交网站"></a>ResearchGATE 科学社交网站</h1><p>网址：<br><a href="http://www.researchgate.net" target="_blank" rel="noopener">http://www.researchgate.net</a></p><p>ResearchGATE是全球最大的科学社交网络服务网站。于2008年5月上线，至今已经有300,000多来自196不同国家的科学家加入此共同体。</p><p>ResearchGATE针对著科学家以及研究人员提供对科研做有利的线上服务。全球的研究人员可免费注册该网站而和各种领域的同事分享研究结果或讨论专业问题。除了个人中心、科学博客等工能以外，ResearchGATE提供的应用程序随时随地毫无时空的可以分享文件，资料等。</p><p>在2009年ResearchGATE踏出了开放存取的第一步。藉由本站的开放存取自存档功能科研人员可以上载自己写作的论文以便分享研究结果。由此本网站将免费提供论文参考。搜索文件可以直接使用该站的搜寻引擎而不侵犯出版社的版权。</p><p>该站点提供的索引包括各种刊物总共有三千五百万多个登记。资料库又含有六万多篇直接可以使用的论文。特别设计的浏览特点成员抓取所有重要的对外资讯库内容，包括Pubmed, Citeseer, Arxiv, Nasa Library 等。</p><h1 id="Engineering-amp-Science1937-1988"><a href="#Engineering-amp-Science1937-1988" class="headerlink" title="Engineering &amp; Science1937-1988"></a>Engineering &amp; Science1937-1988</h1><p>网址：<br><a href="http://calteches.library.caltech.edu/" target="_blank" rel="noopener">http://calteches.library.caltech.edu/</a></p><p>Engineering &amp; Science is a quarterly magazine, founded in 1937. Produced by the Caltech Office of Public Relations, its goal is to present to a scientifically literate audience a lively picture of the intellectual life and research activities at Caltech and to promote interest in science and scientific issues</p><h1 id="Find-Articles-BNET"><a href="#Find-Articles-BNET" class="headerlink" title="Find Articles @ BNET"></a>Find Articles @ BNET</h1><p>网址：<br><a href="http://findarticles.com/" target="_blank" rel="noopener">http://findarticles.com/</a></p><p>Find Articles是BNET网站下属的信息检索平台，包括3000余种出版物（期刊、网站等），在列表中对免费出版物进行了标识，检索方便</p><h1 id="ABC-Chemistry-化学免费全文期刊"><a href="#ABC-Chemistry-化学免费全文期刊" class="headerlink" title="ABC Chemistry 化学免费全文期刊"></a>ABC Chemistry 化学免费全文期刊</h1><p>网址：<br><a href="http://www.abc.chemistry.bsu.by/current/fulltext.htm" target="_blank" rel="noopener">http://www.abc.chemistry.bsu.by/current/fulltext.htm</a></p><p>ABC Chemistry是化学方面的免费全文网上期刊数据库，由白俄罗斯国立大学化学系的一位教授建立的，分为永久期刊和临时期刊两大类。</p><h1 id="Genamics-JournalSeek-期刊信息检索系统"><a href="#Genamics-JournalSeek-期刊信息检索系统" class="headerlink" title="Genamics JournalSeek 期刊信息检索系统"></a>Genamics JournalSeek 期刊信息检索系统</h1><p>网址：<br><a href="http://journalseek.net/index.htm" target="_blank" rel="noopener">http://journalseek.net/index.htm</a></p><p>Genamics JournalSeek is the largest completely categorized database of freely available journal information available on the internet. The database presently contains 95831 titles. Journal information includes the description (aims and scope), journal abbreviation, journal homepage link, subject category and ISSN. Searching this information allows the rapid identification of potential journals to publish your research in, as well as allow you to find new journals of interest to your field.</p><h1 id="Hindawi-出版公司"><a href="#Hindawi-出版公司" class="headerlink" title="Hindawi 出版公司"></a>Hindawi 出版公司</h1><p>网址：<br><a href="http://www.hindawi.com/journals/" target="_blank" rel="noopener">http://www.hindawi.com/journals/</a></p><p>Hindawi成立于1997年，是一个高速成长的OA学术出版机构，出版200余种OA期刊，学科涵盖STM(科学、技术和医学)大部分领域。</p><h1 id="Intel-Technology-Journal"><a href="#Intel-Technology-Journal" class="headerlink" title="Intel Technology Journal"></a>Intel Technology Journal</h1><p>网址：<br><a href="http://www.intel.com/technology/itj/index.htm" target="_blank" rel="noopener">http://www.intel.com/technology/itj/index.htm</a></p><p>Intel Technology Journal的所有信息都由Intel(英特尔)公司提供，是提供给英特尔公司顾客的一项服务。包含有英特尔最新的研究进展信息，重点介绍英特尔公司在微处理器和计算技术方面拥有的尖端技术。此杂志每季度出版一次，由英特尔专家撰写，是一份研究与技术的参考杂志。</p><h1 id="MIT-Open-Access-Articles"><a href="#MIT-Open-Access-Articles" class="headerlink" title="MIT Open Access Articles"></a>MIT Open Access Articles</h1><p>网址：<br><a href="http://dspace.mit.edu/handle/1721.1/49433" target="_blank" rel="noopener">http://dspace.mit.edu/handle/1721.1/49433</a></p><p>通过DSpace@MIT 提供麻省理工学院MIT发表的学术论文，包括原始稿，同行评议稿，最终出版的正式文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;sci-hub&quot;&gt;&lt;a href=&quot;#sci-hub&quot; class=&quot;headerlink&quot; title=&quot;sci-hub&quot;&gt;&lt;/a&gt;sci-hub&lt;/h1&gt;&lt;p&gt;网址：&lt;br&gt;&lt;a href=&quot;http://www.sci-hub.tw/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sci-hub.tw/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;备用站点：&lt;br&gt;&lt;a href=&quot;http://www.sci-hub.wang/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sci-hub.wang/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://uppez.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="学术网站" scheme="https://uppez.github.io/tags/%E5%AD%A6%E6%9C%AF%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
