{"pages":[{"title":"","text":"#shuoshuo_content { background-color: #fff; padding: 10px; min-height: 500px; } /* shuo */ body.theme-dark .cbp_tmtimeline::before { background: RGBA(255, 255, 255, 0.06); } ul.cbp_tmtimeline { padding: 0; } div class.cdp_tmlabel > li .cbp_tmlabel { margin-bottom: 0; } .cbp_tmtimeline { margin: 30px 0 0 0; padding: 0; list-style: none; position: relative; } /* The line */ .cbp_tmtimeline:before { content: ''; position: absolute; top: 0; bottom: 0; width: 4px; background: RGBA(0, 0, 0, 0.02); left: 80px; margin-left: 10px; } /* The date/time */ .cbp_tmtimeline > li .cbp_tmtime { display: block; /* width: 29%; */ /* padding-right: 110px; */ max-width: 70px; position: absolute; } .cbp_tmtimeline > li .cbp_tmtime span { display: block; text-align: right; } .cbp_tmtimeline > li .cbp_tmtime span:first-child { font-size: 0.9em; color: #bdd0db; } .cbp_tmtimeline > li .cbp_tmtime span:last-child { font-size: 1.2em; color: #9BCD9B; } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmtime span:last-child { color: RGBA(255, 125, 73, 0.75); } div.cbp_tmlabel > p { margin-bottom: 0; } /* Right content */ .cbp_tmtimeline > li .cbp_tmlabel { margin: 0 0 45px 65px; background: #9BCD9B; color: #fff; padding: .8em 1.2em .4em 1.2em; /* font-size: 1.2em; */ font-weight: 300; line-height: 1.4; position: relative; border-radius: 5px; transition: all 0.3s ease 0s; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); cursor: pointer; display: block; } .cbp_tmlabel:hover { /* transform:scale(1.05); */ transform: translateY(-3px); z-index: 1; -webkit-box-shadow: 0 15px 32px rgba(0, 0, 0, 0.15) !important } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel { background: RGBA(255, 125, 73, 0.75); } /* The triangle */ .cbp_tmtimeline > li .cbp_tmlabel:after { right: 100%; border: solid transparent; content: \" \"; height: 0; width: 0; position: absolute; pointer-events: none; border-right-color: #9BCD9B; border-width: 10px; top: 4px; } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel:after { border-right-color: RGBA(255, 125, 73, 0.75); } p.shuoshuo_time { margin-top: 10px; border-top: 1px dashed #fff; padding-top: 5px; } /* Media */ @media screen and (max-width: 65.375em) { .cbp_tmtimeline > li .cbp_tmtime span:last-child { font-size: 1.2em; } } .shuoshuo_author_img img { border: 1px solid #ddd; padding: 2px; float: left; border-radius: 64px; transition: all 1.0s; } .avatar { -webkit-border-radius: 100% !important; -moz-border-radius: 100% !important; box-shadow: inset 0 -1px 0 #3333sf; -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; -moz-transition: -moz-transform 0.4s ease-out; } .zhuan { transform: rotateZ(720deg); -webkit-transform: rotateZ(720deg); -moz-transform: rotateZ(720deg); } /* end */ 如果你想要成功,你就要付出更多的努力 2019年9月17日 (function () { var oldClass = \"\"; var Obj = \"\"; $(\".cbp_tmtimeline li\").hover(function () { Obj = $(this).children(\".shuoshuo_author_img\"); Obj = Obj.children(\"img\"); oldClass = Obj.attr(\"class\"); var newClass = oldClass + \" zhuan\"; Obj.attr(\"class\", newClass); }, function () { Obj.attr(\"class\", oldClass); }) })","link":"/say/index.html"},{"title":"About","text":"博主姓名:王荣胜 就读:河南理工大学本科生 联系方式: QQ:603329354 QQ交流群:843108406 邮箱:603329354@qq.com 想更加了解我,请转至:我的主页-教书的先生 我深信不疑的就是:他们以梦为马,我偏以码为梦","link":"/about/index.html"}],"posts":[{"title":"The Game of Life","text":"#引言 Python 的 Matplotlib 是最常用的图表绘制以及数据可视化库。我们对折线图、柱状图以及热力图都比较熟悉，但你知道用 Matplotlib 还能做简单的动画吗？ 下面就是用 Matplotlib 制作动画的例子。展示的是 John Conway 的 《The Game of Life》，这是一个 Metis（数据科学夏令营）中的编程挑战题目，同时给了我一个机会让我知道Matpltlib可以制作动图。看看结果的动图： 这篇文章的重点还是主要放在 python 中如何用 Matploylib 制作动画。 但如果你不太熟悉模拟游戏的话（它更像是可以看的模拟动画，而非可以玩的游戏），我来给大家介绍一下规则： 一开始先设置一个 N×N 的网格（我的动画中用的是 50×50 ）； 接着随机地向格子中填充“小细胞”（一开始随机地从 2500 个格子中选取 1500 个进行填充）； 如果邻居小细胞少于等于 1 个，那格子中的小细胞会死掉； 如果邻居大于等于 4 个的也会死掉； 只有 2 个或 3 个邻居时可以生存； 空的格子中如果正好有 3 个邻居，则会长出 1 个新的“小细胞”； 通过对规则的阅读我最先想到的是：生命游戏 代码实现注意:我运行采用的是Anaconda3集成环境；程序运行两次，第一次营造运行环境，第二次运行程序输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import timefrom IPython import displayimport matplotlib.pyplot as pltimport matplotlib.animation as animationimport numpy as npimport seaborn as snsimport random# Some helper functions# Initialize the board with starting positionsdef init_board(pos_list, my_board): for pos in pos_list: my_board[pos[0], pos[1]] = 1 return my_board# Make sure padded border values are always zerodef force_pad_zero(my_board): edge_row_0 = 0 edge_row_1 = my_board.shape[0] - 1 edge_col_0 = 0 edge_col_1 = my_board.shape[1] - 1 for index, row in enumerate(my_board): if index == 0: row[:] = 0 elif index == edge_row_1: row[:] = 0 else: row[edge_col_0] = 0 row[edge_col_1] = 0 for col in my_board: col[edge_row_0] = 0 col[edge_row_1] = 0 return my_board# Figure out the number of neighbors for a given celldef calc_neighbors(row, col, my_board): b = force_pad_zero(my_board) num_neighbors = (b[row-1,col-1] + b[row+0,col-1] + b[row+1,col-1] + b[row+1,col+0] + b[row+1,col+1] + b[row+0,col+1] + b[row-1,col+1] + b[row-1,col+0]) return num_neighbors# Update the board based on the game rules, each call to update_board is one turndef update_board(my_board): old_board = my_board.copy() set_zero = [] set_one = [] # Loop through board and update according to rules for i, row in enumerate(my_board[1:-1,1:-1]): for j, col in enumerate(row): true_i = i + 1 true_j = j + 1 # Update based on number of neighbors (using calc_neighbors) # set_zero and set_one are lists that tell me the coordinates of cells that require updating if (((calc_neighbors(true_i, true_j, my_board) &lt;= 1) or (calc_neighbors(true_i, true_j, my_board) &gt;= 4)) and my_board[true_i, true_j] != 0): set_zero.append([true_i, true_j]) elif ((calc_neighbors(true_i, true_j, my_board) == 3) and my_board[true_i, true_j] == 0): set_one.append([true_i, true_j]) # Update the required cells for index, val in enumerate(set_zero): my_board[val[0], val[1]] = 0 for index, val in enumerate(set_one): my_board[val[0], val[1]] = 1 return my_board# Input variables for the boardboardsize = 50 # board will be X by X where X = boardsizepad = 2 # padded border, do not change this!initial_cells = 1500 # this number of initial cells will be placed # in randomly generated positions# Get a list of random coordinates so that we can initialize # board with randomly placed organismspos_list = []for i in range(initial_cells): pos_list.append([random.randint(1, boardsize), random.randint(1, boardsize)])# Initialize the boardmy_board = np.zeros((boardsize+pad, boardsize+pad))my_board = init_board(pos_list, my_board)##### Animate the board ###### This will throw an error the first time you run the code, but the program will run properly if you# execute the cell again (there is an error with the animation package that I cannot seem to get rid of)# Required line for plotting the animation%matplotlib notebook# Initialize the plot of the board that will be used for animationfig = plt.gcf()# Show first image - which is the initial boardim = plt.imshow(my_board)plt.show()plt.savefig(fname='game_of_life', dpi=150)# Helper function that updates the board and returns a new image of# the updated board animate is the function that FuncAnimation callsdef animate(frame): im.set_data(update_board(my_board)) return im,# This line creates the animationanim = animation.FuncAnimation(fig, animate, frames=200, interval=50) 总结希望这篇文章能帮到大家。在结束之前，让我来帮助大家脑补更多我们今天学到的动画功能在数据科学上的应用： 一个个地画出蒙特卡洛模拟数据，你能观察到最终的分布是如何逐步形成的； 按顺序遍历时间序列数据，可以描绘你的模型或数据在新的观察角度下有什么表现； 当你改变输入参数时，比如族群数，可以展现你的算法是如何划分族群的； 根据时间或不同的数据子集生成关联热力图，用于观察不同的样本是如何影响你的模型的预期参数的。","link":"/2019/09/18/The-Game-of-Life/"},{"title":"AI领域区分介绍","text":"说到人工智能(AI)的定义，映入脑海的关键词可能是“未来”，“科幻小说”，虽然这些因素看似离我们很遥远，但它却是我们日常生活的一部分。语音助手的普及、无人驾驶的成功，人工智能、机器学习、深度学习已经深入我们生活的各个场景。例如京东会根据你的浏览行为和用户的相似性，利用算法为你推荐你需要的产品；又比如美颜相机，会基于你面部特征的分析，通过算法精细你的美颜效果。还有众所周知的谷歌DeepMind，当AlphaGo打败了韩国职业围棋高手Lee Se-dol时，媒体描述这场人机对战的时候，提到了人工智能AI、机器学习、深度学习等术语。没错，这三项技术都为AlphaGo的胜利立下了汗马功劳，然而它们并不是一回事。 人工智能和机器学习的同时出现，机器学习和深度学习的交替使用……使大部分读者雾里看花，这些概念究竟有何区别，我们可以通过下面一个关系图来进行区分。 图一：人工智能、机器学习、深度学习的关系 人工智能包括了机器学习和深度学习，机器学习包括了深度学习。人工智能是机器学习的父类，机器学习则是深度学习的父类。 人工智能（Artificial Intelligence，AI）是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的与人类智能相似的方式作出反应的智能机器，它不是人的智能，但能像人那样思考、也可能超过人的智能。 人工智能实际应用：机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。人工智能目前也分为：强人工智能(BOTTOM-UPAI)和弱人工智能(TOP-DOWNAI)。 机器学习（Machine Learning，ML）是人工智能的核心，属于人工智能的一个分支。机器学习是指从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法，所以机器学习的核心是数据、算法（模型）、算力（计算机运算能力）。 机器学习应用领域：数据挖掘、数据分类、计算机视觉、自然语言处理(NLP)、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用等。 深度学习（Deep Learning，DL）：是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据。 数据挖掘（Data Mining，DM），顾名思义是指利用机器学习技术从海量数据中“挖掘”隐藏信息，主要应用于图像、声音、文本。在商业环境中，企业希望让存放在数据库中的数据能“说话”，支持决策。所以数据挖掘更偏向于应用。 图二：数据挖掘与机器学习的关系 机器学习是数据挖掘的一种重要方法，但机器学习是另一门学科，并不从属于数据挖掘，二者相辅相成。数据挖掘是机器学习和数据库的交叉，主要利用机器学习提供的技术来分析海量数据，利用数据库界提供的技术来管理海量数据。 不管是人工智能、机器学习、深度学习还是数据挖掘，目前都在解决共同目标时发挥了自己的优势，并为社会生产和人类生活提供便利，帮助我们探索过去、展示现状、预测未来。","link":"/2019/09/15/AI领域区分介绍/"},{"title":"为Anaconda3安装tensorflow等","text":"Anaconda3介绍简单来说，Anaconda是Python的包管理器和环境管理器。 先来解决一个初学者都会问的问题：我已经安装了Python，那么为什么还需要Anaconda呢？原因有以下几点： Anaconda附带了一大批常用数据科学包，它附带了conda、Python和 150 多个科学包及其依赖项。因此你可以用Anaconda立即开始处理数据。 管理包。Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这些包，包括安装、卸载和更新包。 管理环境。为什么需要管理环境呢？比如你在A项目中用到了Python2，而新的项目要求使用Python3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候conda就可以帮助你为不同的项目建立不同的运行环境。还有很多项目使用的包版本不同，比如不同的pandas版本，不可能同时安装两个pandas版本。你要做的应该是在项目对应的环境中创建对应的pandas版本。这时候conda就可以帮你做到。 Anaconda3的安装 官网地址 清华镜像 关于安装过程中的细节,如全局变量设置…可自行百度,下面我们转入正题 Anaconda3安装tensorflow 打开anaconda安装时自带的Anaconda prompt 打开后,输入清华镜像的tensorflow的下载地址(如果你已经在墙外翱翔了,可以省略这一步): 12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 接着我们开始创建一个python3.6的环境,因为如果你安装的是最新的anaconda,它默认环境为py3.7,并且在不久之前,tensorflow已经开始支持py3.6,所以我们创建一个py3.6环境:1conda create -n tensorflow python=3.6 启动anaconda中的py3.6环境:1activate tensorflow 如果不能进入,则重新执行第3步骤 进入py3.6的环境中后,我们就可以进行安装了(此处我们安装的是CPU版本的tensorflow):1pip install --upgrade --ignore-installed tensorflow 当我们不使用tensorflow时,我们就可以使用:1deactivate 退出该环境 开始测试一下是否安装成功: 重新打开Anaconda Prompt—&gt;activate tensorflow—&gt;python来启动tensorflow，并进入python环境 12345#TensorFlow使用图(Graph)来表示计算任务；并使用会话(Session)来执行图，通过Session.close()来关闭会话（这是一种显式关闭会话的方式）。会话方式有显式和隐式会话之分。import tensorflow as tfhello = tf.constant('Hello, TensorFlow!') #初始化一个TensorFlow的常量sess = tf.Session() #启动一个会话print(sess.run(hello)) 如果可以准确的输出结果,那么恭喜你,安装tensorflow成功! Anaconda3安装pytorch 打开anaconda安装时自带的Anaconda prompt 创建py3.6环境: 1conda create -n pytorch python=3.6 启动anaconda中的py3.6环境:1activate pytorch PyTorch 的官网提供了简单的安装方法，只需简单的命令即可。 首先，打开 PyTorch 官网安装页面（需自备梯子）：https://pytorch.org/get-started/locally/ 然后复制页面中Run this Command后的代码,粘贴在你的命令行,等待安装完成就可以了~ Anaconda3安装keras其实keras是可以与tensorflow在共同环境下使用的,所以我们可以直接将keras安装在我们的tensorflow环境中。 打开anaconda安装时自带的Anaconda prompt 创建py3.6环境: 1conda create -n tensorflow python=3.6 启动anaconda中的py3.6环境:1activate tensorflow 直接运行命令:123conda install keras或者pip install keras 等待安装完成即可~","link":"/2019/09/15/为Anaconda3安装tensorflow等/"},{"title":"使用cython加速代码运行","text":"引入毫无疑问，Python是社区最喜爱的编程语言!到目前为止，它是最容易使用的语言之一，因为python代码是用一种直观的、人类可读的方式编写的。 然而，你经常会反复听到一些对Python的抱怨，尤其是来自C语言爱好者的抱怨，这些抱怨无非就是Python很慢。 是的，他们并没有说错。 与许多其他编程语言相比，Python确实很慢。Benchmark game有一些比较不同编程语言在不同任务上的速度的可靠基准。 https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/gpp-python3.html?source=post_page 对于Python，我们有几种不同的方法可以加快速度: 1.使用多进程库来使用所有的CPU核心https://towardsdatascience.com/heres-how-you-can-get-a-2-6x-speed-up-on-your-data-pre-processing-with-python-847887e63be52.如果你使用Numpy、panda或Scikit-Learn，使用Rapids来加速GPU上的处理。https://towardsdatascience.com/heres-how-you-can-accelerate-your-data-science-on-gpu-4ecf99db3430 如果你所做的实际上可以并行化，比如数据预处理或矩阵运算，这些都是很好的方法。 但是如果你的代码是纯Python的呢?如果你不得不使用一个很大的for循环，且不能将数据放入矩阵中，因为数据必须按顺序处理，那会怎样?有没有办法加快Python本身的速度呢? 答案是肯定的，这就是Cython来加速原生Python代码的地方。 什么是Cython？Cython是Python和C/C++之间的一个中间步骤。它允许你编写纯Python代码，并且只需要做一些小修改，然后将其直接翻译成C代码。 你对Python代码所做的惟一调整就是向每个变量添加类型信息。通常，我们可以像这样在Python中声明一个变量: 1x = 5 使用Cython，我们将向该变量添加一个类型: 1cdef int x = 5 这告诉Cython，我们的变量是浮点类型，就像我们在C中所做的一样。对于纯Python，变量的类型是动态确定的。Cython中类型的显式声明使转换为C成为可能，因为显式类型声明是必须的。 安装Cython只需要一行简单的pip命令: 1pip install cython Cython中的类型使用Cython时，变量和函数分别有不同的类型。 对于变量我们有以下类型: cdef int a, b, c cdef char *s cdef float x = 0.5 (单精度) cdef double x = 63.4 (双精度) cdef list names cdef dict goals_for_each_play cdef object card_deck 注意所有这些类型都来自C/C++ ! 而对于方法我们有以下类型: def — 常规python函数，仅从python调用。 cdef — 不能从python的代码中访问Cython的函数。即必须在Cython内调用 cpdef — C 和 Python. 可以从C和Python中访问 了解了Cython类型之后，我们就可以直接实现加速了! 如何使用Cython加速python代码我们要做的第一件事是设置Python代码基准:用于计算数值阶乘的for循环。原生Python代码如下: 12345def test(x): y = 1 for i in range(x+1): y *= i return y 相同功能的Cython方法看起来非常相似。首先，我们将确保Cython代码文件具有.pyx扩展名。对代码本身的惟一更改是，我们已经声明了每个变量和函数的类型。 123456cpdef int test(int x): cdef int y = 1 cdef int i for i in range(x+1): y *= i return y Boom ! 可以看到我们的C代码已经编译好了，可以使用了! 你将看到，在Cython代码所在的文件夹中，你拥有运行C代码所需的所有文件，包括run_cython.c文件。如果你感兴趣，可以查看一下Cython生成的C代码! 现在我们准备测试我们新的并且超级快的C代码!查看下面的代码，它实现了一个速度测试，将原生Python代码与Cython代码进行比较。 123456789101112131415161718192021import run_pythonimport run_cythonimport timenumber = 10start = time.time()run_python.test(number)end = time.time()py_time = end - startprint(\"Python time = {}\".format(py_time))start = time.time()run_cython.test(number)end = time.time()cy_time = end - startprint(\"Cython time = {}\".format(cy_time))print(\"Speedup = {}\".format(py_time / cy_time)) 代码非常直观，我们以与普通Python相同的方式导入文件，并以与普通Python相同的方式运行函数! Cython几乎可以让你在所有原生Python代码上获得良好的加速，而不需要太多额外的工作。需要注意的关键是，循环次数越多，处理的数据越多，Cython可以提供的帮助就越多。 下表显示了Cython为不同的数值阶乘带来的加速性能。当数值为10000000的时候，可以看到，我们的Cython加速超过了36倍。 注意目前我的运行存在有 1DistutilsPlatformError: Unable to find vcvarsall.bat 错误,正在想办法解决,希望可以能尽快进入到一个c与python共存的世界 注意:该问题我已经解决，现在给出方法: 安装vsstudio2019，教程在:cython加速你的代码运行 参考文章:cython加速python使用 我运行的代码源文件:下载 使用笔记","link":"/2019/09/10/使用cython加速代码运行/"},{"title":"Git操作","text":"一.Git简介Git 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具。 Git 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从实用主和深入探索(后期更新)2个方面去谈谈如何在项目中使用 Git，一般来说，看完实用主义这一节就可以开始在项目中动手用。 说明：本文的操作都是基于Windows系统 二.实用主义1.准备阶段 工具准备 进入 Git官网下载合适你的安装包。 账号准备 进入Github网站 注册一个账号就可以使用了。 2.常用操作所谓实用主义，就是掌握了以下知识就可以玩转 Git，轻松应对90%以上的需求。以下是实用主义型的Git命令列表，先大致看一下: git clone git config git branch git checkout git status git add git commit git push git pull git log git tag (1)git clone 从git服务器拉取代码 1git clone https://github.com/user/repo.git (2)git config 配置开发者用户名和邮箱 12git config user.name usergit config user.email user@qq.com (3)git branch 创建、重命名、查看、删除项目分支，通过Git做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。 1git branch daily/0.0.0 创建一个名为daily/0.0.0的日常开发分支，分支名只要不包括特殊字符即可。 1git branch -m daily/0.0.0 daily/0.0.1 如果觉得之前的分支名不合适，可以为新建的分支重命名，重命名分支名为daily/0.0.1。 1git branch 通过不带参数的branch命令可以查看当前项目分支列表。 1git branch -d daily/0.0.1 如果分支已经完成使命则可以通过-d参数将分支删除，这里为了继续下一步操作，暂不执行删除操作。 (4)git checkout 切换分支 1git checkout daily/0.0.1 (5)git status 查看文件变动状态通过任何你喜欢的编辑器对项目中的 README.md 文件做一些改动，保存。 1git status 通过git status命令可以看到文件当前状态Changes not staged for commit:(改动文件未提交到暂存区） 123456On branch daily/0.0.1Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: README.mdno changes added to commit (use \"git add\" and/or \"git commit -a\") (6)git add 添加文件变动到暂存区 1git add README.md 通过指定文件名README.md可以将该文件添加到暂存区，如果想添加所有文件可用git add. 命令，这时候可通过git status看到文件当前状态Changes to be committed:（文件已提交到暂存区） 1234On branch daily/0.0.1Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) modified: README.md (7)git commit 提交文件变动到版本库 1git commit -m '这里写提交原因' 通过-m参数可直接在命令行里输入提交描述文本。 (8)git push 将本地的代码改动推送到服务器 1git push origin daily/0.0.1 origin 指代的是当前的git服务器地址，这行命令的意思是把 daily/0.0.1 分支推送到服务器，当看到命令行返回如下字符表示推送成功了。 12345678Counting objects: 3, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done.Total 3 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local objects.To https://github.com/gafish/gafish.github.com.git * [new branch] daily/0.0.1 -&gt; daily/0.0.1 现在我们回到Github网站的项目首页，点击Branch:master下拉按钮，就会看到刚才推送的daily/00.1分支了。 (9)git pull 将服务器上的最新代码拉取到本地 1git pull origin daily/0.0.1 如果其它项目成员对项目做了改动并推送到服务器，我们需要将最新的改动更新到本地，这里我们来模拟一下这种情况。 进入Github网站的项目首页，再进入daily/0.0.1分支，在线对README.md文件做一些修改并保存，然后在命令中执行以上命令，它将把刚才在线修改的部分拉取到本地，用编辑器打开README.md，你会发现文件已经跟线上的内容同步了。 如果线上代码做了变动，而你本地的代码也有变动，拉取的代码就有可能会跟你本地的改动冲突，一般情况下Git会自动处理这种冲突合并，但如果改动的是同一行，那就需要手动来合并代码，编辑文件，保存最新的改动，再通过git add .和git commit -m ‘xxx’来提交合并。 (10)git log 查看版本提交记录 1git log 通过以上命令，我们可以查看整个项目的版本提交记录，它里面包含了提交人、日期、提交原因等信息，得到的结果如下： 123456789commit c334730f8dba5096c54c8ac04fdc2b31ede7107aAuthor: gafish &lt;gafish@qqqq.com&gt;Date: Wed Jan 11 09:44:13 2017 +0800 Update README.mdcommit ba6e3d21fcb1c87a718d2a73cdd11261eb672b2aAuthor: gafish &lt;gafish@qqqq.com&gt;Date: Wed Jan 11 09:31:33 2017 +0800 test..... 提交记录可能会非常多，按J键往下翻，按K键往上翻，按Q键退出查看。 (11)git tag 为项目标记里程碑 12git tag publish/0.0.1git push origin publish/0.0.1 当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以publish/0.0.1为标记名并发布，当看到命令行返回如下内容则表示发布成功了。 123Total 0 (delta 0), reused 0 (delta 0)To https://github.com/gafish/gafish.github.com.git * [new tag] publish/0.0.1 -&gt; publish/0.0.1 (12).gitignore 设置哪些内容不需要推送到服务器，这是一个配置文件 1touch .gitignore .gitignore 不是Git命令，而在项目中的一个文件，通过设置.gitignore的内容告诉Git哪些文件应该被忽略不需要推送到服务器，通过以上命令可以创建一个.gitignore文件，并在编辑器中打开文件，每一行代表一个要忽略的文件或目录，如： 12demo.htmlbuild/ 以上内容的意思是Git将忽略demo.html文件 和build/目录，这些内容不会被推送到服务器上。 小结 通过掌握以上这些基本命令就可以在项目中开始用起来了，如果追求实用，那关于Git的学习就可以到此结束了，偶尔遇到的问题也基本上通过Google/百度也能找到答案。","link":"/2019/09/04/Git操作/"},{"title":"《深度学习入门》阅读笔记","text":"第1章 Python入门1.5.4 Numpy的N维数组12345import numpy as npa = np.array([[1,2],[3,4]])b = np.array([[3,0],[0,6]])print(a+b)print(a*b) 注意:数学上，一维数组称为向量；二维数组称为矩阵；可以将一般化后的向量或矩阵等统称为张量。 1.5.5 广播1234import numpy as npa = np.array([[1,2],[3,4]])b = np.array([10,20])print(a*b) 1.6.3 显示图像12345import matplotlib.pyplot as pltfrom matplotlib.image import imreadimg = imread('图片名称')plt.imshow(img)plt.show() 第2章 感知机感知机是神经网络(深度学习)的起源算法。 2.3.3 使用权重和偏置的实现权重值是控制输入信号的重要参数；偏置值调整了神经元被激活的容易程度。 2.4.2 线性和非线性单层感知机的局限性在于它只能表示由一条直线分割的区间。 2.5.2 异或门的实现叠加了多层的感知机称为多层感知机。 感知机的层数叫法问题。 2.6 从与非门到计算机实际上，使用感知机甚至可以表示计算机！ 第3章 神经网络当拥有感知机的同时我们也知道了两个消息： 好消息：对于复杂的函数，感知机也能通过叠加层数来有可能性的实现。 坏消息是：设定权重的工作在感知机中仍只能是由人工进行的。 而神经网络的出现就是为了解决来自感知机的坏消息。 3.1.3 激活函数登场激活函数的作用在于决定如何来激活输入信号的总和。 3.2 激活函数阶跃函数：函数以阈值为界，一旦输入超过阈值，就切换输出。 实际上，如果将激活函数从阶跃函数换成其他函数，我们就可以进入到神经网络的世界了。 3.2.5 sigmiod函数和阶跃函数的比较sigmoid函数是一条平滑的曲线，输出随着输入发生连续性变化；而阶跃函数以0为界，输出发生急剧性的变化。sigmoid函数的平滑性对神经网络的学习具有重要的意义。 也就是说，相对于感知机中的神经元只能返回0或1的信号，神经网络中返回的是连续的实数值信号。 相同点 两者的图像结构均表示为：“输入小时，输出接近0（为0）；输入大时，随着输入的增大，输出靠近1（为1）”。 不管输入的大小为多少，输出信号的值始终在0到1之间。 均为非线性函数。 不同点 阶跃函数：“竹筒敲石”。 sigmoid函数：“水车”。 3.2.6 非线性函数输出值为输入值的常数倍的函数称为线性函数。 为了发挥叠加层的优势，神经网络必须使用非线性函数。 3.5 输出层的设计神经网络可以使用在分类和回归问题上，不过需要根据情况改变输出层的激活函数 ，一般而言，回归问题用恒等函数，分类问题用softmax函数。 softmax函数python实现： 12345def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 3.5.2 使用softmax函数时的注意事项softmax函数的分子进行了指数的运算，可能会产生一些超大值，如果这些超大值进行除法运算，会出现”不确定”的情况，这就是产生了溢出问题。 改进的softmax函数python实现： 123456def softmax(a): c = np.max(a) exp_a = np.exp(a - c) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 3.5.4 输出层的神经元数量输出层的神经元数量需要根据需要解决的问题来决定。对于分类问题，输出层的神经元的数量一般设为类别的数量。 第4章 神经网络的学习“学习”是指从训练数据中自动获取最优权重参数的过程。 4.1.1 数据驱动对于一个数字“5”的识别，我们可以采用一些方法来识别： 人暴力想出一个算法识别，得出答案。-人参与 人想到特征量（如一个横，一个类似s构成了5），然后采用机器学习（SVM，KNN）得出答案。-人参与 神经网络（深度学习）利用数据学习，机器自己识别判断。-完全机器 深度学习也被称为端到端的机器学习。 神经网络的优点是对所有问题都可以采用同样的流程来解决，不管解决的是识别数字还是人脸，神经网络都是通过不断的学习所提供的数据，尝试发现待解决的问题。 4.1.2 训练数据和测试数据 训练数据：也称监督数据，用来训练新的模型的数据。 测试数据：为了检验模型的泛化能力。 泛化能力指处理未被观察过的数据（不包含在训练数据中的数据）的能力。 获得泛化能力是机器学习的最终目标。 4.4.1 梯度法根据寻找最小值还是最大值，寻找最小值的梯度法称为梯度下降法，寻找最大值的梯度法称为梯度上升法。但是通过反转损失函数的符号，求最大和最小值会变成相同的问题，所以一般来说，神经网络（深度学习）中，梯度法指的是梯度下降法。 第5章 误差反向传播法5.4 简单层的实现Affine层是负责矩阵乘积的。 第6章 与学习相关的技巧6.1.3 SGD的缺点为了改正SGD的缺点，我们可以使用优化算法Momentum，AdaGrad，Adam等。 第7章 卷积神经网络第8章 深度学习","link":"/2019/09/07/《深度学习入门》阅读笔记/"},{"title":"机器学习VS深度学习的区别","text":"本文我们主要涉及到: 数据相关性 硬件依赖性 特征工程 解决问题方法 执行时间 可解释性 1.数据的相关性深度学习与传统机器学习最重要的区别是，随着数据量的增加，其性能也随之提高。当数据很小的时候，深度学习算法并不能很好地执行，这是因为深度学习算法需要大量的数据才能完全理解它。下图便能很好的说明这个事实：从上图我们可以看到，随着数据量的增大，深度学习的性能会越来越好，而传统机器学习方法性能表现却趋于平缓；但传统的机器学习算法在数据量较小的情况下，比深度学习有着更好的表现。 2.硬件的依赖性深度学习算法在很大程度上依赖于高端机器，而传统的机器学习算法可以在低端机器上工作。这是因为深度学习算法对GPU有较高的要求，GPU是其工作的一个组成部分。因为深度学习算法要固有地执行大量的矩阵乘法运算，而使用GPU可以有效地优化这些操作，这就免不了对GPU的依赖。而相比之下，机器学习算法对硬件配置没有很高的要求。 3.特征工程特征工程是将领域知识应用到特征抽取的创建过程，以降低数据的复杂性为目的。但这一过程在训练时间和如何提取特征方面十分地困难。 在机器学习中，大多数应用的特征需要由专家识别，然后根据域和数据类型手工编码。 例如，特征可以是像素值、形状、纹理、位置和方向，大多数机器学习算法的性能取决于特征识别和提取的准确程度。 而深度学习算法则试图从数据中学习更高级的特性。这是深度学习一个非常独特的部分，也是有别于传统机器学习的一部分。因此，深度学习减少了为每个问题开发新的特征抽取的任务，而是像卷积神经网络（CNN）这样尝试学习低层次的特征，如：早期层次的边缘和线条，然后是人脸的一部分，最后才是人脸的高层次表示。这样的方式相较于机器学习，在训练时间和成本上有较高的提升。 4.解决问题方法在使用传统的机器学习算法解决问题时，通常的做法是将问题分解成不同的部分，然后单独解决，最后结合起来得到结果。相比之下，深度学习更提倡端到端地解决问题。让我们举个例子来理解这一点。如图所示是一个多对象检测任务，我们的目标是哟啊确定对象是什么以及它在图像中的位置。 在典型的机器学习方法中，我们会将问题分为两个步骤：对象检测和对象识别。首先，我们将使用一个边界检测算法，如：GrabCut，来浏览图像并找到图像中所有可能的对象；然后，在所有已识别的对象中，我们再使用对象识别算法（如：SVM）来识别相关对象，最后再判断对象的位置。 不同于传统机器学习算法，在深度学习的方法中，我们将进行端到端的学习过程。例如，使用YOLO算法（一种深度学习算法）。我们往YOLO网络中传入一张图像，它将给出对象的具体位置和名称。是不是方便了很多呢？ 5.执行时间通常，深度学习算法需要很长的时间来训练，这是因为在深度学习算法中有太多的参数，所以训练这些参数的时间比平时要长。即使比较先进的深度学习算法Resnet，从零开始完全训练也需要大约两周的时间。相比之下，机器学习所需的训练时间要少得多，从几秒钟到几个小时不等。 相较于训练时间，测试时间就要短很多。在测试时，深度学习算法的运行时间要短得多。但是，如果将其与k近邻机器学习算法进行比较，测试时间会随着数据大小的增加而增加。但这并不适用于所有机器学习算法，因为其中一些算法的测试时间也很短。 6.可解释性最后，我们将可解释性作为比较机器学习和深度学习的一个因素。这一因素也是深度学习难以在工业中取得大规模应用的主要原因。 我们举个例子：假设我们使用深度学习为论文自动评分，它在得分方面的表现相当出色，接近于人类的表现。但有一个问题：深度学习并没有揭示它为什么会给出那个分数。事实上，从数学中我们可以发现深度神经网络的哪些节点被激活，但是我们不知道神经元应该做什模型以及这些神经元层共同在做什么，所以我们无法对结果进解释。 而相较于深度学习，类似于决策树这样的机器学习算法为我们提供了清晰的规则，告诉我们什么是它的选择以及为什么选择了它，很容易解释算法背后的推理。因此，决策树和线性/逻辑回归等机器学习算法主要用于工业中需要可解释性的场景。","link":"/2019/09/05/机器学习VS深度学习的区别/"},{"title":"关于论文作者那点事","text":"对于论文想必大家可能都有过耳闻,今天做一下一些相关知识的普及~ 首先,第一作者和通讯作者之间一直是缠缠绵绵到天涯的关系，很多人对这两者并不陌生，但是在一些细节上的问题又感觉比较绕，我今天特意收集了平时大家提到的关于两者之间的一些问题，做成问答集锦，你想知道的，都在里面啦~ 什么是第一作者？第一作者通常主导大部分的实验工作，在一般的情况下，引用一篇论文时，提到的就是第一作者的名字，如 Tomas et al. report that…。 以第一作者的身份进行论文发表对博士生的科研路是很重要的，不止中国，全球大部分的博士毕业标准都要求学生要作为第一作者发表至少一篇论文。 对博士后及资深教授来说，作为第一作者的期刊论文发表是争取基金、职称晋升及续聘时的重要因素。据此，期刊论文的作者名单里，第一个名字一直是最抢手的位置。 在第一作者之后，作者顺序是根据对研究的贡献度排序，贡献度越高的排名越前。不过，有时候可能会有多位作者贡献度相同，这时候就可以列为共同一作、共同二作… 注意:第一作者很重要很重要很重要，要毕业、评职称、争基金…没头发可以，没它不行~ 什么是通讯作者？通讯作者是课题的总负责人，承担课题的经费、设计、文章的书写和把关，在投稿、同行评审和整个发表流程中负责和期刊沟通。从知识产权的角度来说，研究成果算是通讯作者的。能当通讯作者的人一般有以下几类： 论文的法定负责人: 通讯作者也是论文的主要受益人之一。也可以这么说，论文的第一作者是这项科研成果的主要贡献者，而论文的通讯作者是这项成果的责任者和受益人。 导师、教授、科研项目的主要负责人 其主要贡献是提供研究指导、研究经费、试验场所、实验室、仪器设备等与实验相关的物质资源。 论文的任何作者 要是一篇论文有数个作者，通讯作者可以是他们中的任何一位。至于到底是谁，主要看通讯作者在这项研究中真正起的作用和做出的贡献。要是他在整个实验中做到了关键的作用，那么他就理所当然地即可做第一作者，也可做通讯作者。 注意: 对于学生来说，通讯作者一般是他的导师。 对于研究机构来说，通讯作者一般是项目负责人。 对于出版机构来说，通讯作者可以是机构老板。 另外！！！一定要有固定的通讯地址！ 第一作者和通讯作者，谁更重要？通讯作者未必是第一作者，但第一作者可以是通讯作者。通讯作者多数情况和第一作者是同一个人，只有在通讯作者和第一作者不一致的时候，才有必要在文章脚注中附加通讯作者的标识。 所以，总的来说都重要！对于作者来说，第一作者很重要，谁是通讯作者没关系，但是通讯单位很关键，很多单位评职称看通讯单位，不看通讯作者。对于导师来说，通讯作者重要，因为导师永远当通讯作者，至于谁是第一作者不重要。对于出版机构来说，通讯作者非常重要，因为机构老板也常是通讯作者… 注意:通讯作者不是随便挂的，一旦出现通讯作者，这篇文章的科研版权就要非常注意了~ 共同一作排序重要吗，会影响评职称吗？共同作者排在第一位的是最好，所有东西都可以申请。因为排第一的肯定是第一作者，大家引用的时候都会缩写成“First-Author, et al，但是排在第二位就要小心了，排在第二位的虽然也是共同第一作者，但是有些单位只看第一位的，所以评职称的时候一定要问清楚单位科研处排在第二的共同作者能否评职称。 不过事无绝对，以下一些例子里面的共同一作和第一作者的贡献量和含金量差不多，排序嘛，就比较随便了··· 按作者名字的字母顺序决定作者排序 抛硬币决定作者顺序 根据对星战的痴迷程度决定作者顺序 根据申tenure的时间远近决定作者顺序 注意:国内对作者排序还是很重视的，很多机构和单位甚至只认可排序靠前的，所以能排前面就别排后面啦~ 所有的论文都要有通讯作者吗？并不是要求所有的论文都一定要写通讯作者。对于没有通讯作者的稿件，默认第一作者为通讯作者。 通讯作者多数情况和第一作者是同一个人，这样的话实际上是省略了通讯作者。只有在通讯作者和第一作者不一致的时候，才有必要加通讯作者。不赞成一味地模仿国外杂志，加不加通讯作者应根据需要而定。 注意:通讯作者非必须，随意模仿不可取~ 我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？目前，最常见的做法是权力最大的排最后，权力排倒数第二，也就是大老板排最后，小老板排倒数第二。一般期刊只能允许两位通讯作者，在文章中标注，列出他们的邮箱，偶尔也会看见有些期刊会有三个通讯，不过也有些期刊不准共同通讯，只能一个人。所以在投稿前一定要仔细阅读稿约。 注意:根据权力大小排就对了！ 导师可以既是第一作者，又是通讯作者吗？可以。第一作者兼任通讯作者没什么问题，更何况，对单一作者的论文来说，第一作者和通讯作者肯定是同一个人。如果你的教授对研究也出谋划策，拟出初始计划和研究设计，一定要将他列为共同作者。至于具体怎么做，还是需要跟导师商量，达成一致，避免日后产生争议。 注意:导师可以既当第一作者，又当通讯作者。 论文被接受，还能更换作者顺序和通讯作者吗？一般来说，期刊对于作者顺序变更不会有太大的意见，但非必要最好避免更换通讯作者，因为期刊编辑和通讯作者之间已经有过交流，有一定的熟悉程度。 不过，如果有不可抗拒的因素需要换通讯作者跟作者顺序的话，一定要跟编辑沟通解释清楚，因为这会涉及到之后的一系列问题，例如评职称、申奖金等等。另外，修改作者的时候，一定要附上新的版权~ 注意:作者顺序可以改，通讯作者最好不要改！ 不是通讯作者可以直接和期刊编辑联系吗？通讯作者的作用就是期刊编辑最主要的联系窗口，相关的沟通事宜都是通讯作者负责，不是通讯作者最好不要和期刊编辑联系，为避免将事情复杂化，最好是将事情积极反馈给通讯作者，再由通讯作者和期刊编辑沟通。 注意:让通讯作者架起沟通的桥梁~ 论文被查出学术不端，负责的应该是第一作者还是通讯作者？通讯作者是要对论文的全程进行把关的。特别是对里面内容的真实性，论证的根据等，有没有达到发表的水平。所以，通讯作者，既是一个署名权，更重要的是对这篇学术论文承担的责任。如果这篇文章出问题，通讯作者是第一责任人！当然那些没有被告知，就被别人列为论文的通讯作者，还是会有背黑锅的时候··· 注意:通讯作者负责就要负到底！ 让有名望的学者当通讯作者是不是能增加论文的投中率？如果在学术界口碑好、有名望教授当自己论文的通讯作者，会增加论文的投中率。因为通讯作者需要对论文把关，好口碑的教授一般学风严谨，出任通讯作者也是以自己的名誉来做担保，所以编辑在审查的时候，也会增加对论文的好感度，最后能不能投中关键的还是看论文的质量。 注意:论文能不能投中关键还是靠质量~ 最后,提醒一下大家：研究项目启动前是决定署名作者及其排名顺序的最佳时机，参与项目的团队成员必须在这些方面达成完全一致，毕竟按劳所得是亘古不变的真理~","link":"/2019/09/15/关于论文作者那点事/"},{"title":"镜像站","text":"网易镜像：http://mirrors.163.com/ 阿里云镜像：http://mirrors.aliyun.com/ 中国科学技术大学镜像：http://mirrors.ustc.edu.cn/ 厦门大学镜像：http://mirrors.xmu.edu.cn/ 搜狐镜像：http://mirrors.sohu.com/ 北京交通大学镜像：http://mirror.bjtu.edu.cn/ 北京理工大学镜像：http://mirror.bit.edu.cn/web/ 兰州大学镜像：http://mirror.lzu.edu.cn/ 上海交通大学镜像：http://ftp.sjtu.edu.cn/ 清华大学镜像：https://mirrors.tuna.tsinghua.edu.cn/ 东北大学镜像：http://mirror.neu.edu.cn/ 浙江大学镜像：http://mirrors.zju.edu.cn/ 东软信息学院：http://mirrors.neusoft.edu.cn/ 重庆大学镜像：http://mirrors.cqu.edu.cn/ 大连理工大学镜像：http://mirror.dlut.edu.cn/ CN99镜像：http://mirrors.cn99.com/","link":"/2019/09/18/镜像站/"},{"title":"机器学习分类算法","text":"说起分类算法，相信学过机器学习的同学都能侃上一二。 可是，你能够如数家珍地说出所有常用的分类算法，以及他们的特征、优缺点吗？比如说，你可以快速地回答下面的问题么: KNN算法的优缺点是什么？ Naive Bayes算法的基本假设是什么？ entropy loss是如何定义的？ 最后，分类算法调参常用的图像又有哪些？ 可能真的涉及这些问题时候，我们不能快速的回答，所以我总结了此文~ 机器学习是一种能从数据中学习的计算机编程科学以及艺术，就像下面这句话说得一样。 机器学习是使计算机无需显式编程就能学习的研究领域。——阿瑟·塞缪尔，1959年 不过还有一个更好的定义： “如果一个程序在使用既有的经验（E）执行某类任务（T）的过程中被认为是“具备学习能力的”，那么它一定需要展现出:利用现有的经验（E），不断改善其完成既定任务（T）的性能（P）的特性。” ——Tom Mitchell, 1997 例如，你的垃圾邮件过滤器是一个机器学习程序，通过学习用户标记好的垃圾邮件和常规非垃圾邮件示例，它可以学会标记垃圾邮件。系统用于学习的示例称为训练集。在此案例中，任务（T）是标记新邮件是否为垃圾邮件，经验（E）是训练数据，性能度量（P） 需要定义。例如，你可以定义正确分类的电子邮件的比例为P。这种特殊的性能度量称为准确度，这是一种有监督的学习方法，常被用于分类任务。 监督学习在监督学习中，算法从有标记数据中学习。在理解数据之后，该算法通过将模式与未标记的新数据关联来确定应该给新数据赋哪种标签。 监督学习可以分为两类：分类和回归。 分类问题预测数据所属的类别； 分类的例子包括垃圾邮件检测、客户流失预测、情感分析、犬种检测等。 回归问题根据先前观察到的数据预测数值； 回归的例子包括房价预测、股价预测、身高-体重预测等。 分类问题分类是一种基于一个或多个自变量确定因变量所属类别的技术。 分类算法逻辑回归逻辑回归类似于线性回归，适用于因变量不是一个数值字的情况 (例如，一个“是/否”的响应)。它虽然被称为回归，但却是基于根据回归的分类，将因变量分为两类。 如上所述，逻辑回归用于预测二分类的输出。例如，如果信用卡公司构建一个模型来决定是否通过向客户的发行信用卡申请，它将预测客户的信用卡是否会“违约”。 首先对变量之间的关系进行线性回归以构建模型，分类的阈值假设为0.5。 然后将Logistic函数应用于回归分析，得到两类的概率。 该函数给出了事件发生和不发生概率的对数。最后，根据这两类中较高的概率对变量进行分类。 K-近邻算法（K-NN）K-NN算法是一种最简单的分类算法，通过识别被分成若干类的数据点，以预测新样本点的分类。K-NN是一种非参数的算法，是“懒惰学习”的著名代表，它根据相似性（如，距离函数）对新数据进行分类。 K-NN能很好地处理少量输入变量（p）的情况，但当输入量非常大时就会出现问题。 支持向量机（SVM）支持向量机既可用于回归也可用于分类。它基于定义决策边界的决策平面。决策平面（超平面）可将一组属于不同类的对象分离开。 在支持向量的帮助下，SVM通过寻找超平面进行分类，并使两个类之间的边界距离最大化。 SVM中超平面的学习是通过将问题转化为使用一些某种线性代数转换问题来完成的。（上图的例子是一个线性核，它在每个变量之间具有线性可分性）。 对于高维数据，使用可使用其他核函数，但高维数据不容易进行分类。具体方法将在之后阐述。 核支持向量机核支持向量机将核函数引入到SVM算法中，并将其转换为所需的形式，将数据映射到可分的高维空间。 核函数的类型包括： 前文讨论的就是线性SVM。 多项式核中需要指定多项式的次数。它允许在输入空间中使用曲线进行分割。 径向基核（radial basis function, RBF）可用于非线性可分变量。使用平方欧几里德距离，参数的典型值会导致过度拟合。sklearn中默认使用RBF。 类似于与逻辑回归类似，sigmoid核用于二分类问题。 径向基核（RBF：Radial Basis Function ）RBF核支持向量机的决策区域实际上也是一个线性决策区域。RBF核支持向量机的实际作用是构造特征的非线性组合，将样本映射到高维特征空间，再利用线性决策边界分离类。 因此，可以得出经验是：对线性问题使用线性支持向量机，对非线性问题使用非线性核函数，如RBF核函数。 朴素贝叶斯朴素贝叶斯分类器建立在贝叶斯定理的基础上，基于特征之间互相独立的假设（假定类中存在一个与任何其他特征无关的特征）。即使这些特征相互依赖，或者依赖于其他特征的存在，朴素贝叶斯算法都认为这些特征都是独立的。这样的假设过于理想，朴素贝叶斯因此而得名。 在朴素贝叶斯的基础上，高斯朴素贝叶斯根据二项（正态）分布对数据进行分类。 P(class|data) 表示给定特征（属性）后数据属于某类（目标）的后验概率。给定数据，其属于各类的概率大小就是我们要计算的值。 P(class)表示某类的先验概率。 P(data|class)表示似然，是指定类别时特征出现的概率。 P(data)表示特征或边际似然的先验概率。 步骤: 1、计算先验概率 P(class) = 类中数据点的数量/观测值的总数量 P(yellow) = 10/17 P(green) = 7/17 2、计算边际似然 P(data) = 与观测值相似的数据点的数量/观测值的总数量 P(?) = 4/17 该值用于检查各个概率。 3、计算似然 P(data/class) = 类中与观测值相似的数量/类中点的总数量 P(?/yellow) = 1/7 P(?/green) = 3/10 4、计算各类的后验概率 5、分类 某一点归于后验概率高的类别，因为从上可知其属于绿色类的概率是75%根据其75%的概率这个点属于绿色类。 多项式、伯努利朴素贝叶斯是计算概率的其他模型。朴素贝叶斯模型易于构建，不需要复杂的参数迭代估计，这使得它对非常大的数据集特别有用。 决策树分类决策树以树状结构构建分类或回归模型。它通过将数据集不断拆分为更小的子集来使决策树不断生长。最终长成具有决策节点（包括根节点和内部节点）和叶节点的树。最初决策树算法它采用采用Iterative Dichotomiser 3（ID3）算法来确定分裂节点的顺序。 信息熵和信息增益用于被用来构建决策树。 信息熵信息熵是衡量元素无序状态程度的一个指标，即衡量信息的不纯度。 信息熵是衡量元素的无序状态的程度的一个指标，或者说，衡量信息的不纯度。 直观上说地理解，信息熵表示一个事件的确定性程度。信息熵度量样本的同一性，如果样本全部属于同一类，则信息熵为0；如果样本等分成不同的类别，则信息熵为1。 信息增益信息增益测量独立属性间信息熵的变化。它试图估计每个属性本身包含的信息，构造决策树就是要找到具有最高信息增益的属性（即纯度最高的分支）。 信息增益测量独立属性间的信息熵的变化。它试图估计每个属性本身包含的信息，构造决策树就是要找到具有最高信息增益的属性（即纯度最高的分支）。 其中Gain（(T,X）)是特征X的信息增益。Entropy(T)是整个集合的信息熵，第二项Entropy(T,X)是特征X的信息熵。 采用信息熵进行节点选择时，通过对该节点各个属性信息增益进行排序，选择具有最高信息增益的属性作为划分节点，过滤掉其他属性。 决策树模型存在的一个问题是容易过拟合。因为在其决策树构建过程中试图通过生成长一棵完整的树来拟合训练集，因此却降低了测试集的准确性。 通过剪枝技术可以减少小决策树的过拟合问题。 分类的集成算法集成算法是一个模型组。从技术上说，集成算法是单独训练几个有监督模型，并将训练好的模型以不同的方式进行融合，从而达到最终的得预测结果。集成后的模型比其中任何一个单独的模型都有更高的预测能力。 随机森林分类器随机森林分类器是一种基于装袋（bagging）的集成算法，即自举助聚合法(bootstrap aggregation)。集成算法结合了多个相同或不同类型的算法来对对象进行分类（例如，SVM的集成，基于朴素贝叶斯的集成或基于决策树的集成）。 集成的基本思想是算法的组合提升了最终的结果。 深度太大的决策树容易受过拟合的影响。但是随机森林通过在随机子集上构建决策树防止过拟合，主要原因是它会对所有树的结果进行投票的结果是所有树的分类结果的投票，从而消除了单棵树的偏差。 随机森林在决策树生增长的同时为模型增加了额外的随机性。它在分割节点时，不是搜索全部样本最重要的特征，而是在随机特征子集中搜索最佳特征。这种方式使得决策树具有多样性，从而能够得到更好的模型。 梯度提升分类器梯度提升分类器是一种提升集成算法。提升(boosting)算法是为了减少偏差而对弱分类器的而进行的一种集成方法。与装袋（bagging）方法构建预测结果池不同，提升算法是一种分类器的串行方法，它把每个输出作为下一个分类器的输入。通常，在装袋算法中，每棵树在原始数据集的子集上并行训练，并用所有树预测结果的均值作为模型最终的预测结果；梯度提升模型，采用串行方式而非并行模式获得预测结果。每棵决策树预测前一棵决策树的误差，因而使误差获得提升。 使用浅层决策树初始化预测结果。 计算残差值（实际预测值）。 构建另一棵浅层决策树，将上一棵树的残差作为输入进行预测。 用新预测值和学习率的乘积作为最新预测结果，更新原有预测结果。 重复步骤2-4，进行一定次数的迭代（迭代的次数即为构建的决策树的个数）。 如果想了解更多关于梯度提升分类器的知识，可参考：https://medium.com/mlreview/gradient-boosting-from-scratch-1e317ae4587d%20/t%20_blank 分类器的性能混淆矩阵混淆矩阵是一张表，这张表通过对比已知分类结果的测试数据的预测值和真实值表来描述衡量分类器的性能。在二分类的情况下，混淆矩阵是展示预测值和真实值四种不同结果组合的表。 多分类问题的混淆矩阵可以帮助你确认错误模式。 对于二元分类器： 假正例&amp;假负例假正例和假负例用来衡量模型预测的分类效果。假正例是指模型错误地将负例预测为正例。假负例是指模型错误地将正例预测为负例。主对角线的值越大（主对角线为真正例和真负例），模型就越好；副对角线给出模型的最差预测结果。 假正例下面给出一个假正例的例子。比如：模型将一封邮件分类为垃圾邮件（正例），但这封邮件实际并不是垃圾邮件。这就像一个警示，错误如果能被修正就更好，但是与假负例相比，它并不是一个严重的问题。 作者注：个人观点，这个例子举的不太好，对垃圾邮件来说，相比于错误地将垃圾邮件分类为正常邮件（假负例），将正常邮件错误地分类为垃圾邮件（假正例）是更严重的问题。 假正例（I型错误）——原假设正确而拒绝原假设。 假负例假负例的一个例子。例如，该模型预测一封邮件不是垃圾邮件（负例），但实际上这封邮件是垃圾邮件。这就像一个危险的信号，错误应该被及早纠正，因为它比假正例更严重。 假负例（II型错误）——原假设错误而接受原假设。 上图能够很容易地说明上述指标。左图男士的测试结果是假正例因为男性不能怀孕；右图女士是假负例因为很明显她怀孕了。 从混淆矩阵，我们能计算出准确率、精度、召回率和F-1值。 准确率准确率是模型预测正确的部分。 准确率的公式为： 当数据集不平衡，也就是正样本和负样本的数量存在显著差异时，单独依靠准确率不能评价模型的性能。精度和召回率是衡量不平衡数据集的更好的指标。 精度精度是指在所有预测为正例的分类中，预测正确的程度为正例的效果。 精度越高越好。 召回率召回率是指在所有预测为正例（被正确预测为真的和没被正确预测但为真的）的分类样本中，召回率是指预测正确的程度。它，也被称为敏感度或真正率（TPR）。 召回率越高越好。 F-1值通常实用的做法是将精度和召回率合成一个指标F-1值更好用，特别是当你需要一种简单的方法来衡量两个分类器性能时。F-1值是精度和召回率的调和平均值。 普通的通常均值将所有的值平等对待，而调和平均值给予较低的值更高的权重，从而能够更多地惩罚极端值。所以，如果精度和召回率都很高，则分类器将得到很高的F-1值。 接受者操作曲线（ROC）和曲线下的面积（AUC）ROC曲线是衡量分类器性能的一个很重要指标，它代表模型准确预测的程度。ROC曲线通过绘制真正率和假正率的关系来衡量分类器的敏感度。如果分类器性能优越，则真正率将增加，曲线下的面积会接近于1.如果分类器类似于随机猜测，真正率将随假正率线性增加。AUC值越大，模型效果越好。 累积精度曲线CAP代表一个模型沿y轴为真正率的累积百分比与沿x轴的该分类样本累积百分比。CAP不同于接受者操作曲线（ROC，绘制的是真正率与假正率的关系）。与ROC曲线相比，CAP曲线很少使用。 以考虑一个预测客户是否会购买产品的模型为例，如果随机选择客户，他有50%的概率会购买产品。客户购买产品的累积数量会线性地增长到对应客户总量的最大值，这个曲线称为CAP随机曲线，为上图中的蓝色线。而一个完美的预测，准确地确定预测了哪些客户会购买产品，这样，在所有样本中只需选择最少的客户就能达到最大购买量。这在CAP曲线上产生了一条开始陡峭一旦达到最大值就会维持在1的折线，称为CAP的完美曲线，也被称为理想曲线，为上图中灰色的线。 最后，一个真实的模型应该能尽可能最大化地正确预测，接近于理想模型曲线。","link":"/2019/09/12/机器学习分类算法/"}],"tags":[{"name":"生命游戏","slug":"生命游戏","link":"/tags/生命游戏/"},{"name":"机器学习","slug":"机器学习","link":"/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","link":"/tags/深度学习/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"Cython","slug":"Cython","link":"/tags/Cython/"},{"name":"Git常用操作","slug":"Git常用操作","link":"/tags/Git常用操作/"},{"name":"论文","slug":"论文","link":"/tags/论文/"},{"name":"镜像","slug":"镜像","link":"/tags/镜像/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"阅读笔记","slug":"阅读笔记","link":"/categories/阅读笔记/"},{"name":"杂谈","slug":"杂谈","link":"/categories/杂谈/"}]}